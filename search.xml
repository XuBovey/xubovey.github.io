<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[linux程序安装和arm移植的一点理解]]></title>
      <url>https://xubovey.github.io/2019/08/09/190809-linux-install-arm/</url>
      <content type="html"><![CDATA[<h2 id="之前的理解"><a href="#之前的理解" class="headerlink" title="之前的理解"></a>之前的理解</h2><p>知道<code>sudo apt-get install ***</code>可以安装一些工具、软件。但是实际上对安装过程的理解并不是很懂。<br>后来会用过make config, make install之类来安装。了解到源码的编译安装过程。
但是如何装到内核文件系统还是不太了解</p>
<h2 id="新的领悟"><a href="#新的领悟" class="headerlink" title="新的领悟"></a>新的领悟</h2><p><code>echo $PATH</code>这个命令是经常会用的，还用过<code>env</code>查看所有环境变量。但是并不知道这些变量哪里来的。
刚才忽然想到应该是这样，make的时候完成对源文件的编译，make install的时候会进行编译输出文件的复制和环境变量的配置。
所以应用文件移植到arm的过程就是用<code>arm-linux-gnueai-*</code>进行编译，安装到指定文件夹，
然后把文件夹复制到arm内核文件系统。再把相关路径添加到<code>PATH</code>环境变量里就应该可以了。  </p>
<ol>
<li>下载安装包源文件</li>
<li>用arm编译工具编译安装包</li>
<li>把软件包安装到指定文件夹下</li>
<li>把输出文件夹内的文件复制到arm文件系统</li>
<li>修改arm文件系统的环境变量<code>etc/profile</code></li>
</ol>
<h2 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h2><p>//todo</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[150G的C盘又满了]]></title>
      <url>https://xubovey.github.io/2019/06/20/190620-clean-my-pc/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>C盘100G满的时候扩容到了150G，如今又提示不到13G了。。。</p>
<h2 id="不能忍"><a href="#不能忍" class="headerlink" title="不能忍"></a>不能忍</h2><p>眼睁睁看着C盘变大的时候，尝试过很多种廋身办法都没啥效果。</p>
<h2 id="绝地反击"><a href="#绝地反击" class="headerlink" title="绝地反击"></a>绝地反击</h2><p>后来发现在C盘取消所有文件隐藏的条件下，选中所有文件，查看大小是100G，这里消失的几十G哪里去了。。。
然后就想着如何查看文件夹大小，接着就找到了工具wiztree，这个是好东西，软件很小，但是能几秒内统计100G的文件大小，并用色块表示文件大小。这样很容易就定位到了一些好几G的大文件夹，找到没用的删除之。
其中有1个文件是N卡驱动缓存文件，5-6个G，使用工具DriverStoreExplorer.v0.10.39完成扫码驱动备份，并删除老版本的驱动</p>
<h2 id="C-windows-softwaredistribution过大处理"><a href="#C-windows-softwaredistribution过大处理" class="headerlink" title="C:\windows\softwaredistribution过大处理"></a>C:\windows\softwaredistribution过大处理</h2><p>需要以管理员身份启动cmd
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    Start&gt;Run</span><br><span class="line">   <span class="built_in"> type </span>cmd <span class="keyword">and</span> press enter</span><br><span class="line">   <span class="built_in"> type </span>net stop wuauserv <span class="keyword">and</span> press enter</span><br><span class="line">   <span class="built_in"> type </span>rename c:\windows\SoftwareDistribution softwaredistribution.old <span class="keyword">and</span> press enter</span><br><span class="line">   <span class="built_in"> type </span>net start wuauserv <span class="keyword">and</span> press enter</span><br><span class="line">   <span class="built_in"> type </span>exit <span class="keyword">and</span> press enter</span><br></pre></td></tr></table></figure></p>
<h2 id="Hiberfil-sys很大"><a href="#Hiberfil-sys很大" class="headerlink" title="Hiberfil.sys很大"></a>Hiberfil.sys很大</h2><p>Hiberfil.sys 是 Windows 休眠功能（Windows Hibernation）将内存数据与会话保存至硬盘、
以便计算机断电重新启动后可以快速恢复会话所需的内存镜像文件。在早期版本的 Windows 中，Hiberfil.sys 
文件的大小等同于物理内存大小；而在 Windows 7 中，Hiberfil.sys 可以在物理内存大小的 50%－100% 的范围自行调整。
因此， Windows 7 的 Hiberfil.sys 大小不一定等同于物理内存大小。
需要以管理员身份启动cmd
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmd</span><br><span class="line">powercfg -h off <span class="comment">//关系休眠，该文件可删除</span></span><br><span class="line">powercfg -h <span class="keyword">on</span>  <span class="comment">//如果需要可执行该命令，再次启动休眠</span></span><br></pre></td></tr></table></figure></p>
<h2 id="惨痛的教训"><a href="#惨痛的教训" class="headerlink" title="惨痛的教训"></a>惨痛的教训</h2><p>C:\Program Files\目录下有uninstall.exe文件，还有一些数据库文件，数据库相关的文件日期是14年的，可能是什么时候装软件选择的不对没有放到文件夹下。想用uninstall删除，结果悲催了。这个文件居然开始删除adobe和autocad，赶紧任务管理杀掉进程。后来分析uninstall是用来删除文件夹下其他文件的，所以…如果放任不管，我可能就真的悲催了。
就这样重装了adobe，autocaad，7zip，git等问题解决。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu mplayer no voice]]></title>
      <url>https://xubovey.github.io/2019/06/10/190610-ubuntu-mplayer-no-voice/</url>
      <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>ubuntu环境18.04下
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install mplayer</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> <span class="builtin-name">remove</span> mplayer</span><br></pre></td></tr></table></figure></p>
<h2 id="播放MP3"><a href="#播放MP3" class="headerlink" title="播放MP3"></a>播放MP3</h2><p>在mp3文件夹下执行
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mplayer</span> <span class="selector-tag">xxx</span><span class="selector-class">.mp3</span></span><br></pre></td></tr></table></figure></p>
<p>执行播放后无声音。发现Ubuntu下设置声音为静音。。。。打开后输出声音正常</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[190427-ubuntu-qt-ide]]></title>
      <url>https://xubovey.github.io/2019/04/27/190427-ubuntu-qt-ide/</url>
      <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/meteor_s/article/details/79307496" target="_blank" rel="noopener">Ubuntu–搭建QT开发环境</a></p>
<h2 id="各种装"><a href="#各种装" class="headerlink" title="各种装"></a>各种装</h2><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install qt4-<span class="built_in">dev</span>-tools		<span class="comment">//QT资源包</span></span><br><span class="line">sudo apt-<span class="built_in">get</span> install qt4-qtconfig		<span class="comment">//配置工具</span></span><br><span class="line"><span class="comment">//sudo apt-get install qt-demos			//官方案例源代码</span></span><br><span class="line"><span class="comment">//sudo apt-get install qtcreator			//IDE</span></span><br></pre></td></tr></table></figure>
<p>安装过程出现依赖项问题，解决办法：
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo aptitude <span class="keyword">install</span> qtcreator</span><br></pre></td></tr></table></figure></p>
<p>安装过程遇到<code>libclang-3.6 libobjc-5-dev libobjc4</code>没有安装，输入<code>n</code>,切换解决方案。部分库版本过高，选择降版本处理。</p>
<p>安装完成后执行
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qmake -v</span><br><span class="line"><span class="comment"># QMake version 2.0.1a</span></span><br><span class="line">Using Qt version <span class="number">4.8</span>.<span class="number">7</span> in /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">x86_64</span>-<span class="title">linux</span>-<span class="title">gnu</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="编译工具"><a href="#编译工具" class="headerlink" title="编译工具"></a>编译工具</h2><ol>
<li>下载poky
下载路径：<a href="https://pan.baidu.com/s/11WdTVIuiZNdrW1f5QjYAQA" target="_blank" rel="noopener">https://pan.baidu.com/s/11WdTVIuiZNdrW1f5QjYAQA</a>
提取码：9zhv</li>
<li>安装： sh xx.sh</li>
<li>配置环境变量，在/opt/poky/1.4.3路径下执行 
<code>source enviroment-setup-arm5te-poky-linux-gnuabi</code></li>
</ol>
<p>## 
fatal error: alsa/asoundlib.h: No such file or directory</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[190424-linux-dev-esp32]]></title>
      <url>https://xubovey.github.io/2019/04/24/190424-linux-dev-esp32/</url>
      <content type="html"><![CDATA[<h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><h2 id="安装Linux下的软件需求"><a href="#安装Linux下的软件需求" class="headerlink" title="安装Linux下的软件需求"></a>安装Linux下的软件需求</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install gcc git wget <span class="keyword">make</span> libncurses-dev flex bison gperf <span class="keyword">python</span> <span class="keyword">python</span>-pip <span class="keyword">python</span>-setuptools <span class="keyword">python</span>-serial <span class="keyword">python</span>-cryptography <span class="keyword">python</span>-future <span class="keyword">python</span>-pyparsing <span class="keyword">python</span>-pyelftools</span><br></pre></td></tr></table></figure>
<h2 id="linux环境设置"><a href="#linux环境设置" class="headerlink" title="linux环境设置"></a>linux环境设置</h2><p><a href="https://dl.espressif.com/dl/xtensa-esp32-elf-linux64-1.22.0-61-gab8375a-5.2.0.tar.gz" target="_blank" rel="noopener">下载地址：</a>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /home/username/esp</span><br><span class="line">cd /home/username/esp</span><br><span class="line">tar -xzf /home/username/Downloads/xtensa-esp32-elf-linux64<span class="number">-1.22</span><span class="number">.0</span><span class="number">-61</span>-gab8375a<span class="number">-5.2</span><span class="number">.0</span>.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>2.设置环境变量PATH，以便能搜索到我们的编译工具链
在/home/username/.profile中添加
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=<span class="variable">$PATH</span><span class="symbol">:/home/username/esp/xtensa-esp32-elf/bin</span></span><br></pre></td></tr></table></figure></p>
<p>具体操作：
/usrname路径下<figure class="highlight plain"><figcaption><span>.profile```, 然后在文件尾部输入`o`，写入上面内容，输入`wq`退出。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">source .profile</span><br></pre></td></tr></table></figure></p>
<p>执行<code>echo $PATH</code>查看环境变量结果</p>
<h2 id="git-clone-SDK-ESP-IDF"><a href="#git-clone-SDK-ESP-IDF" class="headerlink" title="git clone SDK ESP-IDF"></a>git clone SDK ESP-IDF</h2><p>在esp目录下
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive http:<span class="regexp">//gi</span>thub.com<span class="regexp">/espressif/</span>esp-idf.git</span><br><span class="line">git submodule add https:<span class="regexp">//gi</span>thub.com<span class="regexp">/tuanpmt/</span>espmqtt.git components<span class="regexp">/espmqtt</span></span><br></pre></td></tr></table></figure></p>
<p>…等一会
如果没有安装git
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt <span class="keyword">install</span> git</span><br></pre></td></tr></table></figure></p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">"export IDF_PATH=~/esp/esp-idf"</span> &gt;&gt; ~<span class="string">/.bashrc</span></span><br><span class="line">source ~<span class="string">/.bashrc</span></span><br></pre></td></tr></table></figure>
<h2 id="编译helloworld"><a href="#编译helloworld" class="headerlink" title="编译helloworld"></a>编译helloworld</h2><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cd </span><span class="string">examples/</span><span class="built_in">get-started/hello_world/</span></span><br><span class="line"><span class="built_in">make</span></span><br></pre></td></tr></table></figure>
<h2 id="烧写固件"><a href="#烧写固件" class="headerlink" title="烧写固件"></a>烧写固件</h2><p>识别到ttyUSB0设备后执行命令
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod <span class="number">777</span> <span class="regexp">/dev/</span>ttyUSB0</span><br><span class="line">make flash monitor</span><br></pre></td></tr></table></figure></p>
<p>提示<code>recipe for target &#39;flash&#39; failed</code>，输入<code>sudo chmod 777 /dev/ttyUSB0</code>即可</p>
<h1 id="ESP-TOUCH"><a href="#ESP-TOUCH" class="headerlink" title="ESP-TOUCH"></a>ESP-TOUCH</h1><p><a href="https://github.com/EspressifApp/ESP-TOUCHForAndroid" target="_blank" rel="noopener">https://github.com/EspressifApp/ESP-TOUCHForAndroid</a></p>
<h2 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h2><ol>
<li>/esp/esp-idf/components/espmqtt/目录下执行mv mqtt_client.c mqtt_client.c.bak</li>
<li>/esp/esp-idf/components/espmqtt/include目录下执行mv mqtt_client.h mqtt_client.h.bak</li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[190401-tr_printer_debug]]></title>
      <url>https://xubovey.github.io/2019/04/01/190401-printer-debug/</url>
      <content type="html"><![CDATA[<h2 id="2A版本打印机调试记录"><a href="#2A版本打印机调试记录" class="headerlink" title="2A版本打印机调试记录"></a>2A版本打印机调试记录</h2><h3 id="打印机接口调试"><a href="#打印机接口调试" class="headerlink" title="打印机接口调试"></a>打印机接口调试</h3><p>版本变更：更换电平转换芯片，更换数据输出接口使layout更容易。
修改代码后发现不能正常打印测试内容。经过各种验证得出如下结论：</p>
<ul>
<li>可打印整行直线，即DAT线长高</li>
<li>CLK,DAT,LATCH,DST信号波形良好无畸变</li>
</ul>
<p>尝试上拉、下拉无果</p>
<p>修改GPIO输出速度为High 无果</p>
<p>示波器测试各信号线波形良好。各种测试无果。</p>
<p>最后在DAT,CLK,LATCH信号线上串联47ohm电阻，问题解决.</p>
<ol>
<li>DAT+CLK+LATCH OK</li>
<li>ONLY DAT NOT OK</li>
<li>DAT+CLK OK</li>
<li>ONLY CLK OK</li>
<li>CLK串联电阻替换为对地并联电容，问题解决</li>
</ol>
<p>因为所用示波器采样率低，测试为发现波形明显异常。
根据并联电容解决问题，分析CLK沿变太快导致接收异常。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[190324-ubuntu 16 for imx6,7,8]]></title>
      <url>https://xubovey.github.io/2019/03/24/190324-ubuntu-16-for-imx6-7-8/</url>
      <content type="html"><![CDATA[<h2 id="boot-from-sd"><a href="#boot-from-sd" class="headerlink" title="boot from sd"></a>boot from sd</h2><p><a href="https://blog.csdn.net/kongzhongloucsdn/article/details/54016248" target="_blank" rel="noopener">参考</a>
SD 卡启动是开发板系统启动方式的一种。 SD 系统启动卡共有 FAT32、 EXT3 两个格式分区，还包含 RAW 格式的无名分区。其中 FAT32 格式分区在 Windows 系统下可见，EXT3 格式分区在 Windows 系统下不可见，两分区在 Linux 系统下均可见。无名分区在Windows 和 Linux 操作系统下均不可见。 无名分区存放 u-boot.ais， FAT32 格式分区存放内核文件 uImage、系统启动脚本等文件， EXT3 格式分区存放文件系统。 </p>
<h2 id="如何做个SD卡启动卡"><a href="#如何做个SD卡启动卡" class="headerlink" title="如何做个SD卡启动卡"></a>如何做个SD卡启动卡</h2><h3 id="step1-安装mkimage-搭建环境"><a href="#step1-安装mkimage-搭建环境" class="headerlink" title="step1 安装mkimage,搭建环境"></a>step1 安装mkimage,搭建环境</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install uboot-mkimage</span><br></pre></td></tr></table></figure>
<p>提示
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Reading <span class="keyword">package</span> <span class="title">l</span>ists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">E: Unable to locate <span class="keyword">package</span> <span class="title">uboot-image</span></span><br><span class="line">root@ubuntu:/# apt-get install uboot-mkimage</span><br><span class="line">Reading <span class="keyword">package</span> <span class="title">l</span>ists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line"><span class="keyword">Package</span> <span class="title">uboot-mkimage </span><span class="keyword">is</span> <span class="keyword">not</span> available, but <span class="keyword">is</span> referred to by another <span class="keyword">package</span>.</span><br><span class="line">This may mean that the <span class="keyword">package</span> <span class="title"></span><span class="keyword">is</span> missing, has been obsoleted, <span class="keyword">or</span></span><br><span class="line"><span class="keyword">is</span> only available from another source</span><br><span class="line">However the following packages replace it:</span><br><span class="line">  u-boot-tools:i386 u-boot-tools</span><br></pre></td></tr></table></figure></p>
<p>重新输入命令
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install u-boot-tools</span><br></pre></td></tr></table></figure></p>
<p>安装好后命令行输入<code>mkimage</code>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Usage: mkimage -l <span class="built_in">image</span></span><br><span class="line">          -l ==&gt; <span class="built_in">list</span> <span class="built_in">image</span> header information</span><br><span class="line">       mkimage [-x] -A arch -O os -T <span class="built_in">type</span> -C comp -a addr -e ep -n <span class="built_in">name</span> -d data_file[:data_file...] <span class="built_in">image</span></span><br><span class="line">          -A ==&gt; <span class="built_in">set</span> architecture <span class="keyword">to</span> <span class="string">'arch'</span></span><br><span class="line">          -O ==&gt; <span class="built_in">set</span> operating system <span class="keyword">to</span> <span class="string">'os'</span></span><br><span class="line">          -T ==&gt; <span class="built_in">set</span> <span class="built_in">image</span> <span class="built_in">type</span> <span class="keyword">to</span> <span class="string">'type'</span></span><br><span class="line">          -C ==&gt; <span class="built_in">set</span> compression <span class="built_in">type</span> <span class="string">'comp'</span></span><br><span class="line">          -a ==&gt; <span class="built_in">set</span> <span class="built_in">load</span> address <span class="keyword">to</span> <span class="string">'addr'</span> (hex)</span><br><span class="line">          -e ==&gt; <span class="built_in">set</span> entry point <span class="keyword">to</span> <span class="string">'ep'</span> (hex)</span><br><span class="line">          -n ==&gt; <span class="built_in">set</span> <span class="built_in">image</span> <span class="built_in">name</span> <span class="keyword">to</span> <span class="string">'name'</span></span><br><span class="line">          -d ==&gt; use <span class="built_in">image</span> data <span class="keyword">from</span> <span class="string">'datafile'</span></span><br><span class="line">          -x ==&gt; <span class="built_in">set</span> XIP (execute <span class="built_in">in</span> place)</span><br><span class="line">       mkimage [-D dtc_options] [-f fit-<span class="built_in">image</span>.its|-F] fit-<span class="built_in">image</span></span><br><span class="line">          -D =&gt; <span class="built_in">set</span> all options <span class="keyword">for</span> device tree compiler</span><br><span class="line">          -f =&gt; input filename <span class="keyword">for</span> FIT source</span><br><span class="line">Signing / verified boot <span class="built_in">not</span> supported (CONFIG_FIT_SIGNATURE undefined)</span><br><span class="line">       mkimage -V ==&gt; print version information <span class="built_in">and</span> <span class="keyword">exit</span></span><br><span class="line">Use -T <span class="keyword">to</span> see a <span class="built_in">list</span> of available <span class="built_in">image</span> types</span><br></pre></td></tr></table></figure></p>
<h3 id="step2-SD卡启动脚本制作"><a href="#step2-SD卡启动脚本制作" class="headerlink" title="step2 SD卡启动脚本制作"></a>step2 SD卡启动脚本制作</h3><ul>
<li>将 SD 卡格式化成无名分区（ RAW 格式）、 boot 分区（ FAT32 格式）和 rootfs分区（ EXT3 格式）。</li>
<li>拷贝镜像所在目录相关文件到 SD 卡对应分区。</li>
<li>在 boot 分区生成 SD 卡启动脚本源文件和 SD 卡启动脚本镜像。</li>
</ul>
<h3 id="step3-把镜像等文件复制到sd卡上"><a href="#step3-把镜像等文件复制到sd卡上" class="headerlink" title="step3 把镜像等文件复制到sd卡上"></a>step3 把镜像等文件复制到sd卡上</h3>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[190321-cadence note]]></title>
      <url>https://xubovey.github.io/2019/03/21/190321-cadence-note/</url>
      <content type="html"><![CDATA[<h2 id="原理图中画三角形"><a href="#原理图中画三角形" class="headerlink" title="原理图中画三角形"></a>原理图中画三角形</h2><p>选择Place-&gt;Poliline，或者快捷键”Y”，启动画多边形命令，默认情况是画直角多边形的，按下shift可画任意角度拐角，这样就可以画三角形了。</p>
<h2 id="allegro局部缩放"><a href="#allegro局部缩放" class="headerlink" title="allegro局部缩放"></a>allegro局部缩放</h2><p>Manufacture-&gt;draft-&gt;Create detail 局部缩放</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[190320 linux cmd]]></title>
      <url>https://xubovey.github.io/2019/03/20/190320-linux-cmd/</url>
      <content type="html"><![CDATA[<h2 id="查看存储空间使用情况"><a href="#查看存储空间使用情况" class="headerlink" title="查看存储空间使用情况"></a>查看存储空间使用情况</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看当前系统磁盘使用空间</span></span><br><span class="line">df -<span class="built_in">h</span></span><br><span class="line"><span class="comment">//查看当前目录文件占用空间大小</span></span><br><span class="line">du -<span class="keyword">sh</span> *</span><br></pre></td></tr></table></figure>
<p>运行效果如下
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@<span class="symbol">tianRong:</span>/usr<span class="comment"># du -sh *</span></span><br><span class="line"><span class="number">5.7</span>M    bin</span><br><span class="line"><span class="number">112.0</span>K  etc</span><br><span class="line"><span class="number">128.5</span>M  <span class="class"><span class="keyword">lib</span></span></span><br><span class="line"><span class="number">0</span>       local</span><br><span class="line"><span class="number">60.0</span>K   regdefault</span><br><span class="line"><span class="number">1.4</span>M    sbin</span><br><span class="line"><span class="number">6.3</span>M    share</span><br><span class="line"></span><br><span class="line">root@<span class="symbol">tianRong:</span>/usr<span class="comment"># df -h</span></span><br><span class="line">Filesystem                Size      Used Available Use% Mounted on</span><br><span class="line"><span class="symbol">ubi0:</span>rootfs             <span class="number">104.6</span>M     <span class="number">98.6</span>M      <span class="number">1.3</span>M  <span class="number">99</span>% <span class="regexp">/</span></span><br><span class="line"><span class="regexp">devtmpfs                 60.4M      4.0K     60.4M   0% /dev</span></span><br><span class="line">tmpfs                    <span class="number">60.6</span>M     <span class="number">80.0</span>K     <span class="number">60.5</span>M   <span class="number">0</span>% <span class="regexp">/var/volatile</span></span><br><span class="line">tmpfs                    <span class="number">60.6</span>M         <span class="number">0</span>     <span class="number">60.6</span>M   <span class="number">0</span>% <span class="regexp">/media/ram</span></span><br><span class="line">tmpfs                    <span class="number">60.6</span>M    <span class="number">244.0</span>K     <span class="number">60.4</span>M   <span class="number">0</span>% <span class="regexp">/tmp</span></span><br><span class="line"><span class="regexp">ubi0_1                  107.9M     24.0K    103.1M   0% /mnt</span><span class="regexp">/user</span></span><br></pre></td></tr></table></figure></p>
<h2 id="重新加载文件系统"><a href="#重新加载文件系统" class="headerlink" title="重新加载文件系统"></a>重新加载文件系统</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mount</span> -o remount -rw /</span><br></pre></td></tr></table></figure>
<p>Linux 文件权限 变成制度 readonly 解决方法
文件系统加载为只读
<figure class="highlight plain"><figcaption><span>-n -o remount,ro</span><a href="/```">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">修改为```mount -n -o remount, rw /```即为读写模式加载</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## su,sudo,退出</span><br><span class="line">终端使用sudo可实现,使用su可进入root把$变成# </span><br><span class="line">退出：ctrl+D,exit,logout</span><br><span class="line"></span><br><span class="line">## ls -Sl或-lS 按大小排序</span><br><span class="line"></span><br><span class="line">## 遍历当前文件夹中所有文件夹内文件，输出md5到指定文件夹</span><br></pre></td></tr></table></figure></p>
<p>find ./ ! -name ‘checksum’ -prune -type f -print0 | xargs -0 md5sum &gt; ./checksum
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## 打包</span><br></pre></td></tr></table></figure></p>
<p>tar -zcvf rootfs.tar.gz ./rootfs
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">打包过程：</span><br><span class="line"><span class="number">1</span>. 把当前可用的最新文件系统复制到Linux下</span><br><span class="line"><span class="number">2</span>. 把调试中修改过的usr,opt,etc文件夹打包，并复制到Linux下</span><br><span class="line"><span class="number">3</span>. 把修改后的<span class="number">3</span>个文件夹替换，替换后遍历所有文件并做MD5校验</span><br><span class="line"><span class="number">4</span>. 把新的文件系统打包</span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除文件夹</span></span><br><span class="line">rm -rf * <span class="regexp">//</span>删除文件下所有文件，包含子文件夹</span><br><span class="line"></span><br><span class="line"><span class="comment">## 环境变量删除</span></span><br><span class="line">export -n</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看文件被哪个进程占用</span></span><br><span class="line">lsof</span><br><span class="line"></span><br><span class="line"><span class="comment">## QT命令行编译</span></span><br><span class="line">执行qmake xxx.pro生产makefile，执行make完成编译</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 声音播放，音量调节</span></span><br><span class="line">aplay ***.mav</span><br><span class="line">alsamixer</span><br><span class="line">aplay -l 可查看声卡信息</span><br><span class="line">aplay -D <span class="symbol">plughw:</span><span class="number">0</span>,<span class="number">0</span> xxx.wav</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## ubuntu下rpm包解压缩</span></span><br><span class="line">rpm2cpio ../alsa-<span class="class"><span class="keyword">lib</span>-<span class="title">dev</span>-1.1.0-<span class="title">r0</span>.<span class="title">armv5e</span>.<span class="title">rpm</span> | <span class="title">cpio</span> -<span class="title">idv</span></span></span><br><span class="line">批量使用</span><br><span class="line"><span class="keyword">for</span> name in *.rpm; <span class="keyword">do</span> rpm2cpio $name | cpio -idv; done</span><br><span class="line"></span><br><span class="line"><span class="comment">## sh文件安装</span></span><br><span class="line">sh xx.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">## 脚本死循环</span></span><br></pre></td></tr></table></figure></p>
<p>cnt=1;
while :
do
    echo $cnt;
    let cnt+=1;
    xxx
    sleep 3
done
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 脚本升级</span><br></pre></td></tr></table></figure></p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 脚本MD5</span><br></pre></td></tr></table></figure>
<p>sudo rm rootfs.tar.gz
sudo rm checksum
sudo find -type f | xargs md5sum &gt;/tmp/checksum
sudo cp /tmp/checksum checksum
sudo tar cvzf rootfs.tar.gz *
sudo chmod -R 777 rootfs.tar.gz
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">`md5sum -c checksum`校验结果,其中checksum为校验结果存放位置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 解压</span></span><br><span class="line"><span class="string">.tar</span> </span><br><span class="line">解包：tar xvf FileName.tar </span><br><span class="line">打包：tar cvf FileName.tar DirName </span><br><span class="line">（注：tar是打包，不是压缩！） </span><br><span class="line"><span class="params">---------------------------------------------</span> </span><br><span class="line"><span class="string">.gz</span> </span><br><span class="line">解压1：gunzip FileName.gz </span><br><span class="line">解压2：gzip -d FileName.gz </span><br><span class="line">压缩：gzip FileName </span><br><span class="line"><span class="string">.tar.gz</span> 和 <span class="string">.tgz</span> </span><br><span class="line">解压：tar zxvf FileName.tar.gz </span><br><span class="line">压缩：tar zcvf FileName.tar.gz DirName </span><br><span class="line"><span class="params">---------------------------------------------</span> </span><br><span class="line"><span class="string">.bz2</span> </span><br><span class="line">解压1：bzip2 -d FileName.bz2 </span><br><span class="line">解压2：bunzip2 FileName.bz2 </span><br><span class="line">压缩： bzip2 -z FileName </span><br><span class="line"><span class="string">.tar.bz2</span> </span><br><span class="line">解压：tar jxvf FileName.tar.bz2 </span><br><span class="line">压缩：tar jcvf FileName.tar.bz2 DirName </span><br><span class="line"><span class="params">---------------------------------------------</span> </span><br><span class="line"><span class="string">.bz</span> </span><br><span class="line">解压1：bzip2 -d FileName.bz </span><br><span class="line">解压2：bunzip2 FileName.bz </span><br><span class="line">压缩：未知 </span><br><span class="line"><span class="string">.tar.bz</span> </span><br><span class="line">解压：tar jxvf FileName.tar.bz </span><br><span class="line">压缩：未知 </span><br><span class="line"><span class="params">---------------------------------------------</span> </span><br><span class="line"><span class="string">.Z</span> </span><br><span class="line">解压：uncompress FileName.Z </span><br><span class="line">压缩：compress FileName </span><br><span class="line"><span class="string">.tar.Z</span> </span><br><span class="line">解压：tar Zxvf FileName.tar.Z </span><br><span class="line">压缩：tar Zcvf FileName.tar.Z DirName </span><br><span class="line"><span class="params">---------------------------------------------</span> </span><br><span class="line"><span class="string">.zip</span> </span><br><span class="line">解压：unzip FileName.zip </span><br><span class="line">压缩：zip FileName.zip DirName </span><br><span class="line"><span class="params">---------------------------------------------</span> </span><br><span class="line"><span class="string">.rar</span> </span><br><span class="line">解压：rar x FileName.rar </span><br><span class="line">压缩：rar a FileName.rar DirName </span><br><span class="line">rar请到： </span><br><span class="line">http:<span class="string">//www.rarsoft.com/download.htm</span> </span><br><span class="line">下载！ </span><br><span class="line">解压后请将rar_static拷贝到<span class="string">/usr/bin</span>目录（其他由$PATH环境变量指定的目录也能）： </span><br><span class="line">[root@www2 tmp]<span class="comment"># cp rar_static /usr/bin/rar </span></span><br><span class="line"><span class="params">---------------------------------------------</span> </span><br><span class="line"><span class="string">.lha</span> </span><br><span class="line">解压：lha -e FileName.lha </span><br><span class="line">压缩：lha -a FileName.lha FileName </span><br><span class="line">lha请到： </span><br><span class="line">http:<span class="string">//www.infor.kanazawa-it.ac.jp/</span>~ishii/lhaunix/ </span><br><span class="line">下载！ </span><br><span class="line">&gt;解压后请将lha拷贝到<span class="string">/usr/bin</span>目录（其他由$PATH环境变量指定的目录也能）： </span><br><span class="line">[root@www2 tmp]<span class="comment"># cp lha /usr/bin/ </span></span><br><span class="line"><span class="params">---------------------------------------------</span> </span><br><span class="line"><span class="string">.rpm</span> </span><br><span class="line">解包：rpm2cpio FileName.rpm | cpio -div </span><br><span class="line"><span class="params">---------------------------------------------</span> </span><br><span class="line"><span class="string">.deb</span> </span><br><span class="line">解包：ar p FileName.deb data.tar.gz | tar zxf - </span><br><span class="line"><span class="params">---------------------------------------------</span> </span><br><span class="line"><span class="string">.tar</span> <span class="string">.tgz</span> <span class="string">.tar.gz</span> <span class="string">.tar.Z</span> </span><br><span class="line"><span class="string">.tar.bz</span> <span class="string">.tar.bz2</span> <span class="string">.zip</span> <span class="string">.cpio</span> <span class="string">.rpm</span> <span class="string">.deb</span> <span class="string">.slp</span> <span class="string">.arj</span> <span class="string">.rar</span> <span class="string">.ace</span> <span class="string">.lha</span> <span class="string">.lzh</span> </span><br><span class="line"><span class="string">.lzx</span> <span class="string">.lzs</span> <span class="string">.arc</span> <span class="string">.sda</span> <span class="string">.sfx</span> <span class="string">.lnx</span> <span class="string">.zoo</span> <span class="string">.cab</span> <span class="string">.kar</span> <span class="string">.cpt</span> <span class="string">.pit</span> <span class="string">.sit</span> <span class="string">.sea</span> </span><br><span class="line">解压：sEx x FileName.* </span><br><span class="line">压缩：sEx a FileName.* FileName </span><br><span class="line">sEx只是调用相关程式，本身并无压缩、解压功能，请注意！ </span><br><span class="line">sEx请到： </span><br><span class="line">http:<span class="string">//sourceforge.net/projects/sex</span> </span><br><span class="line">下载！ </span><br><span class="line">解压后请将sEx拷贝到<span class="string">/usr/bin</span>目录（其他由$PATH环境变量指定的目录也能）： </span><br><span class="line">[root@www2 tmp]<span class="comment"># cp sEx /usr/bin/ </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## arm交叉编译器gnueabi、none-eabi、arm-eabi、gnueabihf、gnueabi区别</span></span><br><span class="line">命名规则</span><br><span class="line">交叉编译工具链的命名规则为：arch [-vendor] [-os] [-<span class="params">(gnu)</span>eabi]</span><br><span class="line"></span><br><span class="line">arch – 体系架构，如ARM，MIPS</span><br><span class="line">vendor – 工具链提供商</span><br><span class="line">os – 目标操作系统</span><br><span class="line">eabi – 嵌入式应用二进制接口（Embedded Application Binary Interface）</span><br><span class="line">根据对操作系统的支持与否，ARM GCC可分为支持和不支持操作系统，如</span><br><span class="line"></span><br><span class="line">arm-none-eabi：这个是没有操作系统的，自然不可能支持那些跟操作系统关系密切的函数，比如fork<span class="params">(2)</span>。他使用的是newlib这个专用于嵌入式系统的C库。</span><br><span class="line">arm-none-linux-eabi：用于Linux的，使用Glibc</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> 实例</span><br><span class="line">1、arm-none-eabi-gcc</span><br><span class="line">（ARM architecture，no vendor，not target an operating system，complies with the ARM EABI）</span><br><span class="line">用于编译 ARM 架构的裸机系统（包括 ARM Linux 的 boot、kernel，不适用编译 Linux 应用 Application），一般适合 ARM7、Cortex-M 和 Cortex-R 内核的使用，所以不支持那些跟操作系统关系密切的函数，比如fork<span class="params">(2)</span>，他使用的是 newlib 这个专用于嵌入式系统的C库。</span><br><span class="line"></span><br><span class="line">2、arm-none-linux-gnueabi-gcc</span><br><span class="line"><span class="params">(ARM architecture, no vendor, creates binaries that run on the Linux operating system, and uses the GNU EABI)</span></span><br><span class="line"></span><br><span class="line">主要用于基于ARM架构的Linux系统，可用于编译 ARM 架构的 u-boot、Linux内核、linux应用等。arm-none-linux-gnueabi基于GCC，使用Glibc库，经过 Codesourcery 公司优化过推出的编译器。arm-none-linux-gnueabi-xxx 交叉编译工具的浮点运算非常优秀。一般ARM9、ARM11、Cortex-A 内核，带有 Linux 操作系统的会用到。</span><br><span class="line"></span><br><span class="line">3、arm-eabi-gcc</span><br><span class="line">Android ARM 编译器。</span><br><span class="line"></span><br><span class="line">4、armcc</span><br><span class="line">ARM 公司推出的编译工具，功能和 arm-none-eabi 类似，可以编译裸机程序（u-boot、kernel），但是不能编译 Linux 应用程序。armcc一般和ARM一起，Keil MDK、ADS、RVDS和DS-5中的编译器都是armcc，所以 armcc 编译器都是收费的（爱国版除外，呵呵~~）。</span><br><span class="line"></span><br><span class="line">5、arm-none-uclinuxeabi-gcc 和 arm-none-symbianelf-gcc</span><br><span class="line">arm-none-uclinuxeabi 用于uCLinux，使用Glibc。</span><br><span class="line"></span><br><span class="line">arm-none-symbianelf 用于symbian，没用过，不知道C库是什么 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 缺少包查找</span></span><br><span class="line">* 如果PC上可以执行到板子上不能执行，那么说明板子上的文件系统里缺少某个包，并且板子上一般会提醒缺少哪个包的。</span><br><span class="line">* 如何在PC上找到对你应的包呢？apt-file search</span><br><span class="line">    * sudo apt-get install apt-file</span><br><span class="line">    * sudo apt-file update</span><br><span class="line">    * apt-file search *<span class="string">.so.1</span></span><br><span class="line">    * 例如：apt-file search libjpeg.so.8</span><br></pre></td></tr></table></figure></p>
<pre><code>libjpeg-turbo8: /usr/lib/x86_64-linux-gnu/libjpeg.so.8
libjpeg-turbo8: /usr/lib/x86_64-linux-gnu/libjpeg.so.8.0.2
```
* 右边的是匹配你的库，左边的是你查的库所在的包，所以需要的包是libjpeg-turbo8
* 判断库是否能用：objdump -a  *.so，看库是64位的还是32位的，是否与目标板一致
</code></pre><h2 id="如何快速下载ubuntu"><a href="#如何快速下载ubuntu" class="headerlink" title="如何快速下载ubuntu"></a>如何快速下载ubuntu</h2><p>由于官网服务器在国外，下载速度奇慢，所以我们可以利用阿里云镜像下载ubuntu 
ubuntu 14.04： 
<a href="http://mirrors.aliyun.com/ubuntu-releases/14.04/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu-releases/14.04/</a> 
ubuntu 16.04： 
<a href="http://mirrors.aliyun.com/ubuntu-releases/16.04/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu-releases/16.04/</a> 
ubuntu 18.04： 
<a href="http://mirrors.aliyun.com/ubuntu-releases/18.04/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu-releases/18.04/</a> 
没错，只要市面上存在的版本，阿里云镜像基本都有，下载速度可以达到3M/s</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[编译结果各字段含义]]></title>
      <url>https://xubovey.github.io/2019/01/30/190130CompileSegment/</url>
      <content type="html"><![CDATA[<p><a href="https://mcuoneclipse.com/2013/04/14/text-data-and-bss-code-and-data-size-explained/" target="_blank" rel="noopener">参考</a></p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  text       data        bss        dec        hex    filename</span><br><span class="line"><span class="number">0x1408</span>       <span class="number">0x18</span>      <span class="number">0x81c</span>       <span class="number">7228</span>       <span class="number">1</span>c3c    size.elf</span><br></pre></td></tr></table></figure>
<p>text
‘text’ is what ends up in FLASH memory. I can show this with adding</p>
<p>data
‘data’ is used for initialized data. This is best explained with the following (global/extern) variable:</p>
<p>bss
The ‘bss’ contains all the uninitalized data.</p>
<p>💡 bss (or .bss, or BSS) is the abbreviation for ‘Block Started by Symbol’ by an old assembler (see this link).</p>
<p>dec
The ‘dec’ (as a decimal number) is the sum of text, data and bss:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">dec</span> = text + <span class="class"><span class="keyword">data</span> + bss</span></span><br></pre></td></tr></table></figure></p>
<p>Size – GNU Utility
The size (or printsize) GNU utility has more options:</p>
<p>Summary
I hope I have sorted out things in a correct way. The way how the initialized data is reported might be confusing. But with the right knowledge (and .map file in mind), things get much clearer:</p>
<p>‘text’ is my code, vector table plus constants.</p>
<p>‘data’ is for initialized variables, and it counts for RAM and FLASH. The linker allocates the data in FLASH which then is copied from ROM to RAM in the startup code.</p>
<p>‘bss’ is for the uninitialized data in RAM which is initialized with zero in the startup code.</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[git常用操作]]></title>
      <url>https://xubovey.github.io/2019/01/18/git/</url>
      <content type="html"><![CDATA[<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><ol>
<li><p>dev分支测试ok后合并到master分支</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">git pull</span><br><span class="line">git checkout <span class="literal">master</span></span><br><span class="line">git merge dev</span><br><span class="line">git push -u origin <span class="literal">master</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>master分支更新后dev1分支同步master分支</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="keyword">master</span> <span class="title"></span></span><br><span class="line"><span class="title">git</span> pull </span><br><span class="line">git checkout dev</span><br><span class="line">git merge <span class="keyword">master</span> <span class="title"></span></span><br><span class="line"><span class="title">git</span> push -u origin dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>从dev分支创建release分支，例如要发布2.0版本</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b <span class="keyword">release</span><span class="number">-2.0</span> develop</span><br><span class="line">// <span class="keyword">change</span> something <span class="keyword">to</span> <span class="keyword">commit</span></span><br><span class="line">git <span class="keyword">commit</span> -a -m <span class="string">"Bumped version number to 2.0"</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
</li>
<li><p>release分支合并到master分支同上1</p>
</li>
<li><p>删除本地release分支</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -d <span class="built_in">release</span><span class="number">-2.0</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除远程release分支</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> --<span class="built_in">delete</span> release-<span class="number">2.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>bug分支，master分支上或其他某分支发现bug，则从当前分支上分出来一个branch</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b ISSUE-<span class="number">110</span> <span class="literal">master</span></span><br><span class="line">// change something</span><br><span class="line">git commit -a -m <span class="string">"Bumped version number to 2.0.1"</span></span><br><span class="line">//fix bug</span><br><span class="line">git commit -m <span class="string">"Fixed ISSUE-110 problem"</span></span><br><span class="line">git checkout <span class="literal">master</span></span><br><span class="line">git merge --no-ff ISSUE-<span class="number">110</span></span><br><span class="line">git <span class="keyword">tag</span> <span class="title">-a</span> <span class="number">2.0</span>.<span class="number">1</span></span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff ISSUE-<span class="number">110</span></span><br><span class="line">git branch -d ISSUE-<span class="number">110</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看分支关系
git log –graph –decorate –oneline –simplify-by-decoration –all</p>
</li>
<li><p>退出git log方法
英文字母Q</p>
</li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[堆栈bug引起的反思]]></title>
      <url>https://xubovey.github.io/2019/01/15/heap-and-stack/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>项目开发中程序运行一段时间后逻辑异常。各种排查，各种加printf。最后定位是vsprintf函数被执行后引起了改变了代码中的某全局变量。胡乱配置，修改一通，无果。最后请教技术大牛，指点迷津<code>堆栈搞大</code></p>
<h2 id="搞大堆栈"><a href="#搞大堆栈" class="headerlink" title="搞大堆栈"></a>搞大堆栈</h2><p>使用的单片机是STM32，在<code>startup_stm32f10x_hd.s</code>文件中有如下配置：
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Stack_Size</span>      <span class="meta">EQU</span>     <span class="number">0x00000800</span></span><br><span class="line"></span><br><span class="line">                <span class="meta">AREA</span>    STACK, NOINIT, READWRITE, <span class="meta">ALIGN</span><span class="number">=3</span></span><br><span class="line"><span class="symbol">Stack_Mem</span>       <span class="meta">SPACE</span>   Stack_Size</span><br><span class="line"><span class="symbol">__initial_sp</span></span><br><span class="line">                                                  </span><br><span class="line"><span class="comment">; &lt;h&gt; Heap Configuration</span></span><br><span class="line"><span class="comment">;   &lt;o&gt;  Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;</span></span><br><span class="line"><span class="comment">; &lt;/h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">Heap_Size</span>       <span class="meta">EQU</span>     <span class="number">0x00000400</span></span><br><span class="line"></span><br><span class="line">                <span class="meta">AREA</span>    HEAP, NOINIT, READWRITE, <span class="meta">ALIGN</span><span class="number">=3</span></span><br><span class="line"><span class="symbol">__heap_base</span></span><br><span class="line"><span class="symbol">Heap_Mem</span>        <span class="meta">SPACE</span>   Heap_Size</span><br><span class="line"><span class="symbol">__heap_limit</span></span><br></pre></td></tr></table></figure></p>
<p>可以发现stack空间是1K, Heap是512字节自然不大。分别进行修改：Heap-&gt;1K 仍然错误，之后又修改Stack-&gt;2K测试通过。</p>
<h2 id="堆栈对数据破坏的隐蔽性"><a href="#堆栈对数据破坏的隐蔽性" class="headerlink" title="堆栈对数据破坏的隐蔽性"></a>堆栈对数据破坏的隐蔽性</h2><p>如何发现堆栈引起的错误，想到的有  </p>
<ul>
<li>if语句判断变量时应该列举每一种情况，不支持的进行打印或告警，基本发现变量被异常修改；</li>
<li>单片机代码进来避免深层调用，避免局部变量过大</li>
<li>适当加大堆栈空间</li>
</ul>
<p>验证发现：后两种都可以解决遇到的问题</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[NXP(freescale) USBDM for HS08 and HS12]]></title>
      <url>https://xubovey.github.io/2019/01/04/NXP-freescale-USBDM-for-HS08-and-HS12/</url>
      <content type="html"><![CDATA[<p>项目需要买了1个USBDM仿真器，但是没有说明IO功能，问了淘宝店家后特记录备忘。  </p>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能</th>
<th>序号</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>BKGD</td>
<td>2</td>
<td>GND</td>
</tr>
<tr>
<td>3</td>
<td>BKGD</td>
<td>4</td>
<td>RST</td>
</tr>
<tr>
<td>5</td>
<td>NC</td>
<td>6</td>
<td>VCC</td>
</tr>
</tbody>
</table>
<p><a href="https://item.taobao.com/item.htm?spm=a1z09.2.0.0.7e432e8dlokL8y&amp;id=563639288303&amp;_u=44l82007830" target="_blank" rel="noopener">taobao</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[激活win10]]></title>
      <url>https://xubovey.github.io/2019/01/04/190104-active-win10/</url>
      <content type="html"><![CDATA[<h2 id="莫名的提升需要激活"><a href="#莫名的提升需要激活" class="headerlink" title="莫名的提升需要激活"></a>莫名的提升需要激活</h2><p>自从自动升级到win10系统后，本来使用良好的，可近日开始自动弹出提示过期需激活之类的窗口。本来想不管继续使用的，可是每天提示不是办法。所以就尝试解决，经过一些处理，找到了很简单的方法，特记录如下。</p>
<h2 id="相关密钥"><a href="#相关密钥" class="headerlink" title="相关密钥"></a>相关密钥</h2><h3 id="Win10家庭版密钥："><a href="#Win10家庭版密钥：" class="headerlink" title="Win10家庭版密钥："></a>Win10家庭版密钥：</h3><ul>
<li>家庭版：TX9XD-98N7V-6WMQ6-BX7FG-H8Q99</li>
<li>Core 家庭版：YTMG3-N6DKC-DKB77-7M9GH-8HVX7</li>
<li>CoreSingleLanguage单语言win1064家庭版激活密钥：BT79Q-G7N6G-PGBYW-4YWX6-6F4BT</li>
<li>CoreCountrySpecific激活64位win10特定国家家庭版：N2434-X9D7W-8PF6X-8DV9T-8TYMD</li>
<li>Professional64位系统win10激活码(家庭版)：TX9XD-98N7V-6WMQ6-BX7FG-H8Q99</li>
<li>Win10家庭版N：3KHY7-WNT83-DGQKR-F7HPR-844BM</li>
<li>Win10单语音家庭版：7HNRX-D7KGG-3K4RQ-4WPJ4-YTDFH</li>
<li><p>Win10特殊国家家庭版：PVMJN-6DFY6-9CCP6-7BKTT-D3WVR</p>
</li>
<li><p>专业版：W269N-WFGWX-YVC9B-4J6C9-T83GX</p>
</li>
<li>企业版：NPPR9-FWDCX-D2C8J-H872K-2YT43</li>
<li>教育版：NW6C2-QMPVW-D7KKK-3GKT6-VCFB2</li>
<li>专业版N：MH37W-N47XK-V7XM9-C7227-GCQG9</li>
<li>企业版N：DPH2V-TTNVB-4X9Q3-TJR4H-KHJW4</li>
<li>教育版N：2WH4N-8QGBV-H22JP-CT43Q-MDWWJ</li>
<li>企业版LSTB：WNMTR-4C88C-JK8YV-HQ7T2-76DF9</li>
<li>企业版LSTB N：2F77B-TNFGY-69QQF-B8YKP-D69TJ</li>
</ul>
<h3 id="密钥选择"><a href="#密钥选择" class="headerlink" title="密钥选择"></a>密钥选择</h3><p>当前电脑装的是win10单语言版，所以选择密钥为<code>BT79Q-G7N6G-PGBYW-4YWX6-6F4BT</code></p>
<h2 id="激活过程"><a href="#激活过程" class="headerlink" title="激活过程"></a>激活过程</h2><ol>
<li>管理员权限打开命令窗口</li>
<li>输入<code>slmgr.vbs /upk</code>卸载密钥，弹出窗口显示<code>已成功卸载了产品密钥</code></li>
<li>输入<code>slmgr /ipk BT79Q-G7N6G-PGBYW-4YWX6-6F4BT</code>安装密钥，提示<code>成功的安装了产品密钥</code></li>
<li>输入<code>slmgr /skms zh.us.to</code>弹出窗口<code>密钥管理服务计算机名成功的设置为zh.us.to</code></li>
<li>输入<code>slmgr /ato</code>，弹出窗口提示<code>成功的激活了产品</code></li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[BeyondStudio develop ide]]></title>
      <url>https://xubovey.github.io/2018/12/13/181213-BeyondStudio-develop-ide/</url>
      <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>BeyondStudio for NXP IDE（JN-SW-4141）是NXP的JN516X系列无线微控制器的开发平台。本工具是支持JN516X系列芯片的软件开发包和开发工具链合集，需要先安装，占用约700MB空间。<br>JN516x SDK需要第二步安装，用于支持不同的网络协议。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>JN-UG-3098<a href="https://pan.baidu.com/s/1ZTZLjXxYRGp_glxZYPUCsQ" target="_blank" rel="noopener">下载</a>  </li>
<li>JN-SW-4141<a href="https://pan.baidu.com/s/1FrquoxXaSGNlOL6bN1TEvw" target="_blank" rel="noopener">下载</a>  </li>
<li>JN-SW-4170<a href="https://pan.baidu.com/s/1jlJWhEkCf0LwhXojVjvERA" target="_blank" rel="noopener">下载</a>  </li>
<li>JN-SW-4170 V1840<a href="https://pan.baidu.com/s/1smR270bZ9KHsLPTG2wqgyA" target="_blank" rel="noopener">下载</a>i7nq  </li>
<li>JN-SW-4163<a href="https://pan.baidu.com/s/1Mim6SftD87ZuOs38ArzxAg" target="_blank" rel="noopener">下载</a>  </li>
<li>JN-SW-4168<a href="https://pan.baidu.com/s/1cfz_LnFkfeKG7DK7JcnwGA" target="_blank" rel="noopener">下载</a> 4suq   </li>
</ul>
<p>根据手册介绍：  </p>
<ol>
<li>BeyondStudio for NXP需要先安装: JN-SW-4141  </li>
<li>SDK需要后续安装: JN-SW-4170/4168  </li>
</ol>
<h2 id="app-zpscfg"><a href="#app-zpscfg" class="headerlink" title="app.zpscfg"></a>app.zpscfg</h2><p>app.zpscfg如何打开呢？其实<code>JN-UG-3098 Beyond Studio for NXP</code>文件中已经进行了详细描述。
文件的<code>1.2.3Installing the ZigBee Plug-ins</code>章节有着详细的描述。
需要在eclipse环境下安装2个插件分别是<code>ZPS Configuration Editor</code>和<code>JenOS Configuration Editor</code>,
具体请参考文档<a href="https://www.nxp.com/docs/en/user-guide/JN-UG-3098.pdf" target="_blank" rel="noopener">JN-UG-3098</a></p>
<h2 id="工程导入"><a href="#工程导入" class="headerlink" title="工程导入"></a>工程导入</h2><p><a href="https://community.nxp.com/docs/DOC-340028" target="_blank" rel="noopener">异常处理</a>中的2.Project Directory</p>
<h2 id="其他问题参考"><a href="#其他问题参考" class="headerlink" title="其他问题参考"></a>其他问题参考</h2><p><a href="https://xubovey.github.io/2017/02/24/170224-BeyondStudio-Nxp-IDE-Note/">BeyondStudio Nxp IDE Note</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[SIM868通信测试]]></title>
      <url>https://xubovey.github.io/2018/11/29/181129-sim868-send-data-test/</url>
      <content type="html"><![CDATA[<h2 id="移动状态"><a href="#移动状态" class="headerlink" title="移动状态"></a>移动状态</h2><h3 id="测试条件"><a href="#测试条件" class="headerlink" title="测试条件"></a>测试条件</h3><ul>
<li>兰州-郑州高铁列车</li>
<li>SIM868模块</li>
<li>移动卡</li>
<li>mqtt</li>
</ul>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><ul>
<li>建立网络连接后可在较大范围内（超过单基站覆盖范围）不掉线保持数据通信</li>
<li>数据延迟情况</li>
</ul>
<table>
<thead>
<tr>
<th>发送数据长度</th>
<th>发送延迟</th>
</tr>
</thead>
<tbody>
<tr>
<td>字节</td>
<td>秒</td>
</tr>
<tr>
<td>500</td>
<td>1-1.5</td>
</tr>
<tr>
<td>1000</td>
<td>3-4</td>
</tr>
</tbody>
</table>
<ul>
<li>移动状态联网比较困难，但是可在站台联网成功，之后保持较长距离和时间可持续通信</li>
</ul>
<h2 id="程序改进"><a href="#程序改进" class="headerlink" title="程序改进"></a>程序改进</h2><h3 id="使用AT-IPQSEND"><a href="#使用AT-IPQSEND" class="headerlink" title="使用AT+IPQSEND"></a>使用AT+IPQSEND</h3><p>通信情况改善很多，测试中最高达到2kB/s，测试为静态市内测试，直接给服务器发数据，没经过mqtt.</p>
<h2 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">mqtt init do it.</span><br><span class="line"><span class="comment">[12:04:09.044]</span> task_mqtt.c <span class="comment">[user_msg_proc]</span> rxdata from TASK 1,len =13,msg_p=0x0</span><br><span class="line"><span class="comment">[12:04:09.044]</span> cmdType = 0</span><br><span class="line"><span class="comment">[12:04:09.044]</span> mqtt_connect.</span><br><span class="line"><span class="comment">[12:04:09.044]</span> </span><br><span class="line"><span class="comment">[12:04:09.044]</span> ---&gt; try to connect mqtt server:gxd729</span><br><span class="line"><span class="comment">[12:04:09.044]</span> </span><br><span class="line"><span class="comment">[12:04:09.044]</span> mqtt-&gt;keepalive = 0x3c</span><br><span class="line"><span class="comment">[12:04:09.044]</span> mqtt-&gt;clientid = gxd729</span><br><span class="line"><span class="comment">[12:04:09.044]</span> INFO: the at cmd func<span class="comment">[0]</span>'s range <span class="keyword">is</span> 46-47</span><br><span class="line"><span class="comment">[12:04:09.049]</span> INFO: funFirst:46  funLast:47</span><br><span class="line"><span class="comment">[12:04:09.049]</span> simcom data send result = 1</span><br><span class="line"><span class="comment">[12:04:09.049]</span> app_send_data_to_server return ok, send....</span><br><span class="line"><span class="comment">[12:04:09.049]</span> mqttc <span class="keyword">is</span> connecting to 114.67.229.68:3881...</span><br><span class="line"><span class="comment">[12:04:09.049]</span> </span><br><span class="line"><span class="comment">[12:04:09.049]</span> 1. WrToModem:AT+CIPSEND=0,124</span><br><span class="line"><span class="comment">[12:04:09.143]</span> </span><br><span class="line"><span class="comment">[12:04:09.143]</span> len=4,ReFrModem:</span><br><span class="line"><span class="comment">[12:04:09.147]</span> &gt; </span><br><span class="line"><span class="comment">[12:04:09.147]</span> at+cipsend? return &gt;</span><br><span class="line"><span class="comment">[12:04:09.147]</span> at+cipsend? return 1</span><br><span class="line"><span class="comment">[12:04:09.147]</span> INFO: callback return 46,1</span><br><span class="line"><span class="comment">[12:04:09.147]</span> 1. WrToModem:z</span><br><span class="line"><span class="comment">[12:04:09.255]</span> </span><br><span class="line"><span class="comment">[12:04:10.693]</span> sec:340</span><br><span class="line"><span class="comment">[12:04:10.693]</span> tcp=1,mqtt=0,tcp_tx=0</span><br><span class="line"><span class="comment">[12:04:10.693]</span> </span><br><span class="line"><span class="comment">[12:04:15.680]</span> sec:345</span><br><span class="line"><span class="comment">[12:04:15.680]</span> tcp=1,mqtt=0,tcp_tx=0</span><br><span class="line"><span class="comment">[12:04:15.680]</span> len=14,ReFrModem:</span><br><span class="line"><span class="comment">[12:04:15.799]</span> 0, SEND OK</span><br><span class="line"><span class="comment">[12:04:15.799]</span> </span><br><span class="line"><span class="comment">[12:04:15.799]</span> send data done,rx SEND OK</span><br><span class="line"><span class="comment">[12:04:15.799]</span> send data, return 4</span><br><span class="line"><span class="comment">[12:04:15.799]</span> INFO: callback return 47,4</span><br><span class="line"><span class="comment">[12:04:15.799]</span> </span><br><span class="line"><span class="comment">[12:04:20.669]</span> sec:350</span><br><span class="line"><span class="comment">[12:04:20.669]</span> tcp=1,mqtt=0,tcp_tx=1</span><br><span class="line"><span class="comment">[12:04:20.669]</span> </span><br><span class="line"><span class="comment">[12:04:22.401]</span> len=13,ReFrModem:</span><br><span class="line"><span class="comment">[12:04:22.401]</span> 0, <span class="keyword">CLOSED</span></span><br><span class="line"><span class="comment">[12:04:22.401]</span> </span><br><span class="line"><span class="comment">[12:04:22.401]</span> mqtt_disconnect :gxd729</span><br><span class="line"><span class="comment">[12:04:22.401]</span> </span><br><span class="line"><span class="comment">[12:04:22.401]</span> send data err tcp disconnected</span><br><span class="line"><span class="comment">[12:04:22.401]</span> app_send_data_to_server return err</span><br><span class="line"><span class="comment">[12:04:22.401]</span> mqttc <span class="keyword">is</span> disconnected.</span><br><span class="line"><span class="comment">[12:04:22.401]</span> </span><br><span class="line"><span class="comment">[12:04:22.401]</span> connect 0 lose.</span><br><span class="line"><span class="comment">[12:04:22.401]</span> INFO: the at cmd func<span class="comment">[0]</span>'s range <span class="keyword">is</span> 48-7</span><br><span class="line"><span class="comment">[12:04:22.401]</span> INFO: funFirst:48  funLast:7</span><br><span class="line"><span class="comment">[12:04:22.401]</span> simcom_gsm_connect_server start.</span><br><span class="line"><span class="comment">[12:04:22.401]</span> 1. WrToModem:AT+CIPSHUT</span><br></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[HEXO+NODE10.13+GULP4.0博客搭建过程中的坑]]></title>
      <url>https://xubovey.github.io/2018/11/28/181128-node10-13-0-gulp4-0-bug-road/</url>
      <content type="html"><![CDATA[<h2 id="前情"><a href="#前情" class="headerlink" title="前情"></a>前情</h2><p>个人的静态日志网页有些日子没更新了。这两天想分享些东西上来。结果因为之前在七牛上的图床不让免费使用了，所以博客的头像也挂了，很是不爽。然后就有了下面的折腾。</p>
<h2 id="尝鲜"><a href="#尝鲜" class="headerlink" title="尝鲜"></a>尝鲜</h2><p>奔着尝鲜的念头更新了node，直接到10.13.0版本，在之后的编写更新过程中无意执行了<code>npm audit fix --force</code>,结果把很多依赖给升级了，之后就悲剧了，本地可以执行<code>hexo server</code>，使用travis自动发布时却总是在gulp处出错，本地也试了确实压缩出问题，然后就是一顿不服，一顿尝试。最终在如下网站中获取帮助得以解决，为帮助其他踩坑者特写此篇。
<a id="more"></a></p>
<h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>.<span class="string">js:</span><span class="number">85</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">assert</span>.AssertionError(&#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uglifier complains <span class="keyword">with</span> `Unexpected token: operator (&gt;)` <span class="keyword">in</span> <span class="number">0.10</span><span class="number">.5</span></span><br></pre></td></tr></table></figure>
<h2 id="线索"><a href="#线索" class="headerlink" title="线索"></a>线索</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Should be...</span><br><span class="line"></span><br><span class="line">ES5 → <span class="symbol">https:</span>/<span class="regexp">/www.npmjs.com/package</span><span class="regexp">/uglify-js → https:/</span><span class="regexp">/github.com/mishoo</span><span class="regexp">/UglifyJS2/blob</span><span class="regexp">/master/</span>README.md</span><br><span class="line">ES6+ (ES2015+) → <span class="symbol">https:</span>/<span class="regexp">/www.npmjs.com/package</span><span class="regexp">/uglify-es → https:/</span><span class="regexp">/github.com/mishoo</span><span class="regexp">/UglifyJS2/blob</span><span class="regexp">/harmony/</span>README.md</span><br><span class="line">... but is currently ...</span><br><span class="line"></span><br><span class="line">ES5 → <span class="symbol">https:</span>/<span class="regexp">/www.npmjs.com/package</span><span class="regexp">/uglify-js → https:/</span><span class="regexp">/github.com/mishoo</span><span class="regexp">/UglifyJS2/blob</span><span class="regexp">/master/</span>README.md</span><br><span class="line">ES6+ (ES2015+) → <span class="symbol">https:</span>/<span class="regexp">/www.npmjs.com/package</span><span class="regexp">/uglify-es → https:/</span><span class="regexp">/github.com/mishoo</span><span class="regexp">/UglifyJS2/blob</span><span class="regexp">/master/</span>README.md</span><br><span class="line"><span class="symbol">Cc:</span> <span class="variable">@isaacs</span> ... is there a way to have npmjs.com read the harmony branch README.md correctly? Thanks <span class="keyword">for</span> the visit <span class="keyword">in</span> advance.</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li>起初错误是gulpfile.js格式与gulp4.0不兼容，4.0的主要变更可<a href="http://web.jobbole.com/82992/" target="_blank" rel="noopener">参考</a></li>
<li>不支持ES6出现的<code>Unexpected token: operator (&gt;)</code>错误</li>
</ol>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="不兼容问题解决"><a href="#不兼容问题解决" class="headerlink" title="不兼容问题解决"></a>不兼容问题解决</h3><p>修改gulpfile.js修改后
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> minifycss = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-terser'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlclean = <span class="built_in">require</span>(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line"><span class="comment">// 压缩css文件</span></span><br><span class="line">gulp.task(<span class="string">'minify-css'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">  .pipe(minifycss())</span><br><span class="line">  .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩html文件</span></span><br><span class="line">gulp.task(<span class="string">'minify-html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">  .pipe(htmlclean())</span><br><span class="line">  .pipe(htmlmin(&#123;</span><br><span class="line">    removeComments: <span class="literal">true</span>,</span><br><span class="line">    minifyJS: <span class="literal">true</span>,</span><br><span class="line">    minifyCSS: <span class="literal">true</span>,</span><br><span class="line">    minifyURLs: <span class="literal">true</span>,</span><br><span class="line">  &#125;))</span><br><span class="line">  .pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩js文件</span></span><br><span class="line">gulp.task(<span class="string">'minify-js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.js'</span>)</span><br><span class="line">  .pipe(uglify())</span><br><span class="line">  .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 默认任务</span></span><br><span class="line"><span class="comment">// gulp.task('default', [</span></span><br><span class="line"><span class="comment">//   'minify-html','minify-css','minify-js'</span></span><br><span class="line"><span class="comment">// ]);</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, gulp.parallel(</span><br><span class="line">  <span class="string">'minify-html'</span>,<span class="string">'minify-css'</span>,<span class="string">'minify-js'</span></span><br><span class="line">));</span><br></pre></td></tr></table></figure></p>
<p>主要将<code>var uglify = require(&#39;gulp-uglify&#39;);</code>变为<code>var uglify = require(&#39;gulp-terser&#39;);</code><br>默认任务的并行执行做了修改，由<code>gulp.parallel</code>实现。
为了使用gulp-terser还需要修改package.json文件中的<code>&quot;gulp-uglify&quot;: &quot;^3.0.1&quot;,</code>为<code>&quot;gulp-terser&quot;: &quot;^1.1.5&quot;,</code></p>
]]></content>
      
        <categories>
            
            <category> hexo,gulp </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo,gulp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CodeWarrior开发环境搭建与程序下载]]></title>
      <url>https://xubovey.github.io/2018/11/27/181128-nxp-s08-CodeWarrior/</url>
      <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>CodeWarriorV6.3版本为32位版本，需要安装在32位机器或虚拟机上，自己是装在虚拟机上的。<br>下载地址：<a href="https://pan.baidu.com/s/1KxLyj4M1UdU38vvc_VyKog" target="_blank" rel="noopener">CodeWarriorV6.3</a>, 提取码：7um4
压缩包中包含4给文件分别是：  </p>
<ol>
<li>CW_MCU_V6.3–S08开发软件 - 软件安装包  </li>
<li>MC9S08AC60.pdf - 芯片手册  </li>
<li>USBDM_4_10_6_80_Win.msi - Flash编程工具  </li>
<li>USBDM_Drivers_1_2_0_WinXP_x32.msi - 编程器驱动  </li>
</ol>
<p>当然除此之外还需要对开发工具进行破解：</p>
<ul>
<li>把提供的license文件放到C:\Program Files\Freescale\CodeWarrior for Microcontrollers V6.3目录下</li>
</ul>
<p>注意：
安装包是32位的，建议虚拟机安装XP，不要折腾去找64位版本。应该是仿真器驱动只能是xp-32位
<a href="https://pan.baidu.com/s/1UKGKrKsD-LqnYIG3a1CGJg" target="_blank" rel="noopener">xp镜像下载</a>,提取码：br5w</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>需要依次安装软件安装包，编程工具和编程器驱动</p>
<h2 id="打开工程"><a href="#打开工程" class="headerlink" title="打开工程"></a>打开工程</h2><h3 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h3><p>从gitlab下载cloud_coffee_S9S08DZ60分支代码</p>
<h3 id="打开工程-1"><a href="#打开工程-1" class="headerlink" title="打开工程"></a>打开工程</h3><p>直接运行上一步下载的代码文件中的”WSD_010”,即可打开文件</p>
<h2 id="编译与下载"><a href="#编译与下载" class="headerlink" title="编译与下载"></a>编译与下载</h2><ol>
<li>快捷键“F7”可直接编译或单击工具栏”make”按钮进行编译  </li>
<li>如需将新的程序下载到单片机需要单击工具栏的”debug”按钮</li>
</ol>
<h2 id="仿真器与板相连"><a href="#仿真器与板相连" class="headerlink" title="仿真器与板相连"></a>仿真器与板相连</h2><p>仿真器与板之间只需要4根线即可烧录程序，分别是<code>VCC,GND,RST,BKG</code><br>板子上的IO描述在背面，仿真器上的IO描述在正面，对应连接即可</p>
<h2 id="只下载步骤"><a href="#只下载步骤" class="headerlink" title="只下载步骤"></a>只下载步骤</h2><p>安装如下工具</p>
<ol start="3">
<li>USBDM_4_10_6_80_Win.msi - Flash编程工具  </li>
<li>USBDM_Drivers_1_2_0_WinXP_x32.msi - 编程器驱动  </li>
</ol>
<ul>
<li>开始-&gt;USBDM 4.10.6.80-&gt;HS08 Programmer</li>
<li>连接仿真器</li>
<li>Interface-&gt;Detect连接仿真器</li>
<li>Target-&gt;LoadHexFiles,加载二进制文件</li>
<li>Target-&gt;Device Selection选择AC-MC9S08AC60</li>
<li>连接目标板</li>
<li>Target-&gt;Device Selection-&gt;Detect Chip</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[zigbee-tree-network-space]]></title>
      <url>https://xubovey.github.io/2017/12/26/171226-zigbee-tree-network-space/</url>
      <content type="html"><![CDATA[<p>参考：<a href="https://archive.freaklabs.org/index.php/blog/zigbee/zigbee-tree-routing-how-it-works-and-why-it-sucks.html" target="_blank" rel="noopener">Zigbee Tree Routing - How It Works and Why It Sucks</a></p>
<p>研究发现博文中Cm!=Rm情况下的公式存在问题。</p>
<p>描述树形网络可用3个重要参数：
Dm：最大网络深度
Cm：最大子节点数量
Rm：子节点中最大路由数量, Cm&gt;=Rm</p>
<p>先看简单例子：
Dm = 2, Cm = 3, Rm = 3
Dm   Cm=Rm
0    3^0=1
1    3^1=3
2    3^2=9
可以看出网络规模等于：<br><code>sum(Rm^n); n={0..Dm}</code></p>
<p>但是如果Cm&gt;Rm，例如：
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Dm = <span class="number">2</span>, Cm = <span class="number">7</span>, Rm = <span class="number">3</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>                 <span class="number">13</span>                    <span class="number">21</span></span><br><span class="line">        <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span>  <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span>  <span class="number">22</span> <span class="number">23</span> <span class="number">24</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">28</span></span><br><span class="line"></span><br><span class="line">Dm    Rm     Cm-Rm=<span class="number">4</span></span><br><span class="line"><span class="number">0</span>     <span class="number">3</span>^<span class="number">0</span>=<span class="number">1</span>  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>     <span class="number">3</span>^<span class="number">1</span>=<span class="number">3</span>  <span class="number">4</span>*<span class="number">3</span>^<span class="number">0</span>=<span class="number">4</span></span><br><span class="line"><span class="number">2</span>     <span class="number">3</span>^<span class="number">2</span>=<span class="number">9</span>  <span class="number">4</span>*<span class="number">3</span>^<span class="number">1</span>=<span class="number">12</span></span><br></pre></td></tr></table></figure></p>
<p>可以看出网络规模为1 + 3 + 4 + 9 + 12=29等于: </p>
<p><code>sum(Rm^n); n={0..Dm} + sum((Cm-Rm)*Rm^n); n={0..Dm-1}</code>
整理后：</p>
<p><code>1+sum(Cm*Rm^n); n={0..Dm-1}</code>  </p>
<p>Dm = 2, Cm = 7, Rm = 3带入公式；
1 + 7<em>1 + 7</em>3 = 29</p>
]]></content>
      
        <categories>
            
            <category> zigbee </category>
            
        </categories>
        
        
        <tags>
            
            <tag> zigbee </tag>
            
            <tag> tree network </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RF4CE_Remote eState]]></title>
      <url>https://xubovey.github.io/2017/07/24/170727-RF4CE_Remote/</url>
      <content type="html"><![CDATA[<h2 id="eState"><a href="#eState" class="headerlink" title="eState"></a>eState</h2><p><div id="flowchart-0" class="flow-chart"></div></p>
<p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">E_COLD_START=>start: E_COLD_START

E_COLD_START -> E_WAIT_FOR_EV_START_CFM
E_WAIT_FOR_EV_START_CFM -> E_WAIT_FOR_KEY
E_WAIT_FOR_KEY -> E_START_DISCOVERY
E_START_DISCOVERY -> E_WAIT_FOR_EV_DISC_DONE
E_WAIT_FOR_EV_DISC_DONE -> E_RF4CE_EV_DISC_CFM
E_RF4CE_EV_DISC_CFM -> E_START_PAIRING
E_RF4CE_EV_DISC_CFM -> E_PRE_RUNNING
E_RF4CE_EV_DISC_CFM -> E_WAIT_FOR_KEY
E_START_PAIRING -> E_RF4CE_EV_PAIR_CFM
E_RF4CE_EV_PAIR_CFM -> E_PAIRED
E_RF4CE_EV_PAIR_CFM -> E_PRE_RUNNING
E_RF4CE_EV_PAIR_CFM -> E_WAIT_FOR_KEY
E_PAIRED -> E_PRE_RUNNING
E_PRE_RUNNING -> E_RUNNING
E_RUNNING -> E_PRE_RUNNING
E_RUNNING -> E_START_DISCOVERY
E_RUNNING -> E_TRANSMITTING
E_TRANSMIT_FAILED -> E_PRE_RUNNING
E_TRANSMITTING -> E_RF4CE_EV_NLDE_CFM
E_RF4CE_EV_NLDE_CFM -> E_RUNNING
E_RF4CE_EV_NLDE_CFM -> E_TRANSMIT_FAILED</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[markdownFlowTest]]></title>
      <url>https://xubovey.github.io/2017/07/24/170724-markdownFlow/</url>
      <content type="html"><![CDATA[<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start|<span class="type">past</span>:&gt;http://www.google.com[blank]</span><br><span class="line">e=&gt;<span class="keyword">end</span>: <span class="keyword">End</span>:&gt;http://www.google.com</span><br><span class="line">op1=&gt;operation: My Operation|<span class="type">past</span></span><br><span class="line">op2=&gt;operation: Stuff|<span class="type">current</span></span><br><span class="line">sub1=&gt;subroutine: My Subroutine|<span class="type">invalid</span></span><br><span class="line">cond=&gt;condition: Yes</span><br><span class="line">or No?|<span class="type">approved</span>:&gt;http://www.google.com</span><br><span class="line">c2=&gt;condition: Good idea|<span class="type">rejected</span></span><br><span class="line">io=&gt;inputoutput: catch something...|<span class="type">request</span></span><br><span class="line"></span><br><span class="line">st-&gt;op1(<span class="built_in">right</span>)-&gt;cond</span><br><span class="line">cond(yes, <span class="built_in">right</span>)-&gt;c2</span><br><span class="line">cond(no)-&gt;sub1(<span class="built_in">left</span>)-&gt;op1</span><br><span class="line">c2(yes)-&gt;io-&gt;e</span><br><span class="line">c2(no)-&gt;op2-&gt;e</span><br></pre></td></tr></table></figure>
<h2 id="flow"><a href="#flow" class="headerlink" title="flow"></a>flow</h2><p><div id="flowchart-0" class="flow-chart"></div><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start|past:>http://www.google.com[blank]
e=>end: End:>http://www.google.com
op1=>operation: My Operation|past
op2=>operation: Stuff|current
sub1=>subroutine: My Subroutine|invalid
cond=>condition: Yes
or No?|approved:>http://www.google.com
c2=>condition: Good idea|rejected
io=>inputoutput: catch something...|request

st->op1(right)->cond
cond(yes, right)->c2
cond(no)->sub1(left)->op1
c2(yes)->io->e
c2(no)->op2->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[唯一不变的是变化中的需求]]></title>
      <url>https://xubovey.github.io/2017/06/30/170630-changing-requirement/</url>
      <content type="html"><![CDATA[<p>摘自<a href="http://icodeit.org/2017/01/why-software-is-complex/" target="_blank" rel="noopener">软件开发为什么很难</a>， 版权声明：自由转载-非商用-非衍生-保持署名| Creative Commons BY-NC-ND 3.0</p>
<h2 id="一个有意思的举例"><a href="#一个有意思的举例" class="headerlink" title="一个有意思的举例"></a>一个有意思的举例</h2><p>软件开发为什么很难中有一个需求不断变化的举例，很有意思，特意给记录下来  </p>
<p>需求的变化方向</p>
<p>作为程序员，有一天你被要求写一段代码，这段代码需要完成一件很简单的事：</p>
<p>打印”Hello, world”5次
很容易嘛，你想，然后顺手就写下了下面这几行代码：
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"Hello, world"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"Hello, world"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"Hello, world"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"Hello, world"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"Hello, world"</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>不过，拷贝粘贴看起来有点低端，你做了一个微小的改动：
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(var <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; <span class="number">5</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">  print(<span class="string">"Hello, world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看起来还不错，老板的需求又变成了打印”Goodbye, world”5次。既然是打印不同的消息，那何不把消息作为参数呢？
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printMessage</span><span class="params">(message)</span> &#123;</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; <span class="number">5</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">      print(message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printMessage(<span class="string">"Hello, world"</span>)</span><br><span class="line">printMessage(<span class="string">"Goodbye, world"</span>)</span><br></pre></td></tr></table></figure></p>
<p>有了这个函数，你可以打印任意消息5次了。老板又一次改变了需求：打印”Hello, world”13次（没人知道为什么是13）。既然次数也变化了，那么一个可能是将次数作为参数传入：
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printMessage</span><span class="params">(count, message)</span> &#123;</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; count; <span class="built_in">i</span>++) &#123;</span><br><span class="line">      print(message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printMessage(<span class="number">13</span>, <span class="string">"Hello, world"</span>);</span><br><span class="line">printMessage(<span class="number">5</span>, <span class="string">"Goodbye, world"</span>);</span><br></pre></td></tr></table></figure></p>
<p>完美，这就是抽象的魅力。有了这个函数，你可以将任意消息打印任意次数。不过老板是永远无法满足的，就在这次需求变化之后的第二天，他的需求又变了：不但要将”Hello, world”打印到控制台，还要将其计入日志。</p>
<p>没办法，通过搜索JavaScript的文档，你发现了一个叫做高阶函数的东东：函数可以作为参数传入另一个参数！</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span><span class="params">(message)</span> &#123;</span></span><br><span class="line">  system.<span class="built_in">log</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doMessage</span><span class="params">(count, message, action)</span> &#123;</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; count; <span class="built_in">i</span>++) &#123;</span><br><span class="line">      action(message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doMessage(<span class="number">5</span>, <span class="string">"Hello, world"</span>, print);</span><br><span class="line">doMessage(<span class="number">5</span>, <span class="string">"Hello, world"</span>, <span class="built_in">log</span>);</span><br></pre></td></tr></table></figure>
<p>这下厉害了，我们可以对任意消息，做任意次的任意动作！再回过头来看看那个最开始的需求：</p>
<p>打印”Hello, world”5次
稍微分割一下这句话：打印，”Hello, world”，5次，可以看到，这三个元素最后都变成了可以变化的点，软件开发很多时候正是如此，需求可能在任意可能变化的方向上变化。这也是各种软件开发原则尝试解决的问题：如何写出更容易扩展，更容易响应变化的代码来。</p>
<p>小节</p>
<p>软件的复杂性来自于大量的不确定性，而这个不确定性事实上是无法避免的，而且每个软件都是独一无二的。另一方面，软件的需求会以各种方式来变化，而且往往会以开发者没有预料到的方向。比如上面这个小例子中看到的，最后的需求可能会变成将消息以短信的方式发送给手机号以185开头的用户手机上。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Markdown table test]]></title>
      <url>https://xubovey.github.io/2017/06/29/170629-markdown-table-test/</url>
      <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>测试github markdown表格语法，因为之前想用表格时参照别人的语法得不到想要的表格。</p>
<h1 id="原生语法"><a href="#原生语法" class="headerlink" title="原生语法"></a>原生语法</h1><p>参考<a href="http://blog.csdn.net/tuxingchen6/article/details/55222951" target="_blank" rel="noopener">利用Markdown创建表格</a>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> Name </span>|<span class="string"> Academy </span>|<span class="string"> score </span>|<span class="string"> </span></span><br><span class="line">|<span class="string"> - </span>|<span class="string"> :-: </span>|<span class="string"> -: </span>|<span class="string"> </span></span><br><span class="line">|<span class="string"> Harry Potter </span>|<span class="string"> Gryffindor</span>|<span class="string"> 90 </span>|<span class="string"> </span></span><br><span class="line">|<span class="string"> Hermione Granger </span>|<span class="string"> Gryffindor </span>|<span class="string"> 100 </span>|<span class="string"> </span></span><br><span class="line">|<span class="string"> Draco Malfoy </span>|<span class="string"> Slytherin </span>|<span class="string"> 90 </span>|</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br>| Name | Academy | score | 
| - | :-: | -: | 
| Harry Potter | Gryffindor| 90 | 
| Hermione Granger | Gryffindor | 100 | 
| Draco Malfoy | Slytherin | 90 |</p>
<h1 id="教程1-简单语法"><a href="#教程1-简单语法" class="headerlink" title="教程1 简单语法"></a>教程1 简单语法</h1><p>参考<a href="http://blog.csdn.net/tuxingchen6/article/details/55222951" target="_blank" rel="noopener">利用Markdown创建表格</a>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name |<span class="string"> Academy </span>|<span class="string"> score </span></span><br><span class="line"><span class="string">- </span>|<span class="string"> :-: </span>|<span class="string"> -: </span></span><br><span class="line"><span class="string">Harry Potter </span>|<span class="string"> Gryffindor</span>|<span class="string"> 90 </span></span><br><span class="line"><span class="string">Hermione Granger </span>|<span class="string"> Gryffindor </span>|<span class="string"> 100 </span></span><br><span class="line"><span class="string">Draco Malfoy </span>|<span class="string"> Slytherin </span>|<span class="string"> 90</span></span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br>Name | Academy | score  </p>
<ul>
<li>| :-: | -:<br>Harry Potter | Gryffindor| 90<br>Hermione Granger | Gryffindor | 100<br>Draco Malfoy | Slytherin | 90  </li>
</ul>
<h1 id="教程2-简书教程"><a href="#教程2-简书教程" class="headerlink" title="教程2 简书教程"></a>教程2 简书教程</h1><p>参考<a href="http://www.jianshu.com/p/1e402922ee32/" target="_blank" rel="noopener">Markdown——入门指南</a>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">| Tables        |</span> Are           <span class="params">| Cool  |</span></span><br><span class="line"><span class="params">| ------------- |</span><span class="symbol">:-------------</span><span class="symbol">:|</span> -----<span class="symbol">:|</span></span><br><span class="line"><span class="params">| col 3 is      |</span> right-aligned <span class="params">| $1600 |</span></span><br><span class="line"><span class="params">| col 2 is      |</span> centered      <span class="params">|   $12 |</span></span><br><span class="line"><span class="params">| zebra stripes |</span> are neat      <span class="params">|    $1 |</span></span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br>| Tables | Are| Cool  |<br>| —–|:—–:| —–:|<br>| col 3 is|right-aligned|$1600|<br>| col 2 is| centered|$12|<br>| zebra stripes | are neat|$1 |  </p>
]]></content>
      
        <categories>
            
            <category> markdown </category>
            
        </categories>
        
        
        <tags>
            
            <tag> markdown </tag>
            
            <tag> table </tag>
            
            <tag> test </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[170628-Create_a_empty_branch_under_git]]></title>
      <url>https://xubovey.github.io/2017/06/28/170628-Create-a-empty-branch/</url>
      <content type="html"><![CDATA[<p>参考链接</p>
<p>Creating Project Pages manually
作者: Volcano 发表于October 15, 2012 at 3:38 pm</p>
<p>版权信息: 可以任意转载, 转载时请务必以超链接形式标明文章原始出处和作者信息及此声明</p>
<p>永久链接 - <a href="http://www.ooso.net/archives/636" target="_blank" rel="noopener">http://www.ooso.net/archives/636</a></p>
<p>有时候我们需要在Git下创建一个空分支，从头开始Coding —— 这大概是那些重构帝最喜欢的事情。参考了github，才找到一个合适的方法。</p>
<p>怎样安全的进行这项操作</p>
<p>我们需要建一个“孤立”的空分支，为了尽可能的保证数据安全，最好还是重新clone一份代码。
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$git clone https:<span class="comment">//github.com/user/repo.git</span></span><br><span class="line"><span class="meta"># Clone our repo</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Cloning into \'repo\'...</span></span><br><span class="line"><span class="meta"># remote: Counting objects: 2791, done.</span></span><br><span class="line"><span class="meta"># remote: Compressing objects: 100% (1225/1225), done.</span></span><br><span class="line"><span class="meta"># remote: Total 2791 (delta 1722), reused 2513 (delta 1493)</span></span><br><span class="line"><span class="meta"># Receiving objects: 100% (2791/2791), 3.77 MiB | 969 KiB/s, done.</span></span><br><span class="line"><span class="meta"># Resolving deltas: 100% (1722/1722), done.</span></span><br></pre></td></tr></table></figure></p>
<p>开工</p>
<p>这里以github的操作为例，下面试图创建一个名为gh-pages的空分支
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$cd repo</span><br><span class="line"></span><br><span class="line">$ git checkout --orphan gh-pages</span><br><span class="line"><span class="meta"># 创建一个orphan的分支，这个分支是独立的</span></span><br><span class="line">Switched <span class="keyword">to</span> a new branch \<span class="string">'gh-pages\'</span></span><br><span class="line"></span><br><span class="line">git rm -rf .</span><br><span class="line"><span class="meta"># 删除原来代码树下的所有文件</span></span><br><span class="line">rm \<span class="string">'.gitignore\'</span></span><br></pre></td></tr></table></figure></p>
<p>注意这个时候你用git branch命令是看不见当前分支的名字的，除非你进行了第一次commit。</p>
<p>下面我们开始添加一些代码文件，例如这里新增了一个index.html
<figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$ </span>echo \<span class="comment">"My GitHub Page\"</span> &gt; index.html</span><br><span class="line"><span class="string">$ </span>git add .</span><br><span class="line"><span class="string">$ </span>git commit -a -m \<span class="comment">"First pages commit\"</span></span><br><span class="line"><span class="string">$ </span>git push origin gh-pages</span><br></pre></td></tr></table></figure></p>
<p>在commit操作之后，你就可以用git branch命令看到新分支的名字了，然后push到远程仓库。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Vscode GBKtoUTF8 bug]]></title>
      <url>https://xubovey.github.io/2017/06/12/170612-Vscode-GBKtoUTF8-bug/</url>
      <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>使用Vscode过程中，会有一些文件是GBK编码格式，打开后是乱码，所以就安装了插件GBKtoUTF8，自动进行转换。<br>问题来了，如果一个<code>*.h</code>文件是GBK编码格式的，同时这个文件又被一个<code>*.c</code>文件给包含了，那么当按住ctrl键，同时移动鼠标到这个头文件的名称上时，会在当前位置打开<code>*.h</code>文件进行格式转换，并将转换后的代码覆盖<code>*.c</code>文件中的原有代码。</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>需要时再打开GBKtoUTF8功能。^_^，简单粗暴。</p>
]]></content>
      
        
        <tags>
            
            <tag> Vscode </tag>
            
            <tag> GBKtoUTF8 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TPS54331 Debug]]></title>
      <url>https://xubovey.github.io/2017/05/16/170516-TPS5431-Debug/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>一个项目中用到了TPS54331电源芯片，电源输入电压5V，输出4V，负载GPRS模块。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>上电后设备无法正常工作，输出波形2s周期三角波，最低电压2V，最高电压4V。增大输入电压后工作正常；或者增大输出电流后也正常。故障现象具有普遍性，所有设备都存在相同问题。
<a id="more"></a></p>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>根据故障现象和查阅手册可知，因为GPRS模块的电流时突变的，最低时只有几十毫安，峰值却能达到1安。所以问题出现在几十毫安，查电源芯片数据手册可知，负载电流较小时，电源芯片将进入ECO模式【当电感上最大电流小于160mA时，设备进入ECO模式】。<br>问题就发生在ECO模式，为了提高效率在负载较小时，会进入ECO模式，降低开关频率。ECO模式下要维持设备正常工作，要求输入关断期间，输出电感上电流不能间断，因此要求输出电感较大。<br>然而实际调试过程中，即便将输出电感增加到100uH，也要输入电压5.5V才能正常工作。进一步测试发现，当减小输出电容时(GPRS模块数据手册要求输入电容470uF x 2，电路设计中为470uFx2，20uF*2)，输出三角波的频率会增加。进一步减小电容（拆除470uFx2）后，输出更趋于良好。增加一个120Ω负载后，输出正常。</p>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><ol>
<li>输入电压7V，输出电容不变，输出4V工作正常；  </li>
<li>输入5V，输出电容减少，输出4V工作正常。<br>原因：输入-输出压差小于2V时，芯片监测BOOT管脚的电压作为欠压保护输入。因此需要保持电感器上电流不能为0。当输入输出压差大于2V时，输入欠压用输入分压后由EN监测实现。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>无计可施的时候认真阅读数据手册是很好的选择。</p>
]]></content>
      
        
        <tags>
            
            <tag> TPS54331 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BeyondStudio for NXP Builder Settings]]></title>
      <url>https://xubovey.github.io/2017/04/19/170419-BeyondStudio-for-NXP-Builder-Settings/</url>
      <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>在使用<code>BeyondStudio</code>过程中，发现修改Makefile中的部分配置信息无效，不能生产相应的文件，例如配置了<code>JENNIC_CHIP=JN5168</code>,但是实际生成的文件却是<code>JENNIC_CHIP=JN5169</code>。
<a id="more"></a></p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><ul>
<li>打开<code>Project</code>-&gt;<code>Properties</code>-&gt;<code>C/C++ Build</code>-&gt;<code>Builder Settings</code></li>
<li>勾选<code>Use default build command</code></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> BeyondStudio </tag>
            
            <tag> Builder </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BeyondStudio Nxp IDE Note]]></title>
      <url>https://xubovey.github.io/2017/02/24/170224-BeyondStudio-Nxp-IDE-Note/</url>
      <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>最近研究JN5168，需要用到NXP官方提供的开发环境，使用中遇到的小东小西就纪录在这里。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Type-‘uint8’-could-not-be-resolved"><a href="#Type-‘uint8’-could-not-be-resolved" class="headerlink" title="Type ‘uint8’ could not be resolved"></a>Type ‘uint8’ could not be resolved</h2><p>参考官方文档JN-UG-3098，page 25：<br>Step 4 Configure the workspace preferences as follows:  </p>
<ul>
<li>Open the Preferences dialogue box by following the menu path Window&gt;Preferences.</li>
<li>In the left tree of the Preferences dialogue box, open the C/C++ entry and click on the Indexer sub-entry. The right side of the dialogue box is now populated with the Indexer options.</li>
<li>In the section Build configuration for the indexer, select the radio-button Use active build configuration.</li>
<li>Click Apply and then OK.</li>
</ul>
<p>问题解决。每次新建workspace都需要配置。
<a id="more"></a></p>
<h3 id="有时候执行完上面的操作后仍然有问题"><a href="#有时候执行完上面的操作后仍然有问题" class="headerlink" title="有时候执行完上面的操作后仍然有问题"></a>有时候执行完上面的操作后仍然有问题</h3><p><a href="http://blog.163.com/rainsmell_/blog/static/212827113201431605936633/" target="_blank" rel="noopener">LittleBoy’s Blog</a>找到如下解决办法：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">也不知道这算不算是一个bug，即便是添加了所有object所依赖的head files，<span class="keyword">include</span> path也完整，依然会出现这个问题。refresh工程，重启Eclipse也无济于事。</span><br><span class="line">Google了一番,终于在stackoverflow里找到了解决办法：  </span><br><span class="line"><span class="symbol">http:</span>/<span class="regexp">/stackoverflow.com/questions</span><span class="regexp">/10041453/eclipse</span>-c-type-could-<span class="keyword">not</span>-be-resolved-error-even-though-build-is-successful  </span><br><span class="line">记录一下，Project -&gt; C/C++ index -&gt; Freshen All Files，问题解决。</span><br></pre></td></tr></table></figure></p>
<h2 id="workspace"><a href="#workspace" class="headerlink" title="workspace"></a>workspace</h2><p>自定义workspace，不能编译问题。<br>原因:<br><code>SDK_BASE_DIR</code>变量没有正确获取SDK路径。abspath函数返回的是当前路径的绝对路径，也就是workspace的绝对路径。
解决：<br>重新安装sdk，安装路径设置为workspace所在路径。例如：  </p>
<ol>
<li>workspace路径为：d:/workspace/nxp-workspace</li>
<li>安装路径应设置为：d:/workspace</li>
</ol>
<p>使用中，先执行clean project，然后再编译</p>
<h2 id="import工程后文件夹为空"><a href="#import工程后文件夹为空" class="headerlink" title="import工程后文件夹为空"></a>import工程后文件夹为空</h2><p>问题：<br>导入<code>JN-AN-1229.zip</code>工程时，导入后项目文件夹下只有两个文件<code>.cproject`</code>.project`。当然也无法编译了，怎么办呢？<br>解决：  </p>
<ul>
<li>将<code>JN-AN-1229.zip</code>解压到<code>当前</code>文件夹;</li>
<li>从文件夹中导入工程时，把options-&gt;Copy projects into workspace 选项取消；</li>
<li>导入后工程的目录里面显示的链接标志，不过可以编译了。</li>
</ul>
<p>原因：<br>暂时不清楚。</p>
<p>后来遇到上述办法不能解决的项目<code>JN-AN-1217.zip</code>。经过一番研究最后发现<code>JN-AN-1217-Zigbee-3-0-Base-Device-v1005\JN-AN-1217-Zigbee-3-0-Base-Device\JN516x</code>这个目录下有个<code>.project</code>文件,文件最后有代码：
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;linkedResources&gt;</span></span><br><span class="line">	<span class="params">&lt;link&gt;</span></span><br><span class="line">		<span class="params">&lt;name&gt;</span>Common<span class="params">&lt;/name&gt;</span></span><br><span class="line">		<span class="params">&lt;type&gt;</span><span class="number">2</span><span class="params">&lt;/type&gt;</span></span><br><span class="line">		<span class="params">&lt;location&gt;</span>C:/NXP/bstudio_nxp<span class="meta-keyword">/workspace/</span>JN-AN<span class="number">-1217</span>-Zigbee<span class="number">-3</span><span class="number">-0</span>-Base-Device/Common<span class="params">&lt;/location&gt;</span></span><br><span class="line">	<span class="params">&lt;/link&gt;</span></span><br><span class="line">	<span class="params">&lt;link&gt;</span></span><br><span class="line">		<span class="params">&lt;name&gt;</span>Coordinator<span class="params">&lt;/name&gt;</span></span><br><span class="line">		<span class="params">&lt;type&gt;</span><span class="number">2</span><span class="params">&lt;/type&gt;</span></span><br><span class="line">		<span class="params">&lt;location&gt;</span>C:/NXP/bstudio_nxp<span class="meta-keyword">/workspace/</span>JN-AN<span class="number">-1217</span>-Zigbee<span class="number">-3</span><span class="number">-0</span>-Base-Device/Coordinator<span class="params">&lt;/location&gt;</span></span><br><span class="line">	<span class="params">&lt;/link&gt;</span></span><br><span class="line">	<span class="params">&lt;link&gt;</span></span><br><span class="line">		<span class="params">&lt;name&gt;</span>EndDevice<span class="params">&lt;/name&gt;</span></span><br><span class="line">		<span class="params">&lt;type&gt;</span><span class="number">2</span><span class="params">&lt;/type&gt;</span></span><br><span class="line">		<span class="params">&lt;location&gt;</span>C:/NXP/bstudio_nxp<span class="meta-keyword">/workspace/</span>JN-AN<span class="number">-1217</span>-Zigbee<span class="number">-3</span><span class="number">-0</span>-Base-Device/EndDevice<span class="params">&lt;/location&gt;</span></span><br><span class="line">	<span class="params">&lt;/link&gt;</span></span><br><span class="line">	<span class="params">&lt;link&gt;</span></span><br><span class="line">		<span class="params">&lt;name&gt;</span>Router<span class="params">&lt;/name&gt;</span></span><br><span class="line">		<span class="params">&lt;type&gt;</span><span class="number">2</span><span class="params">&lt;/type&gt;</span></span><br><span class="line">		<span class="params">&lt;location&gt;</span>C:/NXP/bstudio_nxp<span class="meta-keyword">/workspace/</span>JN-AN<span class="number">-1217</span>-Zigbee<span class="number">-3</span><span class="number">-0</span>-Base-Device/Router<span class="params">&lt;/location&gt;</span></span><br><span class="line">	<span class="params">&lt;/link&gt;</span></span><br><span class="line"><span class="params">&lt;/linkedResources&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>意思很直白了。那么其他工程是怎么配置的呢
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">linkedResources</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">link</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>Common<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">type</span>&gt;</span>2<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">locationURI</span>&gt;</span>PARENT-1-PROJECT_LOC/Common<span class="tag">&lt;/<span class="name">locationURI</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">link</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>Coordinator<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">type</span>&gt;</span>2<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">locationURI</span>&gt;</span>PARENT-1-PROJECT_LOC/Coordinator<span class="tag">&lt;/<span class="name">locationURI</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">link</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>EndDevice<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">type</span>&gt;</span>2<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">locationURI</span>&gt;</span>PARENT-1-PROJECT_LOC/EndDevice<span class="tag">&lt;/<span class="name">locationURI</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">link</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>Router<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">type</span>&gt;</span>2<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">locationURI</span>&gt;</span>PARENT-1-PROJECT_LOC/Router<span class="tag">&lt;/<span class="name">locationURI</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">linkedResources</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>明白了吧，放到C盘才行，😄。</p>
<h2 id="include文件不够"><a href="#include文件不够" class="headerlink" title="include文件不够"></a>include文件不够</h2><p>问题：<br>缺少<code>C:\NXP\bstudio_nxp\sdk\JN-SW-4170\Components\ZigbeeCommon\Include</code></p>
<p>解决： 
在<code>项目右键-&gt;properties -&gt; general -&gt; paths and symbols -&gt; include</code> 点击add，添加如上路径即可。</p>
<h2 id="app-zpscfg"><a href="#app-zpscfg" class="headerlink" title="app.zpscfg"></a>app.zpscfg</h2><p>app.zpscfg如何打开呢？其实<code>JN-UG-3098 Beyond Studio for NXP</code>文件中已经进行了详细描述。文件的<code>1.2.3Installing the ZigBee Plug-ins</code>章节有着详细的描述。需要在eclipse环境下安装2个插件分别是<code>ZPS Configuration Editor</code>和<code>JenOS Configuration Editor</code>,具体请参考文档<a href="https://www.nxp.com/docs/en/user-guide/JN-UG-3098.pdf" target="_blank" rel="noopener">JN-UG-3098</a></p>
<h2 id="不喜欢IDE，如何用命令行进行编译？"><a href="#不喜欢IDE，如何用命令行进行编译？" class="headerlink" title="不喜欢IDE，如何用命令行进行编译？"></a>不喜欢IDE，如何用命令行进行编译？</h2><p>其实demo文档中是有介绍的，以JN-AN-1217-Zigbee-3-0-Base-Device.pdf为例。文件的5.7.2.1介绍的就是用makefile编译的方法。摘抄如下：</p>
<ol>
<li>Ensure that the project directory is located in
 <ide installation="" root="">\workspace</ide></li>
<li>Start an MSYS shell by following the Windows Start menu path: All Programs &gt; NXP &gt; MSYS Shell</li>
<li>Navigate to the Build directory for the application to be built and at the command prompt enter an appropriate make command for your chip type, as illustrated below.
For example, for JN5169:
make JENNIC_CHIP_FAMILY=JN516x JENNIC_CHIP=JN5169 clean all
The binary file will be created in the Build directory, the resulting filename indicating the chip type (e.g. 5169) for which the application was built.</li>
<li>Load the resulting binary file into the board. You can do this from the command line using the JN51xx Production Flash Programmer, as described in Section 4.1.</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Nxp </category>
            
        </categories>
        
        
        <tags>
            
            <tag> BeyondStudio </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[17224-bstudio_nxp-User Workspace config]]></title>
      <url>https://xubovey.github.io/2017/02/24/17224-bstudio-nxp-User-Workspace-config/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近要搞JN5168的开发，下载了官网的历程，搭建了官方提供的bstudio_nxp环境，默认配置下，导入官方demo，编译成功，但是导入到自定义<code>workspace</code>路径时就不能成功。</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>简单了解发现，工程中的C文件包涵的头文件都没有。研究build文件夹下的makefile发现有如下语句：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SDK_BASE_DIR       ?= $(abspath ../../../../sdk/$(JENNIC_SDK)/)</span><br><span class="line">APP_BASE            = $(abspath ../..)</span><br><span class="line">APP_BLD_DIR         = $(APP_BASE)/$(TARGET)/Build</span><br><span class="line">APP_SRC_DIR         = $(APP_BASE)/$(TARGET)/Source</span><br><span class="line">APP_COMMON_SRC_DIR  = $(APP_BASE)/Common/Source</span><br></pre></td></tr></table></figure></p>
<p>可以发现<code>SDK_BASE_DIR</code>经过路径设定指向了<code>sdk/JN-SW-4163</code>,而<code>JN-SW-4163</code>中放的是板级支持包，正是工程中c文件内缺少的头文件存放的位置。<br>分析默认配置发现，这些路径是在安装路径下可用的，而makefile用的是当前路径。所以呢最简单的办法是修改<code>SDK_BASE_DIR</code>变量指向<code>JN-SW-4163</code>所在路径。参考
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#SDK_BASE_DIR       ?= $(abspath <span class="regexp">/C/</span>NXP<span class="regexp">/bstudio_nxp/</span>sdk<span class="regexp">/$(JENNIC_SDK)/</span>)</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>如果只想指向自定义的路径呢？？<br>有点小麻烦…不过还是有办法的！这么修改变量<code>SDK_BASE_DIR</code><br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDK_BASE_DIR       ?= <span class="variable">$(<span class="built_in">abspath</span> ../../../<span class="variable">$(JENNIC_SDK)</span>/)</span></span><br></pre></td></tr></table></figure></p>
<p>之后把对应的板级支持包拷贝到用户设定的路径<code>workspace</code>下。但是还没完…<br>因为板级支持包下有<code>config.mk</code>文件，内部制定了编译相关的参数，而指向的路径还是在安装环境下，也是通过SDK_BASE_DIR变量访问的，所以还需要把板级支持包同路径的<code>tools</code>文件复制到用户<code>workspace</code>下。想想都好麻烦.</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>所以还是改Makefile比较简单。
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#SDK_BASE_DIR       ?= $(abspath <span class="regexp">/C/</span>NXP<span class="regexp">/bstudio_nxp/</span>sdk<span class="regexp">/$(JENNIC_SDK)/</span>)</span><br></pre></td></tr></table></figure></p>
<p>不过就用官方默认配置还是最方便的选择。</p>
]]></content>
      
        <categories>
            
            <category> NXP </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bstudio_nxp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[chrome自动打开ahlqs bengpala 51m33]]></title>
      <url>https://xubovey.github.io/2017/02/08/170208-chrome-ahlqs-bengpala-51m33/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>网上下载了个破解工具，然后还无视windows defender提示的有问题。结果…杯了个具。</p>
<p>经过很多次的折腾…
<a id="more"></a></p>
<h1 id="卸载、删除"><a href="#卸载、删除" class="headerlink" title="卸载、删除"></a>卸载、删除</h1><p>卸载了当前安装的所有软件。不能卸载的看文件或文件夹的更新时间如果是当前的考虑是否删除，总之删除了很多，当然可能有的是不需要的。
嗯嗯，中间不能删除的就没管了，结果。</p>
<h1 id="顽固之主"><a href="#顽固之主" class="headerlink" title="顽固之主"></a>顽固之主</h1><p>ahlqs bengpala 51m33这三个网页总是在chrome打开，无论修改默认浏览器或chrome重置都无效。最后在这个<a href="https://productforums.google.com/forum/#!topic/chrome/WF6jm5fGwBo" target="_blank" rel="noopener">网页</a>找到了解决办法。  </p>
<blockquote>
<p>Deactivate “msiql” in starting programs at task manager. Then delete application by going in its folder. Worked for me.  </p>
</blockquote>
<p>怎么操作呢：</p>
<ol>
<li>打开任务管理器，找到msiql这个任务</li>
<li>在任务上右键选择打开文件位置</li>
<li>结束msiql任务</li>
<li>删除msiql文件所在文件夹。</li>
</ol>
<p>因为被折磨的比较厉害，所以当我发现文件是在local/tmp目录下的时候就残忍的把所有文件都删除了，这个文件之前已经被删除过，那些不能删的就没动。</p>
<h1 id="教训"><a href="#教训" class="headerlink" title="教训"></a>教训</h1><p>这个就是用盗版，还不停杀毒软件提醒的后果。_-_</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[useful_tool]]></title>
      <url>https://xubovey.github.io/2017/01/03/170103-useful-tool/</url>
      <content type="html"><![CDATA[<h1 id="简述："><a href="#简述：" class="headerlink" title="简述："></a>简述：</h1><p>记录工作学习中遇到的经典好用的工具软件。</p>
<h1 id="工作篇"><a href="#工作篇" class="headerlink" title="工作篇"></a>工作篇</h1><h1 id="AxeSlide斧子演示"><a href="#AxeSlide斧子演示" class="headerlink" title="AxeSlide斧子演示"></a><a href="http://www.axeslide.com/" target="_blank" rel="noopener">AxeSlide斧子演示</a></h1><p>AxeSlide是PPT的良好替代品，跨平台，基于Html5 2D/3D技术开发。动画特效等效果十分不错。<br>工具提供很多免费模板，作品可导出pdf格式文件。<br>下载地址：<a href="http://www.axeslide.com/download" target="_blank" rel="noopener">http://www.axeslide.com/download</a></p>
<h1 id="XMIND"><a href="#XMIND" class="headerlink" title="XMIND"></a><a href="http://www.xmindchina.net/" target="_blank" rel="noopener">XMIND</a></h1><p>xmind是一个优秀的思维导图工具，带甘特图功能，甘特图能导出到microsoft project工具中。功能十分强大。
还可以导出word，pdf，excel格式.有不同风格可以选择。自带的任务管理功能包含干特视图。便捷的任务管理，
任务依赖，任务时间调整等等。  </p>
<h1 id="桌面日历"><a href="#桌面日历" class="headerlink" title="桌面日历"></a><a href="http://chs.desktopcal.com/chs/" target="_blank" rel="noopener">桌面日历</a></h1><p>双击桌面即可记录琐事，非常方便，非常实用。桌面日历®能帮您轻松管理约会、待办事项、日程安排 … 不仅如此，桌面日历®还提供万年农历、24节气与各种常见的节庆、纪念日等信息。
现在就下载吧，桌面日历®永久免费。
可以注册账户登陆，进行网络同步。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Electron serialport 应用]]></title>
      <url>https://xubovey.github.io/2016/11/05/161105-electron-serialport/</url>
      <content type="html"><![CDATA[<h1 id="参考1"><a href="#参考1" class="headerlink" title="参考1"></a>参考1</h1><p><a href="https://github.com/nodejs/node-gyp" target="_blank" rel="noopener">nodejs/node-gyp</a></p>
<ul>
<li>npm install -g node-gyp</li>
<li>npm install –global –production windows-build-tools</li>
</ul>
<p>如果有多个Python版本，需要给<code>node-gyp</code>指定版本：
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node-gyp --python /path/<span class="keyword">to</span>/python2.7</span><br><span class="line">npm<span class="built_in"> config </span><span class="builtin-name">set</span> python /path/<span class="keyword">to</span>/executable/python2.7</span><br></pre></td></tr></table></figure></p>
<h1 id="参考2"><a href="#参考2" class="headerlink" title="参考2"></a>参考2</h1><p><a href="https://github.com/paulolc/electron-quick-start-serialport" target="_blank" rel="noopener">paulolc/electron-quick-start-serialport</a>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/paulolc/electron-quick-<span class="literal">start</span>-serialport</span><br><span class="line">cd electron-quick-<span class="literal">start</span>-serialport</span><br><span class="line">npm install &amp;&amp; npm <span class="literal">start</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Contiki Rime协议分析-abc]]></title>
      <url>https://xubovey.github.io/2016/11/02/161102-Contiki-rime-abc/</url>
      <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0 背景"></a>0 背景</h1><p>在研究rime过程中使用了example中的rime文件夹下的例程，中间遇到的问题进行记录。</p>
<a id="more"></a>
<h1 id="1-make出错"><a href="#1-make出错" class="headerlink" title="1 make出错"></a>1 make出错</h1><p>在rime例程文件夹下执行如下命令，以错误退出。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make TARGET=srf06-cc26xx BOARD=srf06/cc26xx</span><br></pre></td></tr></table></figure></p>
<p>后来分析原因是里面有多个历程，复制rime到新的文件夹，将没用的c文件删除，哪些没用？可以看makefile文件中<code>all:</code>后面的名称对应的c文件，除了example-abc.c外的所有文件。</p>
<h1 id="2-接收不到数据"><a href="#2-接收不到数据" class="headerlink" title="2 接收不到数据"></a>2 接收不到数据</h1><p>接收方式：开发板+仿真器+smartrf radio 2.4.3
可以接收到数据但是有溢出警告。
警告没关系，看看数据对不对：</p>
<ul>
<li>发送的内容：<code>Hello</code>  </li>
<li>对应的HEX：<code>48 65 65 60 6f</code>  </li>
</ul>
<p>smartrf radio接收到的十六进制数据：<br><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">16:58:33.737 |<span class="number"> 16792 </span>| 0e cd ab ff ff<span class="number"> 03 </span>3b<span class="number"> 80 </span>00<span class="number"> 48 </span>65 6c 6c 6f<span class="number"> 00 </span> |  -39</span><br></pre></td></tr></table></figure></p>
<p>可以发现其中包含<code>48 65 65 60 6f</code>，看来数据正确，只是两种格式不一样而已，所以报错的。</p>
<p>如何才能正确显示呢？
很简单，两个板子都烧写同样的程序就好了。</p>
<h1 id="3-example-abc数据怎么出去的"><a href="#3-example-abc数据怎么出去的" class="headerlink" title="3 example-abc数据怎么出去的"></a>3 example-abc数据怎么出去的</h1><p>要说过程的话还是这个图片介绍的清楚：<a href="http://blog.sina.com.cn/s/blog_686ee2910102vvf9.html" target="_blank" rel="noopener">转载</a>  </p>
<p><img src="http://oefaano2o.bkt.clouddn.com/blogimages/images/161102-Contiki-rime-abc/161102-Contiki-rime-abc-01.png-blog" alt=""></p>
<blockquote>
<p>如图2所示，描述了Contiki中整个无线传输链路基本结构，主要包含了：网络层（NETSTACK_NETWORK）、链路层安全驱动（link layer security driver, NETSTACK_LLSEC）、MAC层（Media Access Control, NETSTACK_MAC）,RDC层（Radio Duty Cycling，NETSTACK_RDC）以及物理层（NETSTACK_RADIO）。<br>在图2的左边一列为对应不同层次，对应需要实现的驱动接口结构，右边为各个层次之间相互的调用情况（只提取了最重要的部分，相关处理没有细化）。<br>其中网络层主要完成相关无线网络的连接、组网等情况，链路层安全驱动用于保证整个传输链路的数据安全，MAC层完成物理媒介的访问控制，RDC层用于控制无线电电路的开断，可以有效的控制无线电部分的耗电情况，RADIO层实现了不同无线媒介底层访问驱动，完成整个无线链路的访问与操作。  </p>
</blockquote>
<h2 id="3-1-函数调用过程跟踪："><a href="#3-1-函数调用过程跟踪：" class="headerlink" title="3.1 函数调用过程跟踪："></a>3.1 函数调用过程跟踪：</h2><p>abc_send -&gt;<br>rime_output(&amp;c-&gt;channel); -&gt;<br>NETSTACK_LLSEC.send(packet_sent, c); (nullsec_driver.send) =<br>nullsec_driver.send(packet_sent, c); -&gt;<br>NETSTACK_MAC.send(sent, ptr); (csma_driver) =<br>csma_driver.send(sent, ptr); =<br>send_packet(sent, ptr); -&gt;<br>schedule_transmission(n); -&gt;<br>//这里用到ctiemr<br>ctimer_set(&amp;n-&gt;transmit_timer, delay, transmit_packet_list, n); -&gt;<br>transmit_packet_list(void *ptr) -&gt;<br>NETSTACK_RDC.send_list(packet_sent, n, q); (contikimac_driver) =<br>contikimac_driver.qsend_list(packet_sent, n, q); -&gt;<br>ret = send_packet(sent, ptr, curr, is_receiver_awake); -&gt;<br>NETSTACK_RADIO.transmit(transmit_len); -&gt;<br>ret = rf_core_send_cmd((uint32_t)&amp;cmd, &amp;cmd_status);</p>
<h2 id="3-2-数据传递过程："><a href="#3-2-数据传递过程：" class="headerlink" title="3.2 数据传递过程："></a>3.2 数据传递过程：</h2><p>packetbuf.c文件中定义有如下变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packetbuf_attr</span> <span class="title">packetbuf_attrs</span>[<span class="title">PACKETBUF_NUM_ATTRS</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packetbuf_addr</span> <span class="title">packetbuf_addrs</span>[<span class="title">PACKETBUF_NUM_ADDRS</span>];</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span> packetbuf_aligned[(PACKETBUF_SIZE + <span class="number">3</span>) / <span class="number">4</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> *packetbuf = (<span class="keyword">uint8_t</span> *)packetbuf_aligned;</span><br></pre></td></tr></table></figure>
<h1 id="4-abc"><a href="#4-abc" class="headerlink" title="4 abc"></a>4 abc</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">abc_conn</span> <span class="title">abc</span>;</span></span><br><span class="line">abc_open(&amp;abc, <span class="number">128</span>, &amp;abc_call);</span><br><span class="line">packetbuf_copyfrom(<span class="string">"Hello"</span>, <span class="number">6</span>);</span><br><span class="line">abc_send(&amp;abc);</span><br></pre></td></tr></table></figure>
<p>其中abc_conn数据结构如下
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">abc_conn</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">channel</span> <span class="title">channel</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">abc_callbacks</span> *<span class="title">u</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>abc_open(&amp;abc, 128, &amp;abc_call);
abc_open使能了128通道，并将abc的通道添加到channel_list上；<br>并设置abc_call为abc的回调函数。</li>
<li>packetbuf_copyfrom(“Hello”, 6);<br>此函数将Hello拷贝到*packetbuf，即packetbuf_aligned内。</li>
<li><p>abc_send(&amp;abc);
函数中调用语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rime_output(&amp;c-&gt;channel);</span><br></pre></td></tr></table></figure>
</li>
<li><p>rime_output中调用函数<code>NETSTACK_LLSEC.send(packet_sent, c);</code>  </p>
</li>
</ul>
<p>可以看到这些参数传递是通过<code>struct abc_conn abc;</code>进行的。</p>
<h1 id="5-llsec-Link-layer-security"><a href="#5-llsec-Link-layer-security" class="headerlink" title="5 llsec - Link layer security"></a>5 llsec - Link layer security</h1><p>驱动：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">llsec_driver</span> <span class="title">nullsec_driver</span> = &#123;</span></span><br><span class="line">  <span class="string">"nullsec"</span>,</span><br><span class="line">  init,</span><br><span class="line">  send,</span><br><span class="line">  input</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里没有用到该层功能，所以调用过程只做参数传递。
NETSTACK_LLSEC.send = nullsec_driver.send，而Send函数如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">send(<span class="keyword">mac_callback_t</span> sent, <span class="keyword">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//实际执行语句 packetbuf_attrs[type].val = val;</span></span><br><span class="line">  packetbuf_set_attr(PACKETBUF_ATTR_FRAME_TYPE, FRAME802154_DATAFRAME);</span><br><span class="line">  NETSTACK_MAC.send(sent, ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="6-Carrier-Sense-Multiple-Access-CSMA-MAC"><a href="#6-Carrier-Sense-Multiple-Access-CSMA-MAC" class="headerlink" title="6 Carrier Sense Multiple Access (CSMA) MAC"></a>6 Carrier Sense Multiple Access (CSMA) MAC</h1><p>驱动：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mac_driver</span> <span class="title">csma_driver</span> = &#123;</span></span><br><span class="line">  <span class="string">"CSMA"</span>,</span><br><span class="line">  init,</span><br><span class="line">  send_packet,</span><br><span class="line">  input_packet,</span><br><span class="line">  on,</span><br><span class="line">  off,</span><br><span class="line">  channel_check_interval,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>NETSTACK_MAC.send = csma_driver.send_packet  </p>
<h2 id="6-1-mac层send-packet函数解析"><a href="#6-1-mac层send-packet函数解析" class="headerlink" title="6.1 mac层send_packet函数解析"></a>6.1 mac层send_packet函数解析</h2><p>send_packet函数代码结构如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">send_packet(<span class="keyword">mac_callback_t</span> sent, <span class="keyword">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rdc_buf_list</span> *<span class="title">q</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">neighbor_queue</span> *<span class="title">n</span>;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">uint8_t</span> initialized = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">uint16_t</span> seqno;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">linkaddr_t</span> *addr = packetbuf_addr(PACKETBUF_ADDR_RECEIVER);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!initialized) &#123;</span><br><span class="line">    initialized = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Initialize the sequence number to a random value as per 802.15.4. */</span></span><br><span class="line">    seqno = random_rand();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(seqno == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* PACKETBUF_ATTR_MAC_SEQNO cannot be zero, due to a pecuilarity</span></span><br><span class="line"><span class="comment">       in framer-802154.c. */</span></span><br><span class="line">    seqno++;</span><br><span class="line">  &#125;</span><br><span class="line">  packetbuf_set_attr(PACKETBUF_ATTR_MAC_SEQNO, seqno++);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Look for the neighbor entry */</span></span><br><span class="line">  n = neighbor_queue_from_addr(addr);</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* Allocate a new neighbor entry */</span></span><br><span class="line">    n = memb_alloc(&amp;neighbor_memb);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(n != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* Add packet to the neighbor's queue */</span></span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    PRINTF(<span class="string">"csma: could not allocate neighbor, dropping packet\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mac_call_sent_callback(sent, ptr, MAC_TX_ERR, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>数据结构：<br>rdc_buf_list
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* List of packets to be sent by RDC layer */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rdc_buf_list</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rdc_buf_list</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queuebuf</span> *<span class="title">buf</span>;</span></span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>neighbor_queue
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Every neighbor has its own packet queue */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">neighbor_queue</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">neighbor_queue</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="keyword">linkaddr_t</span> addr;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ctimer</span> <span class="title">transmit_timer</span>;</span></span><br><span class="line">  <span class="keyword">uint8_t</span> transmissions;</span><br><span class="line">  <span class="keyword">uint8_t</span> collisions;</span><br><span class="line">  LIST_STRUCT(queued_packet_list);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  #define LIST_STRUCT(name) \</span></span><br><span class="line"><span class="comment">         void *LIST_CONCAT(name,_list); \</span></span><br><span class="line"><span class="comment">         list_t name </span></span><br><span class="line"><span class="comment">  typedef void ** list_t;</span></span><br><span class="line"><span class="comment">  ==&gt;</span></span><br><span class="line"><span class="comment">  LIST_STRUCT(queued_packet_list); = </span></span><br><span class="line"><span class="comment">  void *  queued_packet_list_list; </span></span><br><span class="line"><span class="comment">  void ** queued_packet_list;//这里等价与链表中的next*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>const linkaddr_t *addr = packetbuf_addr(PACKETBUF_ADDR_RECEIVER);</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> u8[LINKADDR_SIZE];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINKADDR_SIZE == 2</span></span><br><span class="line"><span class="keyword">uint16_t</span> u16;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* LINKADDR_SIZE == 2 */</span></span></span><br><span class="line">&#125; <span class="keyword">linkaddr_t</span>;</span><br></pre></td></tr></table></figure>
<p>  packetbuf_addr函数执行语句</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;packetbuf_addrs[type - PACKETBUF_ADDR_FIRST].addr;</span><br><span class="line"><span class="comment">//type = PACKETBUF_ADDR_RECEIVER</span></span><br><span class="line"><span class="comment">//#define PACKETBUF_ADDR_FIRST PACKETBUF_ADDR_SENDER</span></span><br><span class="line"><span class="comment">//PACKETBUF_ADDR_SENDER = PACKETBUF_ADDR_RECEIVER + 1</span></span><br><span class="line"><span class="comment">//这里等效为&amp;packetbuf_addrs[1].addr</span></span><br></pre></td></tr></table></figure>
<p>  packetbuf.c中定义</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packetbuf_addr</span> <span class="title">packetbuf_addrs</span>[<span class="title">PACKETBUF_NUM_ADDRS</span>];</span></span><br><span class="line"><span class="comment">//PACKETBUF_NUM_ADDRS = 4或2</span></span><br></pre></td></tr></table></figure>
<p>  这里是这样的</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packetbuf_addr</span> &#123;</span></span><br><span class="line"><span class="keyword">linkaddr_t</span> addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  也就是说有以linkaddr_t为内容的packetbuf_addr结构体数组packetbuf_addrs，经过赋值语句<code>const linkaddr_t *addr = packetbuf_addr(PACKETBUF_ADDR_RECEIVER);</code>将接收相关的地址赋值给addr。</p>
</li>
<li><p>LIST_STRUCT_INIT(n, queued_packet_list);</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_STRUCT_INIT(struct_ptr, name)                              \</span></span><br><span class="line"><span class="keyword">do</span> &#123;                                                                \</span><br><span class="line">   (struct_ptr)-&gt;name = &amp;((struct_ptr)-&gt;LIST_CONCAT(name,_list));   \</span><br><span class="line">   (struct_ptr)-&gt;LIST_CONCAT(name,_list) = <span class="literal">NULL</span>;                    \</span><br><span class="line">   list_init((struct_ptr)-&gt;name);                                   \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">list_init(<span class="keyword">list_t</span> <span class="built_in">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">*<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  ==&gt;</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n-&gt;queued_packet_list = &amp;(n-&gt;queued_packet_list_list); <span class="comment">//= next</span></span><br><span class="line">n-&gt;queued_packet_list_list = <span class="literal">NULL</span>;</span><br><span class="line">* n-&gt;queued_packet_list = NUL;</span><br></pre></td></tr></table></figure>
</li>
<li><p>packetbuf_set_attr(PACKETBUF_ATTR_MAC_SEQNO, seqno++);</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">packetbuf_set_attr(<span class="keyword">uint8_t</span> type, <span class="keyword">const</span> <span class="keyword">packetbuf_attr_t</span> val)</span><br><span class="line">&#123;</span><br><span class="line">packetbuf_attrs[type].val = val;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packetbuf_attr</span> <span class="title">packetbuf_attrs</span>[<span class="title">PACKETBUF_NUM_ATTRS</span>];</span></span><br></pre></td></tr></table></figure>
<p>  这些是对数组中变量的更新。</p>
</li>
<li><p>neighbor
  一个设备周围的能与其通信的设备都称作邻居/临近节点。设备用链表方式记录其邻居信息，链表的数据结构如下：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Every neighbor has its own packet queue */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">neighbor_queue</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">neighbor_queue</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">linkaddr_t</span> addr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ctimer</span> <span class="title">transmit_timer</span>;</span></span><br><span class="line"><span class="keyword">uint8_t</span> transmissions;</span><br><span class="line"><span class="keyword">uint8_t</span> collisions;</span><br><span class="line">LIST_STRUCT(queued_packet_list);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  还定义了一个链表查找函数<code>neighbor_queue_from_addr</code>,应用示例：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Look for the neighbor entry */</span></span><br><span class="line">n = neighbor_queue_from_addr(addr); <span class="comment">//----&gt;</span></span><br></pre></td></tr></table></figure>
<p>  如果邻居链表中有addr的节点则将其在链表中的位置返回，如果没有则返回NULL。同时后面的语句会根据这n值进行处理，如果为NULL则新建(memb_alloc)一个邻居节点，将addr赋值给新建的邻居节点，然后将该节点添加到邻居链表中。之后是给这个邻居分配内存空间，执行数据发送。</p>
</li>
<li><p>packet_memb
  定义<code>MEMB(packet_memb, struct rdc_buf_list, MAX_QUEUED_PACKETS);</code>语句<code>q = memb_alloc(&amp;packet_memb);</code>进行分配，然后将待发送数据地址放入邻居节点的rdc_buf_list中。<br>  其中</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* List of packets to be sent by RDC layer */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rdc_buf_list</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rdc_buf_list</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queuebuf</span> *<span class="title">buf</span>;</span></span><br><span class="line"><span class="keyword">void</span> *ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  内存分配：  </p>
<ul>
<li>q-&gt;ptr = memb_alloc(&amp;metadata_memb);  </li>
<li>q-&gt;buf = queuebuf_new_from_packetbuf();
分配内存赋值：</li>
<li>struct qbuf_metadata <em>metadata = (struct qbuf_metadata </em>)q-&gt;ptr;</li>
<li>metadata-&gt;max_transmissions = CSMA_MAX_MAX_FRAME_RETRIES + 1;</li>
<li>metadata-&gt;sent = sent;</li>
<li>metadata-&gt;cptr = ptr; //—-&gt;</li>
</ul>
</li>
<li><p>schedule_transmission</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list_add(n-&gt;queued_packet_list, q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(list_head(n-&gt;queued_packet_list) == q) &#123;</span><br><span class="line">              schedule_transmission(n);<span class="comment">//----&gt;</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">schedule_transmission(struct neighbor_queue *n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">clock_time_t</span> delay;</span><br><span class="line">  <span class="keyword">int</span> backoff_exponent; <span class="comment">/* BE in IEEE 802.15.4 */</span></span><br><span class="line"></span><br><span class="line">  backoff_exponent = MIN(n-&gt;collisions, CSMA_MAX_BE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute max delay as per IEEE 802.15.4: 2^BE-1 backoff periods  */</span></span><br><span class="line">  delay = ((<span class="number">1</span> &lt;&lt; backoff_exponent) - <span class="number">1</span>) * backoff_period();</span><br><span class="line">  <span class="keyword">if</span>(delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* Pick a time for next transmission */</span></span><br><span class="line">    delay = random_rand() % delay;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  PRINTF(<span class="string">"csma: scheduling transmission in %u ticks, NB=%u, BE=%u\n"</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span>)delay, n-&gt;collisions, backoff_exponent);</span><br><span class="line">  ctimer_set(&amp;n-&gt;transmit_timer, delay, transmit_packet_list, n); <span class="comment">//----&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>transmit_packet_list</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">transmit_packet_list(<span class="keyword">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">neighbor_queue</span> *<span class="title">n</span> = <span class="title">ptr</span>;</span></span><br><span class="line">  <span class="keyword">if</span>(n) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rdc_buf_list</span> *<span class="title">q</span> = <span class="title">list_head</span>(<span class="title">n</span>-&gt;<span class="title">queued_packet_list</span>);</span></span><br><span class="line">    <span class="keyword">if</span>(q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      PRINTF(<span class="string">"csma: preparing number %d %p, queue len %d\n"</span>, n-&gt;transmissions, q,</span><br><span class="line">          list_length(n-&gt;queued_packet_list));</span><br><span class="line">      <span class="comment">/* Send packets in the neighbor's list */</span></span><br><span class="line">      NETSTACK_RDC.send_list(packet_sent, n, q); <span class="comment">//----&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="7-queuebuf"><a href="#7-queuebuf" class="headerlink" title="7  queuebuf"></a>7  queuebuf</h1><p>默认的queuebuf数量是8，自定义数量少于8则使用swap，并使用ram of cfs，如果大于等于8则不使用swap。<br>数据结构、申请内存空间、接口函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ignore the debug and swap variable */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queuebuf</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">queuebuf_data</span> *<span class="title">ram_ptr</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The actual queuebuf data */</span></span><br><span class="line"><span class="comment">// PACKETBUF_SIZE = 128</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queuebuf_data</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint8_t</span> data[PACKETBUF_SIZE];</span><br><span class="line">  <span class="keyword">uint16_t</span> len;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">packetbuf_attr</span> <span class="title">attrs</span>[<span class="title">PACKETBUF_NUM_ATTRS</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">packetbuf_addr</span> <span class="title">addrs</span>[<span class="title">PACKETBUF_NUM_ADDRS</span>];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Memory</span></span><br><span class="line"><span class="comment">// QUEUEBUF_NUM = 8, 可自定义</span></span><br><span class="line"><span class="comment">// QUEUEBUFRAM_NUM = 8， 根据QUEUEBUF_NUM变化</span></span><br><span class="line">MEMB(bufmem, struct queuebuf, QUEUEBUF_NUM); <span class="comment">//声明指针空间</span></span><br><span class="line">MEMB(buframmem, struct queuebuf_data, QUEUEBUFRAM_NUM); <span class="comment">//声明数据空间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queuebuf_init</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//bufmem、 buframmem init</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从bufmem、 buframmem中获取1个元素</span></span><br><span class="line"><span class="function">struct queuebuf *<span class="title">queuebuf_new_from_packetbuf</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 将b中的attrs和addrs复制到packetbuf.c中定义的attrs、addrs数组中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queuebuf_update_attr_from_packetbuf</span><span class="params">(struct queuebuf *b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 将b中的attrs和addrs复制到packetbuf.c中定义的attrs、addrs数组中</span></span><br><span class="line"><span class="comment">// 2. 将packetbuf.c中定义packetbuf中的数据复制到b中的data中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queuebuf_update_from_packetbuf</span><span class="params">(struct queuebuf *b)</span></span>;</span><br><span class="line"><span class="comment">// 与上一语句功能相反</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queuebuf_to_packetbuf</span><span class="params">(struct queuebuf *b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放b占用的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queuebuf_free</span><span class="params">(struct queuebuf *b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回b中data数组地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">queuebuf_dataptr</span><span class="params">(struct queuebuf *b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回b中data数组内有效数据长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queuebuf_datalen</span><span class="params">(struct queuebuf *b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取type类型在addrs数组中的内容</span></span><br><span class="line"><span class="keyword">linkaddr_t</span> *queuebuf_addr(struct queuebuf *b, <span class="keyword">uint8_t</span> type);</span><br><span class="line"><span class="comment">// 读取type参数在attrs中的内容</span></span><br><span class="line"><span class="keyword">packetbuf_attr_t</span> queuebuf_attr(struct queuebuf *b, <span class="keyword">uint8_t</span> type);</span><br><span class="line"><span class="comment">// 打印queuebuf_list信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queuebuf_debug_print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放bufmem内存</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queuebuf_numfree</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="8-RDC层"><a href="#8-RDC层" class="headerlink" title="8 RDC层"></a>8 RDC层</h1><p>驱动与数据结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* List of packets to be sent by RDC layer */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rdc_buf_list</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rdc_buf_list</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queuebuf</span> *<span class="title">buf</span>;</span></span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The structure of a RDC (radio duty cycling) driver in Contiki.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rdc_driver</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Initialize the RDC driver */</span></span><br><span class="line">  <span class="keyword">void</span> (* init)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Send a packet from the Rime buffer  */</span></span><br><span class="line">  <span class="keyword">void</span> (* send)(<span class="keyword">mac_callback_t</span> sent_callback, <span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Send a packet list */</span></span><br><span class="line">  <span class="keyword">void</span> (* send_list)(<span class="keyword">mac_callback_t</span> sent_callback, <span class="keyword">void</span> *ptr, struct rdc_buf_list *<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Callback for getting notified of incoming packet. */</span></span><br><span class="line">  <span class="keyword">void</span> (* input)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Turn the MAC layer on. */</span></span><br><span class="line">  <span class="keyword">int</span> (* on)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Turn the MAC layer off. */</span></span><br><span class="line">  <span class="keyword">int</span> (* off)(<span class="keyword">int</span> keep_radio_on);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Returns the channel check interval, expressed in clock_time_t ticks. */</span></span><br><span class="line">  <span class="function"><span class="keyword">unsigned</span> <span class="title">short</span> <span class="params">(* channel_check_interval)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>驱动分别在两个文件中都有定义nordc.c和nullrdc.h，其中nordc中的驱动函数均是空函数。所以来分析nullrdc中的函数，驱动如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in nullrdc.c</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rdc_driver</span> <span class="title">nullrdc_driver</span> = &#123;</span></span><br><span class="line">  <span class="string">"nullrdc"</span>,</span><br><span class="line">  init,</span><br><span class="line">  send_packet,</span><br><span class="line">  send_list,</span><br><span class="line">  packet_input,</span><br><span class="line">  on,</span><br><span class="line">  off,</span><br><span class="line">  channel_check_interval,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="8-1-send-list"><a href="#8-1-send-list" class="headerlink" title="8.1 send_list"></a>8.1 send_list</h2><p>send_list函数比较简单函数体如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NETSTACK_RDC.send_list(packet_sent, n, q); //----&gt;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">send_list(<span class="keyword">mac_callback_t</span> sent, <span class="keyword">void</span> *ptr, struct rdc_buf_list *buf_list)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(buf_list != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* We backup the next pointer, as it may be nullified by</span></span><br><span class="line"><span class="comment">     * mac_call_sent_callback() */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rdc_buf_list</span> *<span class="title">next</span> = <span class="title">buf_list</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> last_sent_ok;</span><br><span class="line"></span><br><span class="line">    queuebuf_to_packetbuf(buf_list-&gt;buf); <span class="comment">//data数组复制到packetbuf数组中</span></span><br><span class="line">    last_sent_ok = send_one_packet(sent, ptr); <span class="comment">//----&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If packet transmission was not successful, we should back off and let</span></span><br><span class="line"><span class="comment">     * upper layers retransmit, rather than potentially sending out-of-order</span></span><br><span class="line"><span class="comment">     * packet fragments. */</span></span><br><span class="line">    <span class="keyword">if</span>(!last_sent_ok) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf_list = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="8-2-send-one-packet"><a href="#8-2-send-one-packet" class="headerlink" title="8.2 send_one_packet"></a>8.2 send_one_packet</h2><p>该函数实现了封包和发送两件事； </p>
<ul>
<li>NETSTACK_FRAME.create完成组包 </li>
<li>NETSTACK_RADIO.prepare将数据从packetbuf搬移到ieee-mode.c中定义的tx_buf</li>
<li>NETSTACK_RADIO.send完成发送</li>
</ul>
<h2 id="8-3-NETSTACK-FRAME-create"><a href="#8-3-NETSTACK-FRAME-create" class="headerlink" title="8.3 NETSTACK_FRAME.create"></a>8.3 NETSTACK_FRAME.create</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETSTACK_FRAME framer_802154</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">framer</span> <span class="title">framer_802154</span> = &#123;</span></span><br><span class="line">  hdr_length,</span><br><span class="line">  create,</span><br><span class="line">  parse</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>执行create后会完成如下数据结构的内容：<br>fcf = Frame control field 帧控制
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="comment">/* The fields dest_addr and src_addr must come first to ensure they are aligned to the</span></span><br><span class="line"><span class="comment">   * CPU word size. Needed as they are accessed directly as linkaddr_t*. Note we cannot use</span></span><br><span class="line"><span class="comment">   * the type linkaddr_t directly here, as we always need 8 bytes, not LINKADDR_SIZE bytes. */</span></span><br><span class="line">  <span class="keyword">uint8_t</span> dest_addr[<span class="number">8</span>];           <span class="comment">/**&lt; Destination address */</span></span><br><span class="line">  <span class="keyword">uint8_t</span> src_addr[<span class="number">8</span>];            <span class="comment">/**&lt; Source address */</span></span><br><span class="line">  <span class="keyword">frame802154_fcf_t</span> fcf;          <span class="comment">/**&lt; Frame control field  */</span></span><br><span class="line">  <span class="keyword">uint8_t</span> seq;                    <span class="comment">/**&lt; Sequence number */</span></span><br><span class="line">  <span class="keyword">uint16_t</span> dest_pid;              <span class="comment">/**&lt; Destination PAN ID */</span></span><br><span class="line">  <span class="keyword">uint16_t</span> src_pid;               <span class="comment">/**&lt; Source PAN ID */</span></span><br><span class="line">  <span class="keyword">frame802154_aux_hdr_t</span> aux_hdr;  <span class="comment">/**&lt; Aux security header */</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *payload;               <span class="comment">/**&lt; Pointer to 802.15.4 payload */</span></span><br><span class="line">  <span class="keyword">int</span> payload_len;                <span class="comment">/**&lt; Length of payload field */</span></span><br><span class="line">&#125; <span class="keyword">frame802154_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint8_t</span> frame_type;        <span class="comment">/**&lt; 3 bit. Frame type field, see 802.15.4 */</span></span><br><span class="line">  <span class="keyword">uint8_t</span> security_enabled;  <span class="comment">/**&lt; 1 bit. True if security is used in this frame */</span></span><br><span class="line">  <span class="keyword">uint8_t</span> frame_pending;     <span class="comment">/**&lt; 1 bit. True if sender has more data to send */</span></span><br><span class="line">  <span class="keyword">uint8_t</span> ack_required;      <span class="comment">/**&lt; 1 bit. Is an ack frame required? */</span></span><br><span class="line">  <span class="keyword">uint8_t</span> panid_compression; <span class="comment">/**&lt; 1 bit. Is this a compressed header? */</span></span><br><span class="line">  <span class="comment">/*   uint8_t reserved; */</span>  <span class="comment">/**&lt; 1 bit. Unused bit */</span></span><br><span class="line">  <span class="keyword">uint8_t</span> sequence_number_suppression; <span class="comment">/**&lt; 1 bit. Does the header omit sequence number?, see 802.15.4e */</span></span><br><span class="line">  <span class="keyword">uint8_t</span> ie_list_present;   <span class="comment">/**&lt; 1 bit. Does the header contain Information Elements?, see 802.15.4e */</span></span><br><span class="line">  <span class="keyword">uint8_t</span> dest_addr_mode;    <span class="comment">/**&lt; 2 bit. Destination address mode, see 802.15.4 */</span></span><br><span class="line">  <span class="keyword">uint8_t</span> frame_version;     <span class="comment">/**&lt; 2 bit. 802.15.4 frame version */</span></span><br><span class="line">  <span class="keyword">uint8_t</span> src_addr_mode;     <span class="comment">/**&lt; 2 bit. Source address mode, see 802.15.4 */</span></span><br><span class="line">&#125; <span class="keyword">frame802154_fcf_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** \brief 802.15.4 Aux security header */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">frame802154_scf_t</span> security_control;        <span class="comment">/**&lt; Security control bitfield */</span></span><br><span class="line">  <span class="keyword">frame802154_frame_counter_t</span> frame_counter; <span class="comment">/**&lt; Frame counter, used for security */</span></span><br><span class="line">  <span class="keyword">frame802154_key_source_t</span> key_source;       <span class="comment">/**&lt; Key Source subfield */</span></span><br><span class="line">  <span class="keyword">uint8_t</span> key_index;                         <span class="comment">/**&lt; Key Index subfield */</span></span><br><span class="line">&#125; <span class="keyword">frame802154_aux_hdr_t</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="8-4-NETSTACK-RADIO-send"><a href="#8-4-NETSTACK-RADIO-send" class="headerlink" title="8.4 NETSTACK_RADIO.send"></a>8.4 NETSTACK_RADIO.send</h2>]]></content>
      
        <categories>
            
            <category> Contiki </category>
            
            <category> Rime </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Contiki </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Doxygen 简介]]></title>
      <url>https://xubovey.github.io/2016/10/28/161028-doxygen-brief/</url>
      <content type="html"><![CDATA[<p>再也不用担心软件写文档麻烦了，再也不用担心软件文档写着麻烦了。之前见到过doxygen这个东西，只是没留意，昨天研究Contiki的时候发现了这个<a href="http://dak664.github.io/contiki-doxygen/" target="_blank" rel="noopener">contiki说明</a>，就搜了下原来正式自动文档生成工具。那还不迅速研究下….</p>
<a id="more"></a>
<p>首先是这个工具是做什么用的：</p>
<blockquote>
<p>Doxygen是一种开源跨平台的，以类似JavaDoc风格描述的文档系统，完全支持C、C++、Java、Objective-C和IDL语言，部分支持PHP、C#。注释的语法与Qt-Doc、KDoc和JavaDoc兼容。Doxygen可以从一套归档源文件开始，生成HTML格式的在线类浏览器，或离线的LATEX、RTF参考手册。  </p>
</blockquote>
<p>这里说的RTF文件是可以用world打开的哦。</p>
<h1 id="不同平台的安装"><a href="#不同平台的安装" class="headerlink" title="不同平台的安装"></a>不同平台的安装</h1><p>这里没有，请移步<a href="http://www.stack.nl/~dimitri/doxygen/download.html" target="_blank" rel="noopener">Downloads</a><br><a href="http://blog.csdn.net/blood008/article/details/6567169" target="_blank" rel="noopener">linux doxygen 的安装和使用</a></p>
<h1 id="C语言注释规范"><a href="#C语言注释规范" class="headerlink" title="C语言注释规范"></a>C语言注释规范</h1><p><a href="http://www.stack.nl/~dimitri/doxygen/manual/docblocks.html#cppblock" target="_blank" rel="noopener">参考官方说明</a><br>首先需要想清楚代码中需要哪些注释，软件说明文档要对软件进行哪些介绍。</p>
<ul>
<li>包含哪些函数，这些函数的功能介绍，入口参数，出口参数介绍；</li>
<li>包含哪些数据结构，数据结构的介绍，以及详细说明；</li>
<li>特殊变量的说明；</li>
<li>函数调用关系说明</li>
<li>…</li>
</ul>
<p>理想是很丰满的，现实也很赞的。
这些都能实现：</p>
<h2 id="c代码注释规则"><a href="#c代码注释规则" class="headerlink" title="c代码注释规则"></a>c代码注释规则</h2><p>其实这里不该说是c代码的规则，应当说是c类代码：包含C/C++/C#/Objective-C/PHP/Java。注释中包含<code>brief</code>做简单介绍，可以针对函数、数据结构、变量；注释中包含<code>detailed</code>做详细介绍，可以针对函数、数据结构、变量。</p>
<ul>
<li>brief 简单介绍，建议简短，要惜字如金；</li>
<li>detailed 详细介绍，要对描述对象做足够充分的介绍。</li>
</ul>
<p>对brief和detailed的描述格式有很多种，这里只说明并采用JavaDoc格式的，可以参考<a href="http://blog.csdn.net/yongping8204/article/details/1796667" target="_blank" rel="noopener">Javadoc 的书写格式和javadoc命令的使用</a>：</p>
<ul>
<li>brief<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief It is a brief</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意这里一开始是2个<code>*</code>，如果是1个就是普通注释，不会出现在文档里。</p>
<ul>
<li><p>detailed</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ... text ...</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>brief、param、detailed
如果是一个包含参数的函数呢，有简介，参数说明，详细说明，举了例子吧：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief Set the device name to use with the BLE advertisement/beacon daemon</span></span><br><span class="line"><span class="comment"> * \param interval The interval (ticks) between two consecutive beacon bursts</span></span><br><span class="line"><span class="comment"> * \param name The device name to advertise</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If name is NULL it will be ignored. If interval==0 it will be ignored. Thus,</span></span><br><span class="line"><span class="comment"> * this function can be used to configure a single parameter at a time if so</span></span><br><span class="line"><span class="comment"> * desired.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rf_ble_beacond_config</span><span class="params">(<span class="keyword">clock_time_t</span> interval, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里If name…是详细说明部分，它上面有个空行。这个是必须的。</p>
<ul>
<li>变量后的注释
在struct, union, class, or enum的注释中，有可能注释出现在代码后面。怎么做呢：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var; <span class="comment">/**&lt; Detailed description after the member */</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>*&lt;</code>注意这里有个空格的。</p>
<h2 id="标记示例"><a href="#标记示例" class="headerlink" title="标记示例"></a>标记示例</h2><p><a href="https://www.ibm.com/developerworks/cn/aix/library/au-learningdoxygen/" target="_blank" rel="noopener">转载</a></p>
<blockquote>
<p>体内描述：类、结构、联合体和名称空间等 C++ 元素都有自己的标记。比如&lt;\class&gt;、&lt;\struct&gt;、&lt;\union&gt; 和 &lt;\namespace&gt;。
示例包含用于四种元素的标记：函数标记（&lt;\fn&gt;）、函数参数标记（&lt;\param&gt;）、变量名标记（&lt;\var&gt;）、用于 #define 的标记（&lt;\def&gt;）以及用来表示与一个代码片段相关的问题的标记（&lt;\warning&gt;）。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \file globaldecls.h</span></span><br><span class="line"><span class="comment">      \brief Place to look for global variables, enums, functions</span></span><br><span class="line"><span class="comment">           and macro definitions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** \var const int fileSize</span></span><br><span class="line"><span class="comment">      \brief Default size of the file on disk</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> fileSize = <span class="number">1048576</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** \def SHIFT(value, length)</span></span><br><span class="line"><span class="comment">      \brief Left shift value by length in bits</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHIFT(value, length) ((value) &lt;&lt; (length))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** \fn bool check_for_io_errors(FILE* fp)</span></span><br><span class="line"><span class="comment">      \brief Checks if a file is corrupted or not</span></span><br><span class="line"><span class="comment">      \param fp Pointer to an already opened file</span></span><br><span class="line"><span class="comment">      \warning Not thread safe!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_for_io_errors</span><span class="params">(FILE* fp)</span></span>;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>doxygen的输出：</p>
<p><img src="http://oefaano2o.bkt.clouddn.com/blogimages/images/161102-doxygen-example.jpg-blog" alt=""></p>
<p>这里其实是doxygen对注释部分进行了解析，得到以上内容。</p>
<h1 id="函数调用关系导出"><a href="#函数调用关系导出" class="headerlink" title="函数调用关系导出"></a>函数调用关系导出</h1><p><a href="http://www.jianshu.com/p/f67ec1879fca" target="_blank" rel="noopener">如何使用doxygen+ graphviz</a></p>
]]></content>
      
        <categories>
            
            <category> Doxygen </category>
            
            <category> Doc </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Doxygen </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[转载-Contiki简介]]></title>
      <url>https://xubovey.github.io/2016/10/27/161027-ContikiBrief/</url>
      <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000003850974" target="_blank" rel="noopener">转载</a>
注：文章转自他处，未找到原创作者，有不妥之处请原创作者联系笔者。</p>
<blockquote>
<p>本文介绍了 Contiki 是什么、contiki 的特点、Contiki 事件驱动(Event-driven) 编程模型、contiki 包含的无线网络协议栈 6Lowpan/RPL/Coap、仿真工具 Cooja/MSPsim、文件系统 Coffee File system(CFS)、shell 命令工具等,指出了Contiki 的应用领域。最后给出了 Contiki 相关网站、教程和代码等。</p>
</blockquote>
<a id="more"></a>
<h1 id="Contiki操作系统介绍"><a href="#Contiki操作系统介绍" class="headerlink" title="Contiki操作系统介绍"></a>Contiki操作系统介绍</h1><p>Contiki 是一个开源的、高度可移植的多任务操作系统,适用于联网嵌入式系统和无线传感器网络,由瑞典计算机科学学院(Swedish Institute of Computer Science)的 Adam Dunkels 和他的团队开发。Contiki 完全采用 C 语言开发,可移植性非常好,对硬件的要求极低,能够运行在各种类型的微处理器及电脑上,目前已经移植到 8051 单片机、MSP430、AVR、ARM、PC机等硬件平台上。Contiki 适用于存储器资源十分受限的嵌入式单片机系统,典型的配置下Contiki只占用 约 2Kbytes 的 RAM 以及 40Kbytes 的 Flash 存储器。Contiki是开源的操作系统,适用于 BSD 协议,即可以任意修改和发布,无需任何版权费用,因此已经应用在许多项目中。</p>
<p>Contiki 操作系统是基于事件驱动(Event-driven)内核的操作系统,在此内核上,应用程序可以在运行时动态加载,非常灵活。在事件驱动内核基础上, Contiki 实现了一种轻量级的名为 protothread 的线程模型,来实现线性的、类似于线程的编程风格。该模型类似于 Linux 和 windows 中线程的概念,多个线程共享同一个任务栈,从而减少 RAM 占用。Contiki 还提供一种可选的任务抢占机制、 基于事件和消息传递的进程间通信机制。Contiki 中还包括一个可选的 GUI 子系统,可以提供对本地串口终端、基于 VNC 的网络化虚拟显示或者 Telnet 的图形化支持。</p>
<p>Contiki 系统内部集成了两种类型的无线传感器网络协议栈:uIP 和 Rime。 uIP 是一个小型的符合 RFC 规范的 TCP/IP 协议栈,使得 contiki 可以直接和 Internet 通信。uIP 包含了 IPv4 和 IPv6 两种协议栈版本,支持 TCP、UDP、ICMP 等协议,但是编译时只能二选一,不可以同时使用。Rime 是一个轻量级为低功耗无线传感器网络设计的协议栈,该协议栈提供了大量的通信原语,能够实现从简单的一跳广播通信,到复杂的可靠多跳数据传输等通信功能。</p>
<h1 id="Contiki操作系统特点"><a href="#Contiki操作系统特点" class="headerlink" title="Contiki操作系统特点"></a>Contiki操作系统特点</h1><ul>
<li><p>事件驱动(Event-driven)的多任务内核<br>  Contiki 基于事件驱动模型,即多个任务共享同一个栈(stack),而不是每个任务分别占用独立的栈(如 uCOS、FreeRTOS、Linux 等)。Contiki 每个任务只占用几个字节的 RAM,可以大大节省 RAM 空间,更适合节点资源十分受限的 无线传感器网络应用。</p>
</li>
<li><p>低功耗无线传感器网络协议栈<br>  Contiki 提供完整的 IP 网络和低功耗无线网络协议栈。对于 IP 协议栈,支持 IPv4 和 IPv6 两个版本,IPv6 还包括 6Lowpan 帧头压缩适配器,ROLL RPL 无线网络组网路由协议、CoRE/CoAP 应用层协议,还包括一些简化的 Web 工具, 包括 Telnet、http 和 web 服务等。Contiki 还实现了无线传感器网络领域知名的 MAC 和路由层协议,其中 MAC 层包括 X-MAC、CX-MAC、ContikiMAC、 CSMA-CA、LPP 等,路由层包括 AODV、RPL 等。</p>
</li>
<li><p>集成无线传感器网络仿真工具<br>  Contiki 提供了 Cooja 无线传感器网络仿真工具,能够多对协议在电脑上进行仿真,仿真通过后才下载到节点上进行实际测试,有利于发现问题,减少调试工作量。除此之外,Contiki 还提供 MSPsim 仿真工具,能够对 MSP430 微处理器进行指令级模拟和仿真。仿真工具对于科研、算法和协议验证、工程实施规划、 网络优化等很有帮助。</p>
</li>
<li><p>集成 Shell 命令行调试工具<br>  无线传感器网络中节点数量多,节点的运行维护是一个难题,contiki 可以通过多种交互方式,如 Web 浏览器,基于文本的命令行接口,或者存储和显示传感器数据的专用程序等。基于文本的命令行接口是类似于 Unix 命令行的 Shell 工具,用户通过串口输入命令可以查看和配置传感器节点的信息、控制其运行状态,是部署、维护中实用而有效的工具。</p>
</li>
<li><p>基于Flash的小型文件系统:CoffeeFileSystem<br>  Contiki 实现了一个简单、小巧、易于使用的文件系统,称为 Coffee File System (CFS),它是基于 Flash 的文件系统,用于在资源受限的的节点上存储数据和程 序。CFS 是充分传感器网络数据采集、数据传输需求以及硬件资源受限的特点而设计的,因此在耗损平衡、坏块管理、掉电保护方面、垃圾回收、映射机制方等方面进行优化,具有使用的存储空间少、支持大规模存储的特点。CFS 的编程方法与常用的 C 语言编程类似,提供 open、read、write、close 等函数,易于使用。</p>
</li>
<li><p>集成功耗分析工具<br>  为了延长传感器网络的生命周期,控制和减少传感器节点的功耗至关总重要,无线传感器网络领域提出的许多网络协议都围绕降低功耗而展开。为了评估 网络协议以及算法能耗性能,需要测量出每个节点的能量消耗,由于节点数量多, 使用仪器测试几乎不可行。Contiki 提供了一种基于软件的能量分析工具,自动记录每个传感器节点的工作状态、时间,并计算出能量消耗,在不需要额外的硬 件或仪器的情况下就能完成网络级别的能量分析。Contiki 的能量分析机制既可用于评价传感器网络协议,也可用于估算传感器网络的生命周期。</p>
</li>
<li><p>开源免费<br>  Contiki 采用 BSD 授权协议,用户可以下载代码,用户科研和商业,且可以任意修改代码,无需任何专利以及版权费用,是彻底的开源软件。尽管是开源软 件,但是 contiki 开发十分活跃,在持续不断更新和改进之中。Contiki 的作者 Adam 是一个编程的天才,它发明了 LwIP、uIP、Protothred、contiki 等软件,都在工 业界得到广泛应用,大家熟知的 LwIP 就是一个例子。Adam 还是 IPSO 组织的发起人之一,未来将会不断推进 6Lowpan 的标准化及应用。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Contiki 完全 C 语言开发、易于移植、支持大量的硬件平台和开发工具、事件驱动机制占用内存小、集成了多种无线传感器网络协议、无专利和版权费、集成仿真工具等特点和优势,已经成为无线传感器网络学术研究和产品开发的理想平台,在欧洲已经得到广泛应用,并逐渐得到其它地区开发人员的支持。随着物联网、无线传感器网络的发展,IP 地址将耗尽,骨干网络必将升级到 IPv6,因 此 6Lowpan 标准被越来越多的标准化组织所采纳,研发 6lowpan 的人员将越来越多,这将使得 contiki 很可能成为嵌入系统中的 Linux,在物联网领域得到广泛应用,发挥重要作用。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.contiki-os.org/" target="_blank" rel="noopener">Contiki 官方网站</a>
<a href="http://www.sics.se/contiki/wiki" target="_blank" rel="noopener">Contiki Wiki</a>
<a href="https://segmentfault.com/a/1190000003850974" target="_blank" rel="noopener">Instant Contiki 开发环境</a>
<a href="http://www.iotdev.net/" target="_blank" rel="noopener">物联网开发论坛</a>
<a href="http://dak664.github.io/contiki-doxygen/" target="_blank" rel="noopener">Contiki 源代码文档</a>
<a href="http://sourceforge.net/projects/contiki/files/Contiki/" target="_blank" rel="noopener">Contiki 代码下载</a>
或者使用Git 工具下载 contiki 代码:
<code>git clone git://contiki.git.sourceforge.net/gitroot/contiki/contiki</code></p>
<h1 id="附加-代码模块说明："><a href="#附加-代码模块说明：" class="headerlink" title="附加-代码模块说明："></a>附加-代码模块说明：</h1><ul>
<li>contiki/Makefile.include：
  通过Contiki构建系统，应用程序可以很容易地编译至任意目标平台，在不同的平台上使用应用程序非常简单。没有硬件设备？不要紧，用Cooja可以模拟任何支持的硬件设备！</li>
<li>contiki/core/loader/：
  Contiki 支持运行时的模块动态装载和链接。当应用程序需要在部署后改变自身行为时，这项特性非常有用。Contiki 的模块装载器能够对标准ELF文件进行装载、重新分配和链接。用于装载的ELF文件需要能够移除调试符号以减小文件大小。</li>
<li>contiki/core/lib/{memb,mmem}.[ch]：
  Contiki 是为只有KB级别内存的微型系统设计的，因此在内存使用上极为高效，同时提供了一套内存分配机制：内存块分配memb，托管内存分配函数memm，和标准C内存分配函数malloc</li>
<li>contiki/core/net/：
  Contiki 提供了完整的IP网络栈，包含UDP、TCP、HTTP等标准IP协议，还包含新的低功耗协议，如6LoWPAN、RPL、CoAP等。Cisco开发并 贡献的Contiki IPv6协议栈完全通过了IPv6 Ready Logo program认证。</li>
<li>contiki/core/net/rpl/和contiki/apps/erbium/：
  Contiki 支持IETF最新为低功耗IPv6网络制定的标准协议，包括6LoWPAN适配层、RPL多跳路由协议和REST风格的CoAP应用层协议等</li>
<li>contiki/core/net/mac/：
  在无线网络中，节点可能需要作为中继替其他节点传输消息。在Contiki中，中继节点（路由节点）也可以用电池驱动。Contiki采用的ContikiMac射频duty-cycling机制允许路由节点在中继间隙中进行休眠。</li>
<li>contiki/core/cfs/cfs-coffee.[ch]：
  Contiki为具有外部Flash存储的设备提供了一种名为Coffee的轻量级文件系统。应用程序不需要了解Flash扇区的底层操作就可以对外部 Flash中的文件进行打开、关闭、读取、写入、追加等操作。Coffee文件系统的效率能够达到原生Flash存储操作的95%。</li>
<li>contiki/apps/shell/：
  Contiki提供了一个可选的控制台和一套用于Contiki开发与调试的常用命令，并且支持类似Unix的管道功能。开发者也可以添加自定义命令。</li>
<li>contiki/core/net/rime/：
  对于带宽有限或者不能运行完整IPv6网络栈的环境，Contiki定制了名为Rime的无线网络栈。Rime栈既支持简单操作，例如向所有邻居或指定邻居节点发送消息，也支持一些复杂机制，例如网络洪泛、多跳数据采集等。Rime可以运行在休眠路由上以降低功耗。</li>
<li>contiki/core/sys/pt.h：
  Contiki采用了一种称为Protothreads的机制，提供良好的控制流的同时可以节省内存。Protothreads混合了事件驱动模型与多线程模型。在Protothreads中，事件处理过程可以阻塞等待特定事件的发生。</li>
<li>contiki/platform/和contiki/cpu/：
  Contiki支持多种微型平台，包括8051、MSP430、AVR以及许多ARM设备，还有其他一些平台。</li>
<li>contiki/sys/energest.[ch]：
  Contiki 的设计目的是在极端低功耗的系统中运行，这些系统甚至可能需要只用一对AA电池能够工作许多年。Contiki 为辅助这些低功耗系统的开发提供了功耗估计和功耗分析机制。</li>
<li>contiki/regression-tests/：
  为了确保Contiki正确工作，Contiki开发者们采用了一套每日回归测试，每天在Cooja模拟器中对Contiki的重要部分进行测试。回归测试脚本可以作为使用模拟环境的起点，也可以用于了解Contiki机制有哪些不同。</li>
<li>contiki/examples/：
  Contiki 源码树中有足够多的示例，包括如何进行网络编程、如何操作硬件设备等，展示了 Contiki 系统的方方面面。多数示例有相应的 Cooja 模拟环境。这些示例能够帮助开发者开始快速地开发自己的应用程序。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Contiki </category>
            
            <category> 转载 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Contiki </tag>
            
            <tag> 简介 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Contiki中cc26xx之LPM]]></title>
      <url>https://xubovey.github.io/2016/10/26/161026-Contiki-cc26xx-LPM/</url>
      <content type="html"><![CDATA[<p>LPM: Low-Power management<br>在Contiki中只有CC26XX和CC2538有该特性。  </p>
<p>WUC: Wake-Up Control；
AON: Alway ON;
PRCM: Power and clock management 
PW: Power Down</p>
<p>lpm的使用分析同样按main函数中的主线进行，不过有了前面的分析，会有一些表面上看不到的思路，例如main函数中没有直接调用，而是在其调用的子函数中有相关代码。实际分析是ieee-mode.c的init函数被main函数经netstack_init函数调用。关系如下：<br>main-&gt;netstack_init-&gt;init-&gt;lpm_register_module(&amp;cc26xx_rf_lpm_module);</p>
<a id="more"></a>
<p>先包含main函数中的其它lpm相关代码和上面这个进行一个整合：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    lpm_init();</span><br><span class="line">    ...</span><br><span class="line">    lpm_register_module(&amp;cc26xx_rf_lpm_module);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Drop to some low power mode */</span></span><br><span class="line">    lpm_drop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="0-lpm-API函数"><a href="#0-lpm-API函数" class="headerlink" title="0. lpm API函数"></a>0. lpm API函数</h1><ul>
<li>void lpm_drop(void); //释放CPU，调用lpm_sleep或deep_selp函数</li>
<li>void lpm_sleep(void); //进入休眠状态</li>
<li>void lpm_shutdown(uint32_t wakeup_pin, uint32_t io_pull, uint32_t wake_on); //关闭所有外设，时钟；配置唤醒IO口为wakeup_pin，然后进入deep_sleep。类似于手机的关机。</li>
<li>void lpm_register_module(lpm_registered_module_t *module);   //注册，添加到链表</li>
<li>void lpm_unregister_module(lpm_registered_module_t *module); //删除，从链表移除</li>
<li>void lpm_init(void); //初始化链表，配置IO口沿信号事件触发唤醒</li>
<li>void lpm_pin_set_default_state(uint32_t ioid);</li>
</ul>
<p>数据结构：
lpm_registered_module_t：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lpm_registered_module</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">lpm_registered_module</span> *<span class="title">next</span>;</span> <span class="comment">//下一个</span></span><br><span class="line">  <span class="keyword">uint8_t</span> (*request_max_pm)(<span class="keyword">void</span>);    <span class="comment">//返回休眠类型</span></span><br><span class="line">  <span class="keyword">void</span> (*shutdown)(<span class="keyword">uint8_t</span> mode);     <span class="comment">//对应模块、单元执行shutdown前需要执行的函数</span></span><br><span class="line">  <span class="keyword">void</span> (*wakeup)(<span class="keyword">void</span>);               <span class="comment">//执行wake_up时模块、单元需要执行的函数</span></span><br><span class="line">  <span class="keyword">uint32_t</span> domain_lock;</span><br><span class="line">&#125; <span class="keyword">lpm_registered_module_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>几个宏定义，说明了不同的休眠等级：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LPM_MODE_AWAKE         0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LPM_MODE_SLEEP         1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LPM_MODE_DEEP_SLEEP    2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LPM_MODE_SHUTDOWN      3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LPM_MODE_MAX_SUPPORTED LPM_MODE_DEEP_SLEEP</span></span><br></pre></td></tr></table></figure></p>
<h1 id="0-1-lpm-shutdown"><a href="#0-1-lpm-shutdown" class="headerlink" title="0.1 lpm_shutdown"></a>0.1 lpm_shutdown</h1><p>该函数在platform下的button-sensor.c文件中，在按键处理函数中当检测到右键被按下时执行如下代码段：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpm_shutdown(BOARD_IOID_KEY_RIGHT, IOC_IOPULL_UP, IOC_WAKE_ON_LOW);</span><br></pre></td></tr></table></figure></p>
<h1 id="1-lpm-init"><a href="#1-lpm-init" class="headerlink" title="1. lpm_init"></a>1. lpm_init</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">lpm_init()</span><br><span class="line">&#123;</span><br><span class="line">  list_init(modules_list); <span class="comment">//设置modules_list = NULL</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Always wake up on any DIO edge detection */</span></span><br><span class="line">  ti_lib_aon_event_mcu_wake_up_set(AON_EVENT_MCU_WU3, AON_EVENT_IO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要简单介绍WUC(Wake-Up Control).</p>
<h2 id="1-1-AON-EVENT-MCU-WU3"><a href="#1-1-AON-EVENT-MCU-WU3" class="headerlink" title="1.1 AON_EVENT_MCU_WU3"></a>1.1 AON_EVENT_MCU_WU3</h2><p>表示配置的是MCU唤醒事件的事件3，共有4个事件分别为事件0~事件3。AON_EVENT_IO表示任何IO口上的边沿事件，对应手册中的PAD事件。</p>
<h2 id="1-2-WUC-唤醒控制器"><a href="#1-2-WUC-唤醒控制器" class="headerlink" title="1.2 WUC-唤醒控制器"></a>1.2 WUC-唤醒控制器</h2><p>CC26XX的唤醒控制器根据JTAG，AUX，MCU的输入事件控制power-on的触发。主要用于低功耗状态下的唤醒。唤醒控制器的输入是事件形式的，分三类：JTAG，AUX，MCU。</p>
<ul>
<li>JTAG: 有1个唤醒事件;</li>
<li>AUX : 有3个可编程的唤醒事件;</li>
<li>MCU : 有4个可编程的唤醒事件. 
事件的编程通过AON_EVENT:AUXWUSEL和AON_EVENT:MCUWUSEL完成。</li>
</ul>
<h2 id="1-3-AON-EVENT寄存器"><a href="#1-3-AON-EVENT寄存器" class="headerlink" title="1.3 AON_EVENT寄存器"></a>1.3 AON_EVENT寄存器</h2><p>包含四组：</p>
<ul>
<li>MCUWUSEL  : MCU唤醒事件选择配置 </li>
<li>AUXWUSEL  : AUX唤醒事件选择配置</li>
<li>EVTOMCUSEL: MCU事件来源选择（AON 相关）</li>
<li>RTCSEL    : AON_RTC的事件捕捉选择</li>
</ul>
<h2 id="1-4-MCUWUSEL寄存器"><a href="#1-4-MCUWUSEL寄存器" class="headerlink" title="1.4 MCUWUSEL寄存器"></a>1.4 MCUWUSEL寄存器</h2><p>该寄存器包含4个字节，每个字节对应一组AON_EVENT事件选择.<br>AON_EVENT事件包含IO口的边沿脉冲，RTC，JTAG，AUX_ADC,AUX_TIMER, BAT..其它事件。具体参考TI手册<a href="http://www.ti.com/lit/ug/swcu117f/swcu117f.pdf" target="_blank" rel="noopener">SWCU117D.pdf</a>第246页。</p>
<h1 id="2-lpm-register-module"><a href="#2-lpm-register-module" class="headerlink" title="2. lpm_register_module"></a>2. lpm_register_module</h1><p>lpm_register_module(&amp;cc26xx_rf_lpm_module);</p>
<h2 id="2-1-lpm-register-module函数"><a href="#2-1-lpm-register-module函数" class="headerlink" title="2.1 lpm_register_module函数"></a>2.1 lpm_register_module函数</h2><p>lpm_register_module调用list_add(modules_list, module)函数，将新模块添加到modules_list链表上，完成注册。</p>
<h2 id="2-2-cc26xx-rf-lpm-module定义"><a href="#2-2-cc26xx-rf-lpm-module定义" class="headerlink" title="2.2 cc26xx_rf_lpm_module定义"></a>2.2 cc26xx_rf_lpm_module定义</h2><p>语句中的cc26xx_rf_lpm_module在ieee-mode.c文件中定义。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPM_MODULE(cc26xx_rf_lpm_module, request, <span class="literal">NULL</span>, <span class="literal">NULL</span>, LPM_DOMAIN_NONE);</span><br></pre></td></tr></table></figure></p>
<p>宏展开
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">lpm_registered_module_t</span> cc26xx_rf_lpm_module =&#123;<span class="literal">NULL</span>, request, <span class="literal">NULL</span>, <span class="literal">NULL</span>, LPM_DOMAIN_NONE&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中request为函数，函数体：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span></span><br><span class="line">request(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(rf_is_on()) &#123;</span><br><span class="line">    <span class="keyword">return</span> LPM_MODE_SLEEP;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> LPM_MODE_MAX_SUPPORTED; <span class="comment">//LPM_MODE_DEEP_SLEEP</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="3-lpm-drop"><a href="#3-lpm-drop" class="headerlink" title="3. lpm_drop"></a>3. lpm_drop</h1><p>函数体如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">lpm_drop()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> max_pm;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Critical. Don't get interrupted! */</span></span><br><span class="line">  ti_lib_int_master_disable();</span><br><span class="line"></span><br><span class="line">  max_pm = setup_sleep_mode(); <span class="comment">//获取可执行的最高休眠等级</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Drop */</span></span><br><span class="line">  <span class="keyword">if</span>(max_pm == LPM_MODE_SLEEP) &#123;</span><br><span class="line">    lpm_sleep();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(max_pm == LPM_MODE_DEEP_SLEEP) &#123;</span><br><span class="line">    deep_sleep();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ti_lib_int_master_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为这个函数是在while(1)中被调用的，所有没有shutdown函数的调用，根据上文分析，shutdown是在按键处理函数中进行的。
那么lpm_sleep和deep_sleep的区别呢：</p>
<h1 id="4-lmp-sleep"><a href="#4-lmp-sleep" class="headerlink" title="4. lmp_sleep"></a>4. lmp_sleep</h1><p>函数体挺简单的：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">lpm_sleep(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  ENERGEST_SWITCH(ENERGEST_TYPE_CPU, ENERGEST_TYPE_LPM);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We are only interested in IRQ energest while idle or in LPM */</span></span><br><span class="line">  ENERGEST_IRQ_RESTORE(irq_energest);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Just to be on the safe side, explicitly disable Deep Sleep */</span></span><br><span class="line">  HWREG(NVIC_SYS_CTRL) &amp;= ~(NVIC_SYS_CTRL_SLEEPDEEP);</span><br><span class="line"></span><br><span class="line">  ti_lib_prcm_sleep();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Remember IRQ energest for next pass */</span></span><br><span class="line">  ENERGEST_IRQ_SAVE(irq_energest);</span><br><span class="line"></span><br><span class="line">  ENERGEST_SWITCH(ENERGEST_TYPE_LPM, ENERGEST_TYPE_CPU);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-1-sleep之前之后"><a href="#4-1-sleep之前之后" class="headerlink" title="4.1 sleep之前之后"></a>4.1 sleep之前之后</h2><p>这里又出现了ENERGEST_SWITCH，先来看看执行sleep之前和之后都做了什么吧。展开宏得到：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ERGEST_SWITCH(ENERGEST_TYPE_CPU, ENERGEST_TYPE_LPM); 宏展开</span></span><br><span class="line"><span class="comment">//#define ENERGEST_SWITCH(type_off, type_on) </span></span><br><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line">  <span class="keyword">rtimer_clock_t</span> energest_local_variable_now = RTIMER_NOW();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(energest_current_mode[ENERGEST_TYPE_CPU] != <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> (energest_local_variable_now &lt; energest_current_time[ENERGEST_TYPE_CPU]) &#123; </span><br><span class="line">      energest_total_time[ENERGEST_TYPE_CPU].current += RTIMER_ARCH_SECOND; </span><br><span class="line">    &#125;</span><br><span class="line">    energest_total_time[ENERGEST_TYPE_CPU].current += (<span class="keyword">rtimer_clock_t</span>)(</span><br><span class="line">                          energest_local_variable_now </span><br><span class="line">                        - energest_current_time[ENERGEST_TYPE_CPU]); </span><br><span class="line">    energest_current_mode[ENERGEST_TYPE_CPU] = <span class="number">0</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  energest_current_time[ENERGEST_TYPE_LPM] = energest_local_variable_now; </span><br><span class="line">  energest_current_mode[ENERGEST_TYPE_LPM] = <span class="number">1</span>; </span><br><span class="line">  &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>该代码段处理的是energest_total_time[].current,energest_current_mode,energest_current_time之间的事情。首先将当前时间保持在<em>_now变量中；然后看需要关闭的</em>_mode[type_off]是否为0，如果不为零对其total_time处理后进行置零；最后赋值需要打开的[type_on]的<em>_time[type_on]和</em>_mode[type_on]变量。<br>此处的时间处理，是将CPU启动到关闭运行的时间保存到其total_time变量中。那么这个ENERGEST_SWITCH做的事情就是切换正在执行的类型，记录被关闭的类型的允许时间，并将当前时间保持到要切换的新类型中。</p>
<p>ENERGEST_IRQ_*宏是在lpm.c函数中定义的，RESTORE调用的是<code>energest_type_set(ENERGEST_TYPE_IRQ, a);</code>函数，SAVE调用的是<code>a = energest_type_time(ENERGEST_TYPE_IRQ);</code>函数。总之就是进行休眠前的变量存储和唤醒后的变量还原。</p>
<h2 id="4-2-sleep"><a href="#4-2-sleep" class="headerlink" title="4.2 sleep"></a>4.2 sleep</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ti_lib_prcm_sleep();</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ti_lib_prcm_sleep(...)        PRCMSleep(__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>
<p>这里的PRCM: Power and clock management，而这条语句执行了什么操作呢？继续看
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__STATIC_INLINE <span class="keyword">void</span></span><br><span class="line">PRCMSleep(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Wait for an interrupt.</span></span><br><span class="line">    CPUwfi();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__asm __STATIC_INLINE <span class="keyword">void</span></span><br><span class="line">CPUwfi(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  wfi;</span><br><span class="line">  bx      lr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wfi是Wait for interrupt的缩写，这是个ARM的汇编指令，用于让CPU进入idle状态。可参考链接：<a href="http://www.wowotech.net/armv8a_arch/wfe_wfi.html" target="_blank" rel="noopener">ARM WFI和WFE指令</a>了解更多内容。<br>bx lr同样是汇编语句，作用类似于c函数的return。<br>这下就明白了，执行lpm_sleep函数后，最终停在wfi等待中断事件的发生了。当中断发生时退出休眠模式，返回原来的函数继续执行。</p>
<h1 id="5-deep-sleep"><a href="#5-deep-sleep" class="headerlink" title="5. deep_sleep"></a>5. deep_sleep</h1><p>需要说明的是deep_sleep或shutdown中被唤醒之后是需要执行wakeup函数的。wakeup做的事情与deep_sleep和shutdown刚好相反。</p>
<h3 id="5-1-domains"><a href="#5-1-domains" class="headerlink" title="5.1 domains"></a>5.1 domains</h3><p>在deelp_sleep中首先执行的是各模块的shutdown函数:
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来自lpm.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCKABLE_DOMAINS ((uint32_t)(PRCM_DOMAIN_SERIAL | PRCM_DOMAIN_PERIPH))</span></span><br><span class="line"><span class="comment">//来自deep_sleep</span></span><br><span class="line"><span class="keyword">uint32_t</span> domains = LOCKABLE_DOMAINS; <span class="comment">//变量用于统计深度休眠下需要保持供电的单元</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">module</span> = list_head(modules_list); <span class="keyword">module</span> != <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">module</span> = <span class="keyword">module</span>-&gt;next) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">module</span>-&gt;shutdown) &#123;</span><br><span class="line">    <span class="keyword">module</span>-&gt;shutdown(LPM_MODE_DEEP_SLEEP);</span><br><span class="line">  &#125;</span><br><span class="line">  domains &amp;= ~<span class="keyword">module</span>-&gt;domain_lock;</span><br><span class="line">&#125;</span><br><span class="line">domains &amp;= LOCKABLE_DOMAINS; <span class="comment">//保险起见，变量初始化之后再次进行排查LOCKABLE_DOMAINS，保证这里只控制SERIAL和PERIPH。</span></span><br><span class="line"><span class="comment">//最后domains中</span></span><br></pre></td></tr></table></figure></p>
<p>这里处理的只有PRCM_DOMAIN_SERIAL和PRCM_DOMAIN_PERIPH，根据实际情况选择是否深度休眠状态下保持供电。<br>函数中的后面有语句：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ti_lib_prcm_power_domain_off(PRCM_DOMAIN_RFCORE | PRCM_DOMAIN_CPU |</span><br><span class="line">                               PRCM_DOMAIN_VIMS | PRCM_DOMAIN_SYSBUS);</span><br></pre></td></tr></table></figure></p>
<p>使其它部分掉电。                               </p>
<h3 id="5-2-喂狗"><a href="#5-2-喂狗" class="headerlink" title="5.2 喂狗"></a>5.2 喂狗</h3><p><code>watchdog_periodic();</code>防止唤醒后事情没处理完就发生看门狗中断。</p>
<h3 id="5-3-时钟-VIMS等其它部分关闭"><a href="#5-3-时钟-VIMS等其它部分关闭" class="headerlink" title="5.3 时钟 VIMS等其它部分关闭"></a>5.3 时钟 VIMS等其它部分关闭</h3><p><code></code> c
  oscillators_switch_to_hf_rc();
  /<em> Shut Down the AUX if the user application is not using it </em>/
  aux_ctrl_power_down(false);
  /<em> Configure clock sources for MCU: No clock </em>/
  ti_lib_aon_wuc_mcu_power_down_config(AONWUC_NO_CLOCK);
  ti_lib_aon_wuc_jtag_power_off();
  ti_lib_aon_wuc_domain_power_down_enable();
  ti_lib_sys_ctrl_set_recharge_before_power_down(XOSC_IN_HIGH_POWER_MODE);
  ti_lib_prcm_cache_retention_disable();
  ti_lib_vims_mode_set(VIMS_BASE, VIMS_MODE_OFF);
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">代码整理后就是上面这些完成了相关部分的powerdown.</span><br><span class="line"></span><br><span class="line">### <span class="number">5.4</span> 进入深度休眠</span><br><span class="line">`ti_lib_prcm_deep_sleep();`函数完成。</span><br><span class="line">最终函数体如下：</span><br><span class="line">``` c</span><br><span class="line">void</span><br><span class="line">PRCMDeepSleep(void)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Enable deep-sleep.</span></span><br><span class="line">    HWREG(NVIC_SYS_CTRL) |= NVIC_SYS_CTRL_SLEEPDEEP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for an interrupt.</span></span><br><span class="line">    CPUwfi();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disable deep-sleep so that a future sleep will work correctly.</span></span><br><span class="line">    HWREG(NVIC_SYS_CTRL) &amp;= ~(NVIC_SYS_CTRL_SLEEPDEEP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样是执行CPUwfi函数进入休眠状态。</p>
<h1 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h1><p>与lmp_sleep不同的是，deep_sleep函数进入休眠之前把许多单元的电源时钟都关闭了，同时退出休眠的时候需要执行wakeup函数进行还原。而lmp_sleep不需要，它从休眠模式退出时直接可以执行原来正在执行的代码，并且各个单元与进入休眠时的状态一致。</p>
]]></content>
      
        <categories>
            
            <category> Contiki </category>
            
            <category> cc26xx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> cc26xx </tag>
            
            <tag> LPM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Contiki Energest]]></title>
      <url>https://xubovey.github.io/2016/10/26/161026-Contiki-energest/</url>
      <content type="html"><![CDATA[<p>Contiki 的设计目的是在极端低功耗的系统中运行，这些系统甚至可能需要只用一对AA电池能够工作许多年。Contiki 为辅助这些低功耗系统的开发提供了功耗估计和功耗分析机制Energest。<br>代码分析中多次遇到这个活力评估相关的函数，现在来做简单分析。<br>遇到的代码中基本上是这样的：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">energest_init();</span><br><span class="line">ENERGEST_ON(ENERGEST_TYPE_CPU);</span><br><span class="line"></span><br><span class="line">ENERGEST_ON(ENERGEST_TYPE_IRQ);</span><br><span class="line"></span><br><span class="line">ENERGEST_OFF(ENERGEST_TYPE_IRQ);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h1 id="1-energest-init"><a href="#1-energest-init" class="headerlink" title="1. energest_init"></a>1. energest_init</h1><p>这个比较简单，代码如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">energest_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ENERGEST_TYPE_MAX; ++i) &#123;</span><br><span class="line">    energest_total_time[i].current = energest_current_time[i] = <span class="number">0</span>;</span><br><span class="line">    energest_current_mode[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENERGEST_CONF_LEVELDEVICE_LEVELS</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ENERGEST_CONF_LEVELDEVICE_LEVELS; ++i) &#123;</span><br><span class="line">    energest_leveldevice_current_leveltime[i].current = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就是将相关数组中的变量初始化为0。简化分析写做time数组和mode数据。</p>
<h1 id="2-ENERGEST-ON"><a href="#2-ENERGEST-ON" class="headerlink" title="2. ENERGEST_ON"></a>2. ENERGEST_ON</h1><p>这个宏展是这样定义的：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENERGEST_ON(type)  do &#123; \</span></span><br><span class="line">                           <span class="comment">/*++energest_total_count;*/</span> \</span><br><span class="line">                           energest_current_time[type] = RTIMER_NOW(); \</span><br><span class="line">			   energest_current_mode[type] = <span class="number">1</span>; \</span><br><span class="line">                           &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line">```                           </span><br><span class="line">以ENERGEST_ON(ENERGEST_TYPE_CPU);为例进行展开如下；</span><br><span class="line">``` c</span><br><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line">     <span class="comment">/*++energest_total_count;*/</span> </span><br><span class="line">     energest_current_time[ENERGEST_TYPE_CPU] = RTIMER_NOW(); </span><br><span class="line">	 energest_current_mode[ENERGEST_TYPE_CPU] = <span class="number">1</span>; </span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>这里将time数组中存入当前的RTIMER时间，并将mode置1。而ENERGEST_TYPE_CPU是个枚举变量成员，定义如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> energest_type &#123;</span><br><span class="line">  ENERGEST_TYPE_CPU,</span><br><span class="line">  ENERGEST_TYPE_LPM,</span><br><span class="line">  ENERGEST_TYPE_IRQ,</span><br><span class="line">  ENERGEST_TYPE_LED_GREEN,</span><br><span class="line">  ENERGEST_TYPE_LED_YELLOW,</span><br><span class="line">  ENERGEST_TYPE_LED_RED,</span><br><span class="line">  ENERGEST_TYPE_TRANSMIT,</span><br><span class="line">  ENERGEST_TYPE_LISTEN,</span><br><span class="line"></span><br><span class="line">  ENERGEST_TYPE_FLASH_READ,</span><br><span class="line">  ENERGEST_TYPE_FLASH_WRITE,</span><br><span class="line"></span><br><span class="line">  ENERGEST_TYPE_SENSORS,</span><br><span class="line"></span><br><span class="line">  ENERGEST_TYPE_SERIAL,</span><br><span class="line"></span><br><span class="line">  ENERGEST_TYPE_MAX</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="3-ENERGEST-OFF"><a href="#3-ENERGEST-OFF" class="headerlink" title="3. ENERGEST_OFF"></a>3. ENERGEST_OFF</h1><p>宏定义如下；
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENERGEST_OFF(type) <span class="meta-keyword">if</span>(energest_current_mode[type] != 0) do &#123;	\</span></span><br><span class="line">                           energest_total_time[type].current += (<span class="keyword">rtimer_clock_t</span>)(RTIMER_NOW() - \</span><br><span class="line">                           energest_current_time[type]); \</span><br><span class="line">			               energest_current_mode[type] = <span class="number">0</span>; \</span><br><span class="line">                           &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>ENERGEST_OFF(ENERGEST_TYPE_IRQ);展开后：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(energest_current_mode[ENERGEST_TYPE_IRQ] != <span class="number">0</span>) </span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    energest_total_time[ENERGEST_TYPE_IRQ].current += </span><br><span class="line">                       (<span class="keyword">rtimer_clock_t</span>)(RTIMER_NOW() </span><br><span class="line">                     - energest_current_time[ENERGEST_TYPE_IRQ]); </span><br><span class="line">	energest_current_mode[ENERGEST_TYPE_IRQ] = <span class="number">0</span>; </span><br><span class="line">  &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>这里做的是将RTIMER_NOW得到的时间减去执行ON时存入current_time的时间，并将差值存入total_time中。也就是说这个total_time中存的是某类代码的活跃时间。  </p>
]]></content>
      
        <categories>
            
            <category> Contiki </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Contiki </tag>
            
            <tag> Energest </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Contiki RF底层代码分析]]></title>
      <url>https://xubovey.github.io/2016/10/25/161025-ContikiNetStack-RFAnalysis/</url>
      <content type="html"><![CDATA[<p>要先知道怎么工作的才好了解，移植。本文从main函数中的rf相关代码入手，顺藤摸瓜理清RF的相关操作和数据处理流程。</p>
<a id="more"></a>
<h1 id="1-main函数中的RF相关代码"><a href="#1-main函数中的RF相关代码" class="headerlink" title="1. main函数中的RF相关代码"></a>1. main函数中的RF相关代码</h1><p>为什么从main入手，因为这里有初始化等相关代码，基本可以顺藤摸瓜搞明白里面的问题所在。<br>参考文件：contiki/platform/srf06-cc26xx/contiki-main.c，其中main函数里与射频相关的代码只有两句：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstack_init();</span><br><span class="line">set_rf_params();</span><br></pre></td></tr></table></figure></p>
<h1 id="2-set-rf-params函数"><a href="#2-set-rf-params函数" class="headerlink" title="2. set_rf_params函数"></a>2. set_rf_params函数</h1><p>这里先看<code>set_rf_params()</code>因为函数体就定义在main函数中。核心代码：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取设备地址，并取出16位小地址。</span></span><br><span class="line">ieee_addr_cpy_to(ext_addr, <span class="number">8</span>); </span><br><span class="line">short_addr = ext_addr[<span class="number">7</span>];</span><br><span class="line">short_addr |= ext_addr[<span class="number">6</span>] &lt;&lt; <span class="number">8</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//同样是地址配置，这里将地址copy给了linkaddr_node_addr.</span></span><br><span class="line"><span class="comment">/* Populate linkaddr_node_addr. Maintain endianness */</span></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;linkaddr_node_addr, &amp;ext_addr[<span class="number">8</span> - LINKADDR_SIZE], LINKADDR_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这也是一些配置，问题是NETSTACK_RADIO.set_value是什么？</span></span><br><span class="line">NETSTACK_RADIO.set_value(RADIO_PARAM_PAN_ID, IEEE802154_PANID);</span><br><span class="line">NETSTACK_RADIO.set_value(RADIO_PARAM_16BIT_ADDR, short_addr);</span><br><span class="line">NETSTACK_RADIO.set_value(RADIO_PARAM_CHANNEL, RF_CORE_CHANNEL);</span><br><span class="line">NETSTACK_RADIO.set_object(RADIO_PARAM_64BIT_ADDR, ext_addr, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">NETSTACK_RADIO.get_value(RADIO_PARAM_CHANNEL, &amp;val);</span><br></pre></td></tr></table></figure></p>
<p>注释中可以看到，这段代码引出了<code>NETSTACK_RADIO.set_value</code>函数，<code>NETSTACK_RADIO</code>应该是个包含有函数指针的结构体。<br>在contiki/core/net/netstack.h文件中找到如下宏定义：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETSTACK_RADIO NETSTACK_CONF_RADIO</span></span><br></pre></td></tr></table></figure></p>
<p>继续在contiki/platform/srf06-cc26xx/contiki-conf.h中找到相关代码：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETSTACK_CONF_RADIO        ieee_mode_driver <span class="comment">//这就是我们要找的了。</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RF_CORE_CONF_CHANNEL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RF_CORE_CONF_CHANNEL                     25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULLRDC_CONF_802154_AUTOACK_HW            1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULLRDC_CONF_SEND_802154_ACK              0</span></span><br></pre></td></tr></table></figure></p>
<p>嗯，好了把main函数中的set_value相关代码展开如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ieee_mode_driver.set_value(RADIO_PARAM_PAN_ID, IEEE802154_PANID);</span><br><span class="line">ieee_mode_driver.set_value(RADIO_PARAM_16BIT_ADDR, short_addr);</span><br><span class="line">ieee_mode_driver.set_value(RADIO_PARAM_CHANNEL, RF_CORE_CHANNEL);</span><br><span class="line">ieee_mode_driver.set_object(RADIO_PARAM_64BIT_ADDR, ext_addr, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">ieee_mode_driver.get_value(RADIO_PARAM_CHANNEL, &amp;val);</span><br></pre></td></tr></table></figure></p>
<p>找ieee-mode_driver，在contiki/cpu/cc26xx-cc13xx/rf-core/ieee-mode.c文件中找到该变量。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">radio_driver</span> <span class="title">ieee_mode_driver</span> = &#123;</span></span><br><span class="line">  init,             <span class="comment">//完成参数初始化，中断配置，启动rf_core_process进程</span></span><br><span class="line">  prepare,          <span class="comment">//发送准备，将数据拷贝到tx_buf缓冲区</span></span><br><span class="line">  transmit,         <span class="comment">//完成数据发送</span></span><br><span class="line">  send,             <span class="comment">//调用prepare和transmit，完成发送</span></span><br><span class="line">  read_frame,       <span class="comment">//将当前接收缓冲区数据拷贝到用户缓冲区</span></span><br><span class="line">  channel_clear,    <span class="comment">//判断当前通道是否有被其它设备使用</span></span><br><span class="line">  receiving_packet, <span class="comment">//检查CAA中的RF_CMD_CCA_REQ_CCA_SYNC_BUSY是否为1，判断有接收包</span></span><br><span class="line">  pending_packet,   <span class="comment">//遍历RF接收缓冲区链表，如果有未处理数据调用process_poll(&amp;rf_core_process)触发rf_core_process进程</span></span><br><span class="line">  on,               <span class="comment">//完成一些准备工作后，调用rx_on()-&gt;最终调用rf_cmd_ieee_rx()函数</span></span><br><span class="line">  off,              <span class="comment">//等待发送完成后调用rx_off();和rf_core_power_down();关闭rf接口</span></span><br><span class="line">  get_value,        <span class="comment">//读取单个RF配置参数，这些配置在init_rf_params函数（init函数调用）中被赋值</span></span><br><span class="line">  set_value,        <span class="comment">//单个RF参数设置</span></span><br><span class="line">  get_object,       <span class="comment">//单个参数读取RADIO_PARAM_64BIT_ADDR或RADIO_PARAM_LAST_PACKET_TIMESTAMP参数</span></span><br><span class="line">  set_object,       <span class="comment">//单个参数设置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>经过查看set_value，set_object函数，发现这些操作都是在进行一些参数的配置。至此不必继续分析。只是ieee-mode中有些内部函数可以做简单说明：</p>
<ul>
<li>static uint8_t rf_is_on(void)         判定RF是否打开，1:处于接收模式，0：其他模式</li>
<li>static uint8_t transmitting(void)     判断是否处于发送状态，1：发送，0：其他</li>
<li>static uint8_t get_cca_info(void)     获取CAA信息</li>
<li>static radio_value_t get_rssi(void)   获取当前信号强度，单位dBm</li>
<li>static radio_value_t get_tx_power(void)  获取发送功率配置值，单位dBm</li>
<li>static void set_tx_power(radio_value_t power) 配置发送功率值，单位dBm</li>
<li>static uint8_t rf_radio_setup()       执行CMD_RADIO_SETUP命令完成参数配置</li>
<li>static uint8_t rf_cmd_ieee_rx()       配置RF为IEEE802.15.4 RX模式，即：用将cmd_ieee_rx_buf的内容完成RF配置</li>
<li>static void init_rx_buffers(void)     接收缓冲区初始化为循环链表</li>
<li>static void init_rf_params(void)      完成cmd_ieee_rx_buf参数设置</li>
<li>static int rx_on(void)                执行rf_cmd_ieee_rx();打开Rx</li>
<li>static int rx_off(void)               给RF内核发送CMD_ABORT命令关闭RF</li>
<li>static uint8_t request(void)          LPM_MODULE(cc26xx_rf_lpm_module, request, NULL, NULL, LPM_DOMAIN_NONE);</li>
<li>static void soft_off(void)            给RF内核发送CMD_ABORT命令关闭RF</li>
<li>static uint8_t soft_on(void)          调用rx_on函数打开RF</li>
<li>static uint32_t calc_last_packet_timestamp(uint32_t rat_timestamp) 计算时间戳，用于流控</li>
</ul>
<h1 id="3-netstack-init函数"><a href="#3-netstack-init函数" class="headerlink" title="3 netstack_init函数"></a>3 netstack_init函数</h1><p>netstack_init函数位于contiki/core/net/netstack.c中，函数体并注释展开后的代码如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">netstack_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  NETSTACK_RADIO.init();   <span class="comment">// ieee_mode_driver.init();  // 网络的物理层</span></span><br><span class="line">  NETSTACK_RDC.init();     <span class="comment">// contikimac_driver.init(); // 网络的RDC层</span></span><br><span class="line">  NETSTACK_LLSEC.init();   <span class="comment">// nullsec_driver.init();    // 网络链路层</span></span><br><span class="line">  NETSTACK_MAC.init();     <span class="comment">// csma_driver.init();       // MAC层</span></span><br><span class="line">  NETSTACK_NETWORK.init(); <span class="comment">// rime_driver.init();       // 网络层</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中第一个分析如下，其它几个为协议栈上的函数暂不分析，分析协议栈的时候再另起新篇吧。</p>
<h1 id="4-ieee-mode-driver-init"><a href="#4-ieee-mode-driver-init" class="headerlink" title="4 ieee_mode_driver.init"></a>4 ieee_mode_driver.init</h1><p>这里调用的是init函数，函数内容：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  lpm_register_module(&amp;cc26xx_rf_lpm_module);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//调用函数HWREG(PRCM_BASE + PRCM_O_RFCMODESEL) = PRCM_RFCMODESEL_CURR_MODE5;</span></span><br><span class="line">  <span class="comment">//模式选择</span></span><br><span class="line">  <span class="comment">//这里出现的PRCM相关的宏定义位于Contiki/cpu/cc26xx-cc13xx/lib/cc26xxware/inc/hw-prcm.h,用find没找到。</span></span><br><span class="line">  rf_core_set_modesel();  </span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Initialise RX buffers */</span></span><br><span class="line">  <span class="comment">//初始化接收缓冲区，buf_0~3为4个缓冲区，构成循环链表</span></span><br><span class="line">  <span class="built_in">memset</span>(rx_buf_0, <span class="number">0</span>, RX_BUF_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(rx_buf_1, <span class="number">0</span>, RX_BUF_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(rx_buf_2, <span class="number">0</span>, RX_BUF_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(rx_buf_3, <span class="number">0</span>, RX_BUF_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set of RF Core data queue. Circular buffer, no last entry */</span></span><br><span class="line">  rx_data_queue.pCurrEntry = rx_buf_0;</span><br><span class="line"></span><br><span class="line">  rx_data_queue.pLastEntry = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize current read pointer to first element (used in ISR) */</span></span><br><span class="line">  <span class="comment">//ISR中会对rx_read_entry进行处理。</span></span><br><span class="line">  rx_read_entry = rx_buf_0;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Populate the RF parameters data structure with default values */</span></span><br><span class="line">  <span class="comment">//RF相关参数初始化，例如：CRC、ack等。</span></span><br><span class="line">  init_rf_params();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//on()函数中做了很多事情：时钟的配置使能，还调用了函数init_rx_buffers();rf_core_setup_interrupts(poll_mode);rf_core_boot()；rf_radio_setup()；rx_on()；等。</span></span><br><span class="line">  <span class="keyword">if</span>(on() != RF_CORE_CMD_OK) &#123;</span><br><span class="line">    PRINTF(<span class="string">"init: on() failed\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> RF_CORE_CMD_ERROR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ENERGEST_ON(ENERGEST_TYPE_LISTEN);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//mode_ieee包含了两个函数soft_off和soft_on，将其配置给primary_mode变量。</span></span><br><span class="line">  rf_core_primary_mode_register(&amp;mode_ieee);</span><br><span class="line"></span><br><span class="line">  check_rat_overflow(<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">//溢出监视。</span></span><br><span class="line">  ctimer_set(&amp;rat_overflow_timer, RAT_OVERFLOW_PERIOD_SECONDS * CLOCK_SECOND / <span class="number">2</span>,</span><br><span class="line">             handle_rat_overflow, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//启动rf_core_process进程。</span></span><br><span class="line">  process_start(&amp;rf_core_process, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据分析，init函数完成了接收缓冲区的清零操作，调用<code>init_rf_params();</code>函数完成参数初始化，调用on函数打开RF并配置了中断函数入口地址，回调函数定时器配置ctimer_set，最后完成启动进程rf_core_process。</p>
<h1 id="5-rf-core-process"><a href="#5-rf-core-process" class="headerlink" title="5. rf_core_process"></a>5. rf_core_process</h1><p>该进程定义于contiki/cpu/cc26xx-cc13xx/rf-core/rf_core.c文件中。函数体：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PROCESS_THREAD(rf_core_process, ev, data)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">  PROCESS_BEGIN();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    PROCESS_YIELD_UNTIL(ev == PROCESS_EVENT_POLL);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      watchdog_periodic();</span><br><span class="line">      packetbuf_clear();</span><br><span class="line">      len = NETSTACK_RADIO.read(packetbuf_dataptr(), PACKETBUF_SIZE);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        packetbuf_set_datalen(len);</span><br><span class="line"></span><br><span class="line">        NETSTACK_RDC.input();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(len &gt; <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  PROCESS_END();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该进程做的事情很简单，当PROCESS_EVENT_POLL事件发生的时候，调用<code>NETSTACK_RADIO.read</code>函数读取接收缓冲区数据，并调用<code>NETSTACK_RDC.input</code>函数通知上层协议。如果不需要协议层的支持，在这个process中调用自定义函数触发数据处理进程即可。PROCESS_EVENT_POLL事件是执行process_poll函数时触发的。上文分析在init函数中调用的on函数里调用了<code>rf_core_setup_interrupts(poll_mode);</code>最终执行如下代码：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HWREG(RFC_DBELL_NONBUF_BASE + RFC_DBELL_O_RFCPEIEN) = ENABLED_IRQS_POLL_MODE;</span><br></pre></td></tr></table></figure></p>
<p>看来这里只定义了poll_mode模式，还以为在中断里调用了poll呢，那么就搜索吧，执行<code>find</code>命令：
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user<span class="meta">@instant</span>-<span class="string">contiki:</span>~/contiki$ find -name <span class="string">"*.c"</span> | xargs grep  <span class="string">"process_poll(&amp;rf_core_process)"</span></span><br><span class="line">.<span class="regexp">/cpu/</span>cc26xx-cc13xx<span class="regexp">/rf-core/</span>rf-core.<span class="string">c:</span>    process_poll(&amp;rf_core_process);</span><br><span class="line">.<span class="regexp">/cpu/</span>cc26xx-cc13xx<span class="regexp">/rf-core/</span>prop-mode.<span class="string">c:</span>      process_poll(&amp;rf_core_process);</span><br><span class="line">.<span class="regexp">/cpu/</span>cc26xx-cc13xx<span class="regexp">/rf-core/</span>ieee-mode.<span class="string">c:</span>        process_poll(&amp;rf_core_process);</span><br></pre></td></tr></table></figure></p>
<p>原来只是没找到,rf-core.c中是在函数<code>void cc26xx_rf_cpe0_isr(void)</code>中调用process_poll的，而这个函数正是中断函数。<br>ieee-mode.c中是在pending_packet函数中调用的，遍历接收缓冲区时，当存在缓冲区状态为DATA_ENTRY_STATUS_FINISHED时调用poll。触发数据接收。<br>prop-mode.c和ieee-mode.c是并列文件，其中的process_poll函数同样是在pending_start函数中调用的。</p>
<h1 id="6-自定义配置"><a href="#6-自定义配置" class="headerlink" title="6. 自定义配置"></a>6. 自定义配置</h1><p>如果想自定义配置一些参数、功能，需要对RF部分的参数有清除的掌握才行。而这些参数的定义在文件cpu/cc26xx-cc13xx/rf-core/api/ieee-cmd.h中。</p>
<h1 id="6-1-CMD-IEEE-RX命令参数"><a href="#6-1-CMD-IEEE-RX命令参数" class="headerlink" title="6.1 CMD_IEEE_RX命令参数"></a>6.1 CMD_IEEE_RX命令参数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMD_IEEE_RX                                             0x2801</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">RFC_STRUCT</span> <span class="title">rfc_CMD_IEEE_RX_s</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint16_t</span> commandNo;                  <span class="comment">//!&lt;        The command ID number 0x2801</span></span><br><span class="line">   <span class="keyword">uint16_t</span> status;                     <span class="comment">//!&lt; \brief An integer telling the status of the command. This value is</span></span><br><span class="line">                                        <span class="comment">//!&lt;        updated by the radio CPU during operation and may be read by the</span></span><br><span class="line">                                        <span class="comment">//!&lt;        system CPU at any time.</span></span><br><span class="line">   rfc_radioOp_t *pNextOp;              <span class="comment">//!&lt;        Pointer to the next operation to run after this operation is done</span></span><br><span class="line">   <span class="keyword">ratmr_t</span> startTime;                   <span class="comment">//!&lt;        Absolute or relative start time (depending on the value of &lt;code&gt;startTrigger&lt;/code&gt;)</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="keyword">uint8_t</span> triggerType:<span class="number">4</span>;            <span class="comment">//!&lt;        The type of trigger</span></span><br><span class="line">      <span class="keyword">uint8_t</span> bEnaCmd:<span class="number">1</span>;                <span class="comment">//!&lt; \brief 0: No alternative trigger command&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: CMD_TRIGGER can be used as an alternative trigger</span></span><br><span class="line">      <span class="keyword">uint8_t</span> triggerNo:<span class="number">2</span>;              <span class="comment">//!&lt;        The trigger number of the CMD_TRIGGER command that triggers this action</span></span><br><span class="line">      <span class="keyword">uint8_t</span> pastTrig:<span class="number">1</span>;               <span class="comment">//!&lt; \brief 0: A trigger in the past is never triggered, or for start of commands, give an error&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: A trigger in the past is triggered as soon as possible</span></span><br><span class="line">   &#125; startTrigger;                      <span class="comment">//!&lt;        Identification of the trigger that starts the operation</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="keyword">uint8_t</span> rule:<span class="number">4</span>;                   <span class="comment">//!&lt;        Condition for running next command: Rule for how to proceed</span></span><br><span class="line">      <span class="keyword">uint8_t</span> nSkip:<span class="number">4</span>;                  <span class="comment">//!&lt;        Number of skips if the rule involves skipping</span></span><br><span class="line">   &#125; condition;</span><br><span class="line">   <span class="keyword">uint8_t</span> channel;                     <span class="comment">//!&lt; \brief Channel to tune to in the start of the operation&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        0: Use existing channel&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        11&amp;ndash;26: Use as IEEE 802.15.4 channel, i.e. frequency is (2405 + 5 &amp;times; (channel - 11)) MHz&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        60&amp;ndash;207: Frequency is  (2300 + channel) MHz&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        Others: &lt;i&gt;Reserved&lt;/i&gt;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="keyword">uint8_t</span> bAutoFlushCrc:<span class="number">1</span>;          <span class="comment">//!&lt;        If 1, automatically remove packets with CRC error from Rx queue</span></span><br><span class="line">      <span class="keyword">uint8_t</span> bAutoFlushIgn:<span class="number">1</span>;          <span class="comment">//!&lt;        If 1, automatically remove packets that can be ignored according to frame filtering from Rx queue</span></span><br><span class="line">      <span class="keyword">uint8_t</span> bIncludePhyHdr:<span class="number">1</span>;         <span class="comment">//!&lt;        If 1, include the received PHY header field in the stored packet; otherwise discard it</span></span><br><span class="line">      <span class="keyword">uint8_t</span> bIncludeCrc:<span class="number">1</span>;            <span class="comment">//!&lt;        If 1, include the received CRC field in the stored packet; otherwise discard it</span></span><br><span class="line">      <span class="keyword">uint8_t</span> bAppendRssi:<span class="number">1</span>;            <span class="comment">//!&lt;        If 1, append an RSSI byte to the packet in the Rx queue</span></span><br><span class="line">      <span class="keyword">uint8_t</span> bAppendCorrCrc:<span class="number">1</span>;         <span class="comment">//!&lt;        If 1, append a correlation value and CRC result byte to the packet in the Rx queue</span></span><br><span class="line">      <span class="keyword">uint8_t</span> bAppendSrcInd:<span class="number">1</span>;          <span class="comment">//!&lt;        If 1, append an index from the source matching algorithm</span></span><br><span class="line">      <span class="keyword">uint8_t</span> bAppendTimestamp:<span class="number">1</span>;       <span class="comment">//!&lt;        If 1, append a timestamp to the packet in the Rx queue</span></span><br><span class="line">   &#125; rxConfig;</span><br><span class="line">   dataQueue_t* pRxQ;                   <span class="comment">//!&lt;        Pointer to receive queue</span></span><br><span class="line">   rfc_ieeeRxOutput_t *pOutput;         <span class="comment">//!&lt;        Pointer to output structure (NULL: Do not store results)</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="keyword">uint16_t</span> frameFiltEn:<span class="number">1</span>;           <span class="comment">//!&lt; \brief 0: Disable frame filtering&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: Enable frame filtering</span></span><br><span class="line">      <span class="keyword">uint16_t</span> frameFiltStop:<span class="number">1</span>;         <span class="comment">//!&lt; \brief 0: Receive all packets to the end&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: Stop receiving frame once frame filtering has caused the frame to be rejected.</span></span><br><span class="line">      <span class="keyword">uint16_t</span> autoAckEn:<span class="number">1</span>;             <span class="comment">//!&lt; \brief 0: Disable auto ACK&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: Enable auto ACK.</span></span><br><span class="line">      <span class="keyword">uint16_t</span> slottedAckEn:<span class="number">1</span>;          <span class="comment">//!&lt; \brief 0: Non-slotted ACK&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: Slotted ACK.</span></span><br><span class="line">      <span class="keyword">uint16_t</span> autoPendEn:<span class="number">1</span>;            <span class="comment">//!&lt; \brief 0: Auto-pend disabled&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: Auto-pend enabled</span></span><br><span class="line">      <span class="keyword">uint16_t</span> defaultPend:<span class="number">1</span>;           <span class="comment">//!&lt;        The value of the pending data bit in auto ACK packets that are not subject to auto-pend</span></span><br><span class="line">      <span class="keyword">uint16_t</span> bPendDataReqOnly:<span class="number">1</span>;      <span class="comment">//!&lt; \brief 0: Use auto-pend for any packet&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: Use auto-pend for data request packets only</span></span><br><span class="line">      <span class="keyword">uint16_t</span> bPanCoord:<span class="number">1</span>;             <span class="comment">//!&lt; \brief 0: Device is not PAN coordinator&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: Device is PAN coordinator</span></span><br><span class="line">      <span class="keyword">uint16_t</span> maxFrameVersion:<span class="number">2</span>;       <span class="comment">//!&lt;        Reject frames where the frame version field in the FCF is greater than this value</span></span><br><span class="line">      <span class="keyword">uint16_t</span> fcfReservedMask:<span class="number">3</span>;       <span class="comment">//!&lt;        Value to be AND-ed with the reserved part of the FCF; frame rejected if result is non-zero</span></span><br><span class="line">      <span class="keyword">uint16_t</span> modifyFtFilter:<span class="number">2</span>;        <span class="comment">//!&lt; \brief Treatment of MSB of frame type field before frame-type filtering:&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        0: No modification&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: Invert MSB&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        2: Set MSB to 0&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        3: Set MSB to 1</span></span><br><span class="line">      <span class="keyword">uint16_t</span> bStrictLenFilter:<span class="number">1</span>;      <span class="comment">//!&lt; \brief 0: Accept acknowledgement frames of any length &gt;= 5&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: Accept only acknowledgement frames of length 5</span></span><br><span class="line">   &#125; frameFiltOpt;                      <span class="comment">//!&lt;        Frame filtering options</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="keyword">uint8_t</span> bAcceptFt0Beacon:<span class="number">1</span>;       <span class="comment">//!&lt; \brief Treatment of frames with frame type 000 (beacon):&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        0: Reject&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: Accept</span></span><br><span class="line">      <span class="keyword">uint8_t</span> bAcceptFt1Data:<span class="number">1</span>;         <span class="comment">//!&lt; \brief Treatment of frames with frame type 001 (data):&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        0: Reject&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: Accept</span></span><br><span class="line">      <span class="keyword">uint8_t</span> bAcceptFt2Ack:<span class="number">1</span>;          <span class="comment">//!&lt; \brief Treatment of frames with frame type 010 (ACK):&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        0: Reject, unless running ACK receive command&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: Always accept</span></span><br><span class="line">      <span class="keyword">uint8_t</span> bAcceptFt3MacCmd:<span class="number">1</span>;       <span class="comment">//!&lt; \brief Treatment of frames with frame type 011 (MAC command):&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        0: Reject&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: Accept</span></span><br><span class="line">      <span class="keyword">uint8_t</span> bAcceptFt4Reserved:<span class="number">1</span>;     <span class="comment">//!&lt; \brief Treatment of frames with frame type 100 (reserved):&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        0: Reject&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: Accept</span></span><br><span class="line">      <span class="keyword">uint8_t</span> bAcceptFt5Reserved:<span class="number">1</span>;     <span class="comment">//!&lt; \brief Treatment of frames with frame type 101 (reserved):&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        0: Reject&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: Accept</span></span><br><span class="line">      <span class="keyword">uint8_t</span> bAcceptFt6Reserved:<span class="number">1</span>;     <span class="comment">//!&lt; \brief Treatment of frames with frame type 110 (reserved):&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        0: Reject&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: Accept</span></span><br><span class="line">      <span class="keyword">uint8_t</span> bAcceptFt7Reserved:<span class="number">1</span>;     <span class="comment">//!&lt; \brief Treatment of frames with frame type 111 (reserved):&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        0: Reject&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: Accept</span></span><br><span class="line">   &#125; frameTypes;                        <span class="comment">//!&lt;        Frame types to receive in frame filtering</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="keyword">uint8_t</span> ccaEnEnergy:<span class="number">1</span>;            <span class="comment">//!&lt;        Enable energy scan as CCA source</span></span><br><span class="line">      <span class="keyword">uint8_t</span> ccaEnCorr:<span class="number">1</span>;              <span class="comment">//!&lt;        Enable correlator based carrier sense as CCA source</span></span><br><span class="line">      <span class="keyword">uint8_t</span> ccaEnSync:<span class="number">1</span>;              <span class="comment">//!&lt;        Enable sync found based carrier sense as CCA source</span></span><br><span class="line">      <span class="keyword">uint8_t</span> ccaCorrOp:<span class="number">1</span>;              <span class="comment">//!&lt; \brief Operator to use between energy based and correlator based CCA&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        0: Report busy channel if either ccaEnergy or ccaCorr are busy&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: Report busy channel if both ccaEnergy and ccaCorr are busy</span></span><br><span class="line">      <span class="keyword">uint8_t</span> ccaSyncOp:<span class="number">1</span>;              <span class="comment">//!&lt; \brief Operator to use between sync found based CCA and the others&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        0: Always report busy channel if ccaSync is busy&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: Always report idle channel if ccaSync is idle</span></span><br><span class="line">      <span class="keyword">uint8_t</span> ccaCorrThr:<span class="number">2</span>;             <span class="comment">//!&lt;        Threshold for number of correlation peaks in correlator based carrier sense</span></span><br><span class="line">   &#125; ccaOpt;                            <span class="comment">//!&lt;        CCA options</span></span><br><span class="line">   <span class="keyword">int8_t</span> ccaRssiThr;                   <span class="comment">//!&lt;        RSSI threshold for CCA</span></span><br><span class="line">   <span class="keyword">uint8_t</span> __dummy0;</span><br><span class="line">   <span class="keyword">uint8_t</span> numExtEntries;               <span class="comment">//!&lt;        Number of extended address entries</span></span><br><span class="line">   <span class="keyword">uint8_t</span> numShortEntries;             <span class="comment">//!&lt;        Number of short address entries</span></span><br><span class="line">   <span class="keyword">uint32_t</span>* pExtEntryList;             <span class="comment">//!&lt;        Pointer to list of extended address entries</span></span><br><span class="line">   rfc_shortAddrEntry_t *pShortEntryList;<span class="comment">//!&lt;        Pointer to list of short address entries</span></span><br><span class="line">   <span class="keyword">uint64_t</span> localExtAddr;               <span class="comment">//!&lt;        The extended address of the local device</span></span><br><span class="line">   <span class="keyword">uint16_t</span> localShortAddr;             <span class="comment">//!&lt;        The short address of the local device</span></span><br><span class="line">   <span class="keyword">uint16_t</span> localPanID;                 <span class="comment">//!&lt;        The PAN ID of the local device</span></span><br><span class="line">   <span class="keyword">uint16_t</span> __dummy1;</span><br><span class="line">   <span class="keyword">uint8_t</span> __dummy2;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="keyword">uint8_t</span> triggerType:<span class="number">4</span>;            <span class="comment">//!&lt;        The type of trigger</span></span><br><span class="line">      <span class="keyword">uint8_t</span> bEnaCmd:<span class="number">1</span>;                <span class="comment">//!&lt; \brief 0: No alternative trigger command&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: CMD_TRIGGER can be used as an alternative trigger</span></span><br><span class="line">      <span class="keyword">uint8_t</span> triggerNo:<span class="number">2</span>;              <span class="comment">//!&lt;        The trigger number of the CMD_TRIGGER command that triggers this action</span></span><br><span class="line">      <span class="keyword">uint8_t</span> pastTrig:<span class="number">1</span>;               <span class="comment">//!&lt; \brief 0: A trigger in the past is never triggered, or for start of commands, give an error&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: A trigger in the past is triggered as soon as possible</span></span><br><span class="line">   &#125; endTrigger;                        <span class="comment">//!&lt;        Trigger that causes the device to end the Rx operation</span></span><br><span class="line">   <span class="keyword">ratmr_t</span> endTime;                     <span class="comment">//!&lt; \brief Time used together with &lt;code&gt;endTrigger&lt;/code&gt; that causes the device to end the Rx</span></span><br><span class="line">                                        <span class="comment">//!&lt;        operation</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>参数配置函数：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">init_rf_params(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  rfc_CMD_IEEE_RX_t *cmd = (rfc_CMD_IEEE_RX_t *)cmd_ieee_rx_buf;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(cmd_ieee_rx_buf, <span class="number">0x00</span>, RF_CMD_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">  cmd-&gt;commandNo = CMD_IEEE_RX;</span><br><span class="line">  cmd-&gt;status = RF_CORE_RADIO_OP_STATUS_IDLE;</span><br><span class="line">  cmd-&gt;pNextOp = <span class="literal">NULL</span>;</span><br><span class="line">  cmd-&gt;startTime = <span class="number">0x00000000</span>;</span><br><span class="line">  cmd-&gt;startTrigger.triggerType = TRIG_NOW;</span><br><span class="line">  cmd-&gt;condition.rule = COND_NEVER;</span><br><span class="line">  cmd-&gt;channel = RF_CORE_CHANNEL;</span><br><span class="line"></span><br><span class="line">  cmd-&gt;rxConfig.bAutoFlushCrc = <span class="number">1</span>;</span><br><span class="line">  cmd-&gt;rxConfig.bAutoFlushIgn = <span class="number">0</span>;</span><br><span class="line">  cmd-&gt;rxConfig.bIncludePhyHdr = <span class="number">0</span>;</span><br><span class="line">  cmd-&gt;rxConfig.bIncludeCrc = <span class="number">1</span>;</span><br><span class="line">  cmd-&gt;rxConfig.bAppendRssi = <span class="number">1</span>;</span><br><span class="line">  cmd-&gt;rxConfig.bAppendCorrCrc = <span class="number">1</span>;</span><br><span class="line">  cmd-&gt;rxConfig.bAppendSrcInd = <span class="number">0</span>;</span><br><span class="line">  cmd-&gt;rxConfig.bAppendTimestamp = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  cmd-&gt;pRxQ = &amp;rx_data_queue;</span><br><span class="line">  cmd-&gt;pOutput = (rfc_ieeeRxOutput_t *)rf_stats;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IEEE_MODE_PROMISCOUS</span></span><br><span class="line">  cmd-&gt;frameFiltOpt.frameFiltEn = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  cmd-&gt;frameFiltOpt.frameFiltEn = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  cmd-&gt;frameFiltOpt.frameFiltStop = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IEEE_MODE_AUTOACK</span></span><br><span class="line">  cmd-&gt;frameFiltOpt.autoAckEn = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  cmd-&gt;frameFiltOpt.autoAckEn = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  cmd-&gt;frameFiltOpt.slottedAckEn = <span class="number">0</span>;</span><br><span class="line">  cmd-&gt;frameFiltOpt.autoPendEn = <span class="number">0</span>;</span><br><span class="line">  cmd-&gt;frameFiltOpt.defaultPend = <span class="number">0</span>;</span><br><span class="line">  cmd-&gt;frameFiltOpt.bPendDataReqOnly = <span class="number">0</span>;</span><br><span class="line">  cmd-&gt;frameFiltOpt.bPanCoord = <span class="number">0</span>;</span><br><span class="line">  cmd-&gt;frameFiltOpt.maxFrameVersion = <span class="number">2</span>;</span><br><span class="line">  cmd-&gt;frameFiltOpt.bStrictLenFilter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Receive all frame types */</span></span><br><span class="line">  cmd-&gt;frameTypes.bAcceptFt0Beacon = <span class="number">1</span>;</span><br><span class="line">  cmd-&gt;frameTypes.bAcceptFt1Data = <span class="number">1</span>;</span><br><span class="line">  cmd-&gt;frameTypes.bAcceptFt2Ack = <span class="number">1</span>;</span><br><span class="line">  cmd-&gt;frameTypes.bAcceptFt3MacCmd = <span class="number">1</span>;</span><br><span class="line">  cmd-&gt;frameTypes.bAcceptFt4Reserved = <span class="number">1</span>;</span><br><span class="line">  cmd-&gt;frameTypes.bAcceptFt5Reserved = <span class="number">1</span>;</span><br><span class="line">  cmd-&gt;frameTypes.bAcceptFt6Reserved = <span class="number">1</span>;</span><br><span class="line">  cmd-&gt;frameTypes.bAcceptFt7Reserved = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Configure CCA settings */</span></span><br><span class="line">  cmd-&gt;ccaOpt.ccaEnEnergy = <span class="number">1</span>;</span><br><span class="line">  cmd-&gt;ccaOpt.ccaEnCorr = <span class="number">1</span>;</span><br><span class="line">  cmd-&gt;ccaOpt.ccaEnSync = <span class="number">1</span>;</span><br><span class="line">  cmd-&gt;ccaOpt.ccaCorrOp = <span class="number">1</span>;</span><br><span class="line">  cmd-&gt;ccaOpt.ccaSyncOp = <span class="number">0</span>;</span><br><span class="line">  cmd-&gt;ccaOpt.ccaCorrThr = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  cmd-&gt;ccaRssiThr = IEEE_MODE_RSSI_THRESHOLD;</span><br><span class="line"></span><br><span class="line">  cmd-&gt;numExtEntries = <span class="number">0x00</span>;</span><br><span class="line">  cmd-&gt;numShortEntries = <span class="number">0x00</span>;</span><br><span class="line">  cmd-&gt;pExtEntryList = <span class="number">0</span>;</span><br><span class="line">  cmd-&gt;pShortEntryList = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  cmd-&gt;endTrigger.triggerType = TRIG_NEVER;</span><br><span class="line">  cmd-&gt;endTime = <span class="number">0x00000000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* set address filter command */</span></span><br><span class="line">  filter_cmd.commandNo = CMD_IEEE_MOD_FILT;</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;filter_cmd.newFrameFiltOpt, &amp;cmd-&gt;frameFiltOpt, <span class="keyword">sizeof</span>(cmd-&gt;frameFiltOpt));</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;filter_cmd.newFrameTypes, &amp;cmd-&gt;frameTypes, <span class="keyword">sizeof</span>(cmd-&gt;frameTypes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-2-CMD-IEEE-TX命令参数"><a href="#6-2-CMD-IEEE-TX命令参数" class="headerlink" title="6.2 CMD_IEEE_TX命令参数"></a>6.2 CMD_IEEE_TX命令参数</h2><p>数据结构如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMD_IEEE_TX                                             0x2C01</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">RFC_STRUCT</span> <span class="title">rfc_CMD_IEEE_TX_s</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint16_t</span> commandNo;                  <span class="comment">//!&lt;        The command ID number 0x2C01</span></span><br><span class="line">   <span class="keyword">uint16_t</span> status;                     <span class="comment">//!&lt; \brief An integer telling the status of the command. This value is</span></span><br><span class="line">                                        <span class="comment">//!&lt;        updated by the radio CPU during operation and may be read by the</span></span><br><span class="line">                                        <span class="comment">//!&lt;        system CPU at any time.</span></span><br><span class="line">   rfc_radioOp_t *pNextOp;              <span class="comment">//!&lt;        Pointer to the next operation to run after this operation is done</span></span><br><span class="line">   <span class="keyword">ratmr_t</span> startTime;                   <span class="comment">//!&lt;        Absolute or relative start time (depending on the value of &lt;code&gt;startTrigger&lt;/code&gt;)</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="keyword">uint8_t</span> triggerType:<span class="number">4</span>;            <span class="comment">//!&lt;        The type of trigger</span></span><br><span class="line">      <span class="keyword">uint8_t</span> bEnaCmd:<span class="number">1</span>;                <span class="comment">//!&lt; \brief 0: No alternative trigger command&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: CMD_TRIGGER can be used as an alternative trigger</span></span><br><span class="line">      <span class="keyword">uint8_t</span> triggerNo:<span class="number">2</span>;              <span class="comment">//!&lt;        The trigger number of the CMD_TRIGGER command that triggers this action</span></span><br><span class="line">      <span class="keyword">uint8_t</span> pastTrig:<span class="number">1</span>;               <span class="comment">//!&lt; \brief 0: A trigger in the past is never triggered, or for start of commands, give an error&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: A trigger in the past is triggered as soon as possible</span></span><br><span class="line">   &#125; startTrigger;                      <span class="comment">//!&lt;        Identification of the trigger that starts the operation</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="keyword">uint8_t</span> rule:<span class="number">4</span>;                   <span class="comment">//!&lt;        Condition for running next command: Rule for how to proceed</span></span><br><span class="line">      <span class="keyword">uint8_t</span> nSkip:<span class="number">4</span>;                  <span class="comment">//!&lt;        Number of skips if the rule involves skipping</span></span><br><span class="line">   &#125; condition;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="keyword">uint8_t</span> bIncludePhyHdr:<span class="number">1</span>;         <span class="comment">//!&lt; \brief 0: Find PHY header automatically&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: Insert PHY header from the buffer</span></span><br><span class="line">      <span class="keyword">uint8_t</span> bIncludeCrc:<span class="number">1</span>;            <span class="comment">//!&lt; \brief 0: Append automatically calculated CRC&lt;br&gt;</span></span><br><span class="line">                                        <span class="comment">//!&lt;        1: Insert FCS (CRC) from the buffer</span></span><br><span class="line">      <span class="keyword">uint8_t</span> :<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">uint8_t</span> payloadLenMsb:<span class="number">5</span>;          <span class="comment">//!&lt; \brief Most significant bits of payload length. Should only be non-zero to create long</span></span><br><span class="line">                                        <span class="comment">//!&lt;        non-standard packets for test purposes</span></span><br><span class="line">   &#125; txOpt;</span><br><span class="line">   <span class="keyword">uint8_t</span> payloadLen;                  <span class="comment">//!&lt;        Number of bytes in the payload</span></span><br><span class="line">   <span class="keyword">uint8_t</span>* pPayload;                   <span class="comment">//!&lt;        Pointer to payload buffer of size &lt;code&gt;payloadLen&lt;/code&gt;</span></span><br><span class="line">   <span class="keyword">ratmr_t</span> timeStamp;                   <span class="comment">//!&lt;        Time stamp of transmitted frame</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="7-下一步"><a href="#7-下一步" class="headerlink" title="7. 下一步"></a>7. 下一步</h1><p>在代码分析中有两个东西直接忽略掉了，下一步需要补上。  </p>
<ul>
<li>LPM 相关</li>
<li>ENERGEST相关</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Contiki </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Contiki </tag>
            
            <tag> RF </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Contiki OLCD移植]]></title>
      <url>https://xubovey.github.io/2016/10/25/161025-ContikiOlcdPost/</url>
      <content type="html"><![CDATA[<p>硬件环境AMOMCU的CC2650DK V0.2;<br>使用例程contiki/examples/hello-world;<br>经过前一阶段对Contiki的深入了解，目前算是对定时器和进程调用有了一个全面的了解。好吧开始和printf较真。例程中默认输出是到串口的，而我想让他输出到OLCD上。 
如果您有同样的目的或需要可以继续往下看： 
<a id="more"></a></p>
<h1 id="printf与putchar"><a href="#printf与putchar" class="headerlink" title="printf与putchar"></a>printf与putchar</h1><p>contiki中不同平台的输出相关函数多在cpu路径下，以CC26XX为例，在contiki/cpu/cc26xx/putchar.c文件中。<br>文件内包含三个函数：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dbg_send_bytes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>以<code>int putchar(int c)</code>函数为例进行说明，该函数完成将单个数据进行发送。而发送是通过函数中的语句<code>cc26xx_uart_write_byte(c);</code>实现的，那么移植就很简单了只要在该语句出现的地方放上实现相同功能，只不过是输出到LCD的函数即可,此处为<code>olcd_write_byte(c);</code></p>
<h1 id="接口初始化"><a href="#接口初始化" class="headerlink" title="接口初始化"></a>接口初始化</h1><p>同样参考串口的初始化函数，参考<a href="https://xubovey.github.io/2016/10/20/161020-Contiki-platform-main-function-analyse/">从main函数分析contiki</a>,可以找到main函数相关的描述，分析。结论串口初始化在进入main函数的while(1)之前完成，更进一步是在main函数中printf函数执行之前进行的。<br>此处将相应函数放在了led_init之后：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leds_init();</span><br><span class="line">hw_lcd_init();</span><br></pre></td></tr></table></figure></p>
<p>hw_lcd_init函数体根据屏的不同也会有所不同。此处参考了开发板提供的源码，最终代码如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOPinWrite(...) GPIO_writeDio(__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> inited = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*********************LCD init**********************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hw_lcd_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inited)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inited = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    ti_lib_ioc_pin_type_gpio_output(LCD_SCL);</span><br><span class="line">    ti_lib_ioc_pin_type_gpio_output(LCD_SDA);</span><br><span class="line">    ti_lib_ioc_pin_type_gpio_output(LCD_RST);</span><br><span class="line">    ti_lib_ioc_pin_type_gpio_output(LCD_DC);   </span><br><span class="line"></span><br><span class="line">    GPIOPinWrite(LCD_SCL, <span class="number">1</span>);  </span><br><span class="line">    GPIOPinWrite(LCD_RST, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    LCD_DLY_ms(<span class="number">250</span>);</span><br><span class="line"></span><br><span class="line">    GPIOPinWrite(LCD_RST, <span class="number">1</span>);      <span class="comment">//从上电到下面开始初始化要有足够的时间，即等待RC复位完毕   </span></span><br><span class="line"></span><br><span class="line">    LCD_WrCmd(<span class="number">0xae</span>);<span class="comment">//--turn off oled panel</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0x00</span>);<span class="comment">//---set low column address</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0x10</span>);<span class="comment">//---set high column address</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0x40</span>);<span class="comment">//--set start line address  Set Mapping RAM Display Start Line (0x00~0x3F)</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0x81</span>);<span class="comment">//--set contrast control register</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0xcf</span>); <span class="comment">// Set SEG Output Current Brightness</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0xa1</span>);<span class="comment">//--Set SEG/Column Mapping     0xa0左右反置 0xa1正常</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0xc8</span>);<span class="comment">//Set COM/Row Scan Direction   0xc0上下反置 0xc8正常</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0xa6</span>);<span class="comment">//--set normal display</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0xa8</span>);<span class="comment">//--set multiplex ratio(1 to 64)</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0x3f</span>);<span class="comment">//--1/64 duty</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0xd3</span>);<span class="comment">//-set display offset    Shift Mapping RAM Counter (0x00~0x3F)</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0x00</span>);<span class="comment">//-not offset</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0xd5</span>);<span class="comment">//--set display clock divide ratio/oscillator frequency</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0x80</span>);<span class="comment">//--set divide ratio, Set Clock as 100 Frames/Sec</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0xd9</span>);<span class="comment">//--set pre-charge period</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0xf1</span>);<span class="comment">//Set Pre-Charge as 15 Clocks &amp; Discharge as 1 Clock</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0xda</span>);<span class="comment">//--set com pins hardware configuration</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0x12</span>);</span><br><span class="line">    LCD_WrCmd(<span class="number">0xdb</span>);<span class="comment">//--set vcomh</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0x40</span>);<span class="comment">//Set VCOM Deselect Level</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0x20</span>);<span class="comment">//-Set Page Addressing Mode (0x00/0x01/0x02)</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0x02</span>);<span class="comment">//</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0x8d</span>);<span class="comment">//--set Charge Pump enable/disable</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0x14</span>);<span class="comment">//--set(0x10) disable</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0xa4</span>);<span class="comment">// Disable Entire Display On (0xa4/0xa5)</span></span><br><span class="line">    LCD_WrCmd(<span class="number">0xa6</span>);<span class="comment">// Disable Inverse Display On (0xa6/a7) </span></span><br><span class="line">    LCD_WrCmd(<span class="number">0xaf</span>);<span class="comment">//--turn on oled panel</span></span><br><span class="line">    LCD_Fill(<span class="number">0</span>); <span class="comment">//初始化为黑屏</span></span><br><span class="line">    LCD_Set_Pos(<span class="number">0</span>,<span class="number">0</span>); </span><br><span class="line">    lcd_x = <span class="number">0</span>;</span><br><span class="line">    lcd_y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中lcd_x和lcd_y为屏坐标的全局变量，初始化为(0, 0)。LCD_WrCmd函数为开发板提供的源码，直接使用。</p>
<h1 id="olcd-write-byte函数"><a href="#olcd-write-byte函数" class="headerlink" title="olcd_write_byte函数"></a>olcd_write_byte函数</h1><p>上文提到的olcd_write_byte函数体如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_MAX_LINE_COUNT      8</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> lcd_x, lcd_y;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">olcd_write_byte</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">'\n'</span>) &#123; lcd_x = <span class="number">0</span>; lcd_y ++; &#125;<span class="comment">//判断是否为换行符</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(lcd_x &gt; <span class="number">126</span>)&#123;lcd_x = <span class="number">0</span>; lcd_y ++;&#125;<span class="comment">//判断是否需要换行</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(lcd_y &gt; LCD_MAX_LINE_COUNT)<span class="comment">//0~7共8行，判断是否满屏，如果是则清屏</span></span><br><span class="line">       &#123;</span><br><span class="line">           lcd_y = <span class="number">0</span>;</span><br><span class="line">           lcd_x = <span class="number">0</span>;</span><br><span class="line">           LCD_Set_Pos(lcd_x, lcd_y); <span class="comment">//修改坐标为(0， 0)</span></span><br><span class="line">           LCD_Fill(<span class="number">0</span>); <span class="comment">//清屏</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       c -= <span class="number">32</span>; <span class="comment">//用于匹配字库表F6x8，字库从空格字符“ ”开始，“ ”对应32。</span></span><br><span class="line">       <span class="keyword">if</span>(c &gt;= <span class="number">0</span> &amp;&amp; c &lt;= <span class="number">94</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//更新坐标，并将字符写入</span></span><br><span class="line">           LCD_Set_Pos(lcd_x, lcd_y); </span><br><span class="line">           <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">           &#123;</span><br><span class="line">               LCD_WrDat(F6x8[c][i]); <span class="comment">//将数据写入LCD屏，完成字符显示。</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       lcd_x += <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Contiki </category>
            
            <category> OLCD </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Contiki </tag>
            
            <tag> OLCD </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Contiki etimer_process进程分析]]></title>
      <url>https://xubovey.github.io/2016/10/24/161024-Contiki-process-etimer-process/</url>
      <content type="html"><![CDATA[<p>contiki代码分析过程中，发现对进程的多次调用有必要进行一定的分析。<br>在分析etimer_process进程的时候当时有点想不明白，后来想通了就来做个记录。</p>
<a id="more"></a>
<h1 id="etmer-process函数体"><a href="#etmer-process函数体" class="headerlink" title="etmer_process函数体"></a>etmer_process函数体</h1><p>为了方便分析while(1)中代码略去，只保留了PROCESS_*部分。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PROCESS_THREAD(etimer_process, ev, data)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">etimer</span> *<span class="title">t</span>, *<span class="title">u</span>;</span></span><br><span class="line">	</span><br><span class="line">  PROCESS_BEGIN();</span><br><span class="line"></span><br><span class="line">  timerlist = <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    PROCESS_YIELD();</span><br><span class="line">    ...   </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  PROCESS_END();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对代码进行宏展开，代码中注释了重要的分析：<br>第一次执行是在<code>process_start</code>函数中的<code>process_post_synch(p, PROCESS_EVENT_INIT, data);</code>语句完成的。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> <span class="title">process_thread_etimer_process</span><span class="params">(struct pt *etimer_process, <span class="keyword">process_event_t</span> ev, <span class="keyword">process_data_t</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">etimer</span> *<span class="title">t</span>, *<span class="title">u</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//PROCESS_BEGIN start</span></span><br><span class="line">    <span class="keyword">char</span> PT_YIELD_FLAG = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PT_YIELD_FLAG) &#123;;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一次执行进程，lc=0，执行case 0</span></span><br><span class="line">    <span class="comment">//第二次执行进程，lc=__LINE__， 直接执行case __LINE__:</span></span><br><span class="line">    <span class="keyword">switch</span>((process_pt) -&gt; lc) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">    <span class="comment">//PROCESS_BEGIN end</span></span><br><span class="line"></span><br><span class="line">    timerlist = <span class="literal">NULL</span>; <span class="comment">//第一次执行进程，etimer链表初始化。</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//PROCESS_YIELD start</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="comment">//第一次执行进程到此时,执行清零操作；</span></span><br><span class="line">            <span class="comment">//第二次执行进程中，第二次执行while(1)循环时，执行清零操作。</span></span><br><span class="line">            PT_YIELD_FLAG = <span class="number">0</span>; </span><br><span class="line">            (process_pt) -&gt; lc = __LINE__;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> __LINE__: </span><br><span class="line">            <span class="comment">//第一次执行进程到此时，进入if语句，直接退出；</span></span><br><span class="line">            <span class="comment">//第二次执行进程，第二个循环执行到此，进入if语句，直接退出；</span></span><br><span class="line">            <span class="keyword">if</span> (PT_YIELD_FLAG == <span class="number">0</span>) </span><br><span class="line">            &#123; <span class="keyword">return</span> ;&#125;            </span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">//PROCESS_YIELD end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//每次进入进程只执行1次while(1)循环。</span></span><br><span class="line">        函数体代码部分   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//PROCESS_END start       </span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    PT_YIELD_FLAG = <span class="number">0</span>;</span><br><span class="line">    process_pt-&gt;lc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> PT_ENDED;</span><br><span class="line">    <span class="comment">//PROCESS_END  end</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>来看看和常见的程序有什么不一样，我们常见的switch是这样的：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而这里的是这样的：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="comment">/*do something*/</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = __LINE__;</span><br><span class="line">        <span class="keyword">case</span> __LINE__:</span><br><span class="line">        <span class="comment">/*do something*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即便时while(1)和case混合使用了，可是在语法上也是没有错的。<strong>LINE</strong>是内置宏，表示当前代码所在的行号。这里的case用0以外的数字都行，但是是用宏的方式给出的。为了通用性，避免出错，用行号再好不过了。<br>上面etimer_process的代码，采用了case语句成功的解决了1个问题：可以退出while(1)循环，保证进程能按时结束。因此只有main函数中的while(1)能一直循环下去。</p>
]]></content>
      
        <categories>
            
            <category> Contiki </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Contiki </tag>
            
            <tag> YIELD </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Contiki定时器]]></title>
      <url>https://xubovey.github.io/2016/10/21/161021-Contiki-timer/</url>
      <content type="html"><![CDATA[<p>了解contiki进程调度之前有必要先了解下它的定时器使用。因为作为轮询方式执行的函数，除了外部中断，其他事件中断可触发一些任务外，只有了解了才能明白系统是如何进行任务调度的。</p>
<p>Contiki有5种定时器：  </p>
<ul>
<li>clock : 用于处理系统时间，是下面集中timer的基础；而这个是需要platform提供的。</li>
<li>timer : 以clock的tick为单位进行计时，精度最高；</li>
<li>stimer: second timers，秒计时器，比timer计时时间长；timer和stimer库函数可以在中断中调用。</li>
<li>etimer: event timers，事件定时器，定期进行进程的事件调度；被用来上电时等待系统稳定，或进入低功耗模式；</li>
<li>ctimer: callback timers，回调定时器，定期执行进程回调函数，和etimer一样可被用于等待系统稳定和进入低功耗模式；但是更实用的是用在协议栈之类的非进程函数中。</li>
<li>rtimer: real-time timers，实时时钟定时器，用于实时任务的调度，rtimer优先级高于其它任何进程,以保证实时任务被及时调用。</li>
</ul>
<p>本文参考Contiki的<a href="https://github.com/contiki-os/contiki/wiki/Timers" target="_blank" rel="noopener">Timers</a></p>
<a id="more"></a>
<h1 id="1-clock"><a href="#1-clock" class="headerlink" title="1. clock"></a>1. clock</h1><p>clock是需要不同平台(platform)中提供的，Clock Module提供如下API:
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">clock_time_t</span> clock_time(); <span class="comment">// Get the system time. </span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">clock_seconds</span><span class="params">()</span></span>; <span class="comment">// Get the system time in seconds. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clock_delay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> delay)</span></span>; <span class="comment">// Delay the CPU. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clock_wait</span><span class="params">(<span class="keyword">int</span> delay)</span></span>; <span class="comment">// Delay the CPU for a number of clock ticks. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clock_init</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// Initialize the clock module. </span></span><br><span class="line">CLOCK_SECOND; <span class="comment">// The number of ticks per second.</span></span><br></pre></td></tr></table></figure></p>
<p>clock_time返回ticks计数值，而每秒钟有多少个ticks，则由宏定义CLOCK_SECOND决定，clock_time_t多是unsigned，具体因platform而异。<br>clock_seconds是秒计数，返回值为unsigned long型数据（MSP430可计时136年），不同处理器字节数可能不同。<br>delay用于us延时，和wait用于ticks延时（利用clock_time延时）。这两个延时均独占CPU。</p>
<h1 id="2-timer"><a href="#2-timer" class="headerlink" title="2. timer"></a>2. timer</h1><p>timer调用clock的clock_time函数完成各种功能，每一个需要用到timer的地方需要定义一个struct timer数据结构，所有的timer函数均是对这个数据结构的操作，API函数如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_set</span><span class="params">(struct timer *t, <span class="keyword">clock_time_t</span> interval)</span></span>; <span class="comment">// Start the timer.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_reset</span><span class="params">(struct timer *t)</span></span>; <span class="comment">// Restart the timer from the previous expiration time.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_restart</span><span class="params">(struct timer *t)</span></span>; <span class="comment">// Restart the timer from current time. </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timer_expired</span><span class="params">(struct timer *t)</span></span>; <span class="comment">// Check if the timer has expired. </span></span><br><span class="line"><span class="keyword">clock_time_t</span> timer_remaining(struct timer *t); <span class="comment">// Get the time until the timer expires.</span></span><br></pre></td></tr></table></figure></p>
<p>例如串口接收中断函数，判断等待超时：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/timer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer</span> <span class="title">rxtimer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  timer_set(&amp;rxtimer, CLOCK_SECOND / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interrupt(UART1RX_VECTOR)</span><br><span class="line">uart1_rx_interrupt(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(timer_expired(&amp;rxtimer)) &#123;</span><br><span class="line">    <span class="comment">/* Timeout */</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  timer_restart(&amp;rxtimer);</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用前先调用init函数，当前时间（clock_time函数获取）保存在timer-&gt;start中，将设定的时间间隔保存在timer-&gt;interval中，之后每次执行timer_expired函数时用当前时间减去start，然后和interval比较，返回ture/false。<br>timer数据结构
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer</span> &#123;</span></span><br><span class="line">  <span class="keyword">clock_time_t</span> start; <span class="comment">//= unsigned short start;</span></span><br><span class="line">  <span class="keyword">clock_time_t</span> interval; <span class="comment">//= unsigned short interval; </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="3-stimer"><a href="#3-stimer" class="headerlink" title="3. stimer"></a>3. stimer</h1><p>用法和timer一样，只是时间精度和最大时间长度不一样，API函数如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stimer_set</span><span class="params">(struct stimer *t, <span class="keyword">unsigned</span> <span class="keyword">long</span> interval)</span></span>; <span class="comment">// Start the timer.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stimer_reset</span><span class="params">(struct stimer *t)</span></span>; <span class="comment">// Restart the stimer from the previous expiration time.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stimer_restart</span><span class="params">(struct stimer *t)</span></span>; <span class="comment">// Restart the stimer from current time. </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stimer_expired</span><span class="params">(struct stimer *t)</span></span>; <span class="comment">// Check if the stimer has expired. </span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">stimer_remaining</span><span class="params">(struct stimer *t)</span></span>; <span class="comment">// Get the time until the timer expires.</span></span><br></pre></td></tr></table></figure></p>
<h1 id="4-进程事件标识符"><a href="#4-进程事件标识符" class="headerlink" title="4. 进程事件标识符"></a>4. 进程事件标识符</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_EVENT_NONE 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_EVENT_INIT 129</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_EVENT_POLL 130</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_EVENT_EXIT 131</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_EVENT_CONTINUE 133</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_EVENT_MSG 134</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_EVENT_EXITED 135</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_EVENT_TIMER 136</span></span><br></pre></td></tr></table></figure>
<h1 id="5-etimer"><a href="#5-etimer" class="headerlink" title="5. etimer"></a>5. etimer</h1><p>参考<a href="https://my.oschina.net/lgl88911/blog/139463" target="_blank" rel="noopener">Contiki 调度内核不完全介绍</a>
 在进程事件标识符中的PROCESS_EVENT_TIMER就是由etimer所触发的。etimer同样是通过clock_time函数进行时间的设定，比较的。不同的是etiemr必须绑定到一个process上，etimer到期后就触发PROCESS_EVENT_TIMER到对应的process上。etimer基于timer和etimer_process，而etiemr_process只响应两种事件：PROCESS_EVENT_EXITED和PROCESS_EVENT_POLL。<br> PROCESS_EVENT_EXITED告诉etimer_process有进程执行了process_exit，需要从etimer链表中删除相应process的节点；PROCESS_EVENT_POLL事件由etimer_request_poll()驱动，告诉etimer_process，让其检查etimer链表上是否有到期事件发生。  </p>
<blockquote>
<p>当etimer检查到timer到期，会发生PROCESS_EVENT_TIMER到绑定的process，如果发送失败，etimer_process会再自己call etimer_request_poll()来触发一次检查。如果发生成功了etimer就会从timer list中删除，因此一个etimer启动后到期一次就失效了。</p>
</blockquote>
<p> 其API函数与timer类似：</p>
<h2 id="5-1-etimer-API函数"><a href="#5-1-etimer-API函数" class="headerlink" title="5.1 etimer API函数"></a>5.1 etimer API函数</h2> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">etimer_set</span><span class="params">(struct etimer *t, <span class="keyword">clock_time_t</span> interval)</span></span>; <span class="comment">// Start the timer.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">etimer_reset</span><span class="params">(struct etimer *t)</span></span>; <span class="comment">// Restart the timer from the previous expiration time.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">etimer_reset_with_new_interval</span><span class="params">(struct etimer *et, <span class="keyword">clock_time_t</span> interval)</span></span>;<span class="comment">// Reset an event timer with a new interval.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">etimer_restart</span><span class="params">(struct etimer *t)</span></span>; <span class="comment">// Restart the timer from current time. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">etimer_adjust</span><span class="params">(struct etimer *et, <span class="keyword">int</span> td)</span></span>; <span class="comment">// Adjust the expiration time for an event timer.</span></span><br><span class="line"><span class="keyword">clock_time_t</span> etimer_start_time(struct etimer *et);<span class="comment">//Get the start time for the event timer.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">etimer_stop</span><span class="params">(struct etimer *t)</span></span>; <span class="comment">// Stop the timer. </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">etimer_expired</span><span class="params">(struct etimer *t)</span></span>; <span class="comment">// Check if the timer has expired. </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">etimer_pending</span><span class="params">()</span></span>; <span class="comment">// Check if there are any non-expired event timers.</span></span><br><span class="line"><span class="keyword">clock_time_t</span> etimer_next_expiration_time(); <span class="comment">// Get the next event timer expiration time.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">etimer_request_poll</span><span class="params">()</span></span>; <span class="comment">// Inform the etimer library that the system clock has changed.</span></span><br><span class="line">PROCESS_NAME(etimer_process);</span><br><span class="line"> ```  </span><br><span class="line">etimer的数据结构：</span><br><span class="line">``` c</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">etimer</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timer</span> <span class="title">timer</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">etimer</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出etimer与process数据结构类似都是链表形式。并且包含有timer结构类型变量.API函数etimer的也要丰富的多。并且有了一个etimer_process进程。还是举个实际的例子看看：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/etimer.h"</span></span></span><br><span class="line"></span><br><span class="line">PROCESS_THREAD(example_process, ev, data)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">etimer</span> <span class="title">et</span>;</span></span><br><span class="line">  PROCESS_BEGIN();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Delay 1 second */</span></span><br><span class="line">  etimer_set(&amp;et, CLOCK_SECOND);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&amp;et));</span><br><span class="line">    <span class="comment">/* Reset the etimer to trig again in 1 second */</span></span><br><span class="line">    etimer_reset(&amp;et);</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  PROCESS_END();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到timer是用在中断函数中，而etimer是用在进程中的。而进程相关的宏我们已经研究过了。这里的PROCESS_BEGIN和PROCESS_END展开为switch(c){ case 0:{…} };所以只需要看中间部分就好了。<br>由于etimer_set函数是在进程被执行的时候才会被调用的，所以函数的入口参数不需要进程信息，在etimer_set函数中用PROCESS_CURRENT();(其实就是process_current变量，指向当前正在运行的进程)得到当前的进程，并将此变量赋值给et-&gt;p。etimer_set函数执行以下两条语句：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timer_set(&amp;et-&gt;timer, interval);</span><br><span class="line">add_timer(et);</span><br></pre></td></tr></table></figure></p>
<p>第一条是timer数据结构的初始化，包含记录当前时间，并设置时间触发的距离。第二条语句是更新etimer的事件触发点，add_timer做四件事：</p>
<ul>
<li>执行etimer_request_poll();// = process_poll(&amp;etimer_process);</li>
<li>如果新的etimer数据结构不在链表中，则将其加入链表，并将链表指向新加入的数据结构；</li>
<li>将当前进程赋值给新的etimer数据结构的进程指针；</li>
<li>更新etimer事件触发的时间距离。</li>
</ul>
<p>执行process_poll意味着etimer_process进程需要被执行。<br>例如加入新的etimer之前需要在10s后执行某个etimer操作，加入后执行update_timer会更新这个时间为当前链表中的所有etimer的start+interval-now的最小值作为下次发生etimer事件的时间距离next_expiration。很简单，某事件需要在更短的时刻被执行，而事件的执行需要etimer条件，而etimer条件的出现依赖于next_expiration-now是否为0，now是clock_time函数得到的值。</p>
<h2 id="5-2-etimer-process"><a href="#5-2-etimer-process" class="headerlink" title="5.2 etimer_process"></a>5.2 etimer_process</h2><p>etimer_process进程做了两件事：</p>
<ul>
<li>删除已经停掉的或执行出错的进程的etimer在etimer_list上的节点；</li>
<li>如果有计时时间到的进程则，再次执行执行etimer_request_poll();// = process_poll(&amp;etimer_process);
执行etimer_request_poll的作用，参考<a href="https://xubovey.github.io/2016/10/20/161020-Contiki-process-analysis/">Contiki进程分析-struct process</a>。<br>那么etimer_process进程什么时候被添加到进程链表，又什么时候开始执行了呢？<br>答案是在main函数中有<code>process_start(&amp;etimer_process, NULL);</code>语句完成了将etimer_process进程添加到process_list中。</li>
</ul>
<h1 id="6-ctimer"><a href="#6-ctimer" class="headerlink" title="6. ctimer"></a>6. ctimer</h1><p>回调定时器，采用<code>clock_time()</code>获取当前时间，功能与etimer类似，不同的是<code>ctimer_set()</code>函数的入口参数和etimer不一样，多了一个函数指针和数据指针。<br>还有ctimer不适合应用在中断函数中。</p>
<h2 id="6-1-ctimer的API函数"><a href="#6-1-ctimer的API函数" class="headerlink" title="6.1 ctimer的API函数"></a>6.1 ctimer的API函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ctimer_set</span><span class="params">(struct ctimer *c, <span class="keyword">clock_time_t</span> t, <span class="keyword">void</span>(*f)(<span class="keyword">void</span> *), <span class="keyword">void</span> *ptr)</span></span>; <span class="comment">// Start the timer.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ctimer_reset</span><span class="params">(struct ctimer *t)</span></span>; <span class="comment">// Restart the timer from the previous expiration time.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ctimer_restart</span><span class="params">(struct ctimer *t)</span></span>; <span class="comment">// Restart the timer from current time. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ctimer_stop</span><span class="params">(struct ctimer *t)</span></span>; <span class="comment">// Stop the timer. </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ctimer_expired</span><span class="params">(struct ctimer *t)</span></span>; <span class="comment">// Check if the timer has expired.</span></span><br></pre></td></tr></table></figure>
<p>ctimer数据结构如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ctimer</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ctimer</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">etimer</span> <span class="title">etimer</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="keyword">void</span> (*f)(<span class="keyword">void</span> *);</span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在etimer基础上，多了进程指针<code>struct process *p;</code>，函数指针<code>void (*f)(void *);</code>和数据指针<code>void *ptr;</code>。  </p>
<h2 id="6-2-举个例子"><a href="#6-2-举个例子" class="headerlink" title="6.2 举个例子"></a>6.2 举个例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/ctimer.h"</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctimer</span> <span class="title">timer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">callback(<span class="keyword">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">  ctimer_reset(&amp;timer);</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  ctimer_set(&amp;timer, CLOCK_SECOND, callback, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数ctimer_set内容如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ctimer_set(struct ctimer *c, <span class="keyword">clock_time_t</span> t, <span class="keyword">void</span> (*f)(<span class="keyword">void</span> *), <span class="keyword">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">  ctimer_set_with_process(c, t, f, ptr, PROCESS_CURRENT());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续展开
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ctimer_set_with_process(struct ctimer *c, <span class="keyword">clock_time_t</span> t, <span class="keyword">void</span> (*f)(<span class="keyword">void</span> *), <span class="keyword">void</span> *ptr, struct process *p)</span><br><span class="line">&#123;</span><br><span class="line">  PRINTF(<span class="string">"ctimer_set %p %u\n"</span>, c, (<span class="keyword">unsigned</span>)t);</span><br><span class="line">  c-&gt;p = p;  <span class="comment">//将当前进添加到ctimer数据结构中.</span></span><br><span class="line">  c-&gt;f = f;  <span class="comment">//将回调函数添加到ctimer数据结构中.</span></span><br><span class="line">  c-&gt;ptr = ptr; <span class="comment">//将入口参数数据指针添加到ctimer数据结构中.</span></span><br><span class="line">  <span class="keyword">if</span>(initialized) &#123; <span class="comment">//初始化ctimer数据结构总的etimer数据结构.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    #define PROCESS_CONTEXT_BEGIN(p) &#123;\</span></span><br><span class="line"><span class="comment">    struct process *tmp_current = PROCESS_CURRENT();\</span></span><br><span class="line"><span class="comment">    process_current = p</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    PROCESS_CONTEXT_BEGIN(&amp;ctimer_process);</span><br><span class="line"></span><br><span class="line">    etimer_set(&amp;c-&gt;etimer, t);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    #define PROCESS_CONTEXT_END(p) process_current = tmp_current; &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    PROCESS_CONTEXT_END(&amp;ctimer_process);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c-&gt;etimer.timer.interval = t;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  list_add(ctimer_list, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中if语句展开如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(initialized) &#123; <span class="comment">//1表示ctimer_process进程已经被执行.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">tmp_current</span> = <span class="title">PROCESS_CURRENT</span>();</span></span><br><span class="line">  process_current = &amp;ctimer_process;</span><br><span class="line">  etimer_set(&amp;c-&gt;etimer, t);</span><br><span class="line">  process_current = tmp_current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-3-进程切换"><a href="#6-3-进程切换" class="headerlink" title="6.3 进程切换"></a>6.3 进程切换</h2><p>为什么需要进程切换再执行<code>etimer_set</code>函数呢，因为<code>etimer_set</code>会在其链表中添加新节点，并将当前进程添加进来。此处是将<code>ctimer_process</code>进程添加到etimer的链表中，这样对应的etimer事件就不会直接触发最终进程，而是触发<code>ctimer_process</code>进程，再由<code>ctimer_process</code>进程找到对应的回调函数完成事件处理。
<code>ctimer_process</code>进程中核心代码如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    PROCESS_YIELD_UNTIL(ev == PROCESS_EVENT_TIMER);</span><br><span class="line">    <span class="keyword">for</span>(c = list_head(ctimer_list); c != <span class="literal">NULL</span>; c = c-&gt;next) &#123;</span><br><span class="line">      <span class="keyword">if</span>(&amp;c-&gt;etimer == data) &#123;</span><br><span class="line">	      list_remove(ctimer_list, c);</span><br><span class="line">	      PROCESS_CONTEXT_BEGIN(c-&gt;p);</span><br><span class="line">	      <span class="keyword">if</span>(c-&gt;f != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	        c-&gt;f(c-&gt;ptr);</span><br><span class="line">	      &#125;</span><br><span class="line">	      PROCESS_CONTEXT_END(c-&gt;p);</span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>ctimer_process</code>进程是在执行过<code>ctimer_init()</code>函数中启动的。</p>
<h1 id="7-rtimer"><a href="#7-rtimer" class="headerlink" title="7. rtimer"></a>7. rtimer</h1><p>实时时钟定时器，用于处理实时的、紧急的事件，被处理的事件或被调用的处理函数的运行事件必须是可评估的，防止事件处理函数执行事件过长，影响实时性能。和其它几种定时器依赖与tiemr或stimer，rtimer有独立的定时器和调度方式。<br>函数<code>RTIMER_NOW()</code>可获得当前时间，<code>TIMER_SECOND</code>指定1s钟需要多少个tiks。另外rtimer最大的特点是可以抢占其它正在运行的进程。同样也是这个特点，只有中断中可安全使用的process_poll()之类的函数可以被执行，而会引起与其它进程冲突的函数则必须要异步方式执行。<br>rtimer的API函数：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RTIMER_CLOCK_LT(a, b); <span class="comment">// This should give TRUE if 'a' is less than 'b', otherwise false.</span></span><br><span class="line">RTIMER_ARCH_SECOND; <span class="comment">// The number of ticks per second. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtimer_arch_init</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// Initialize the rtimer architecture code. </span></span><br><span class="line"><span class="keyword">rtimer_clock_t</span> rtimer_arch_now(); <span class="comment">// Get the current time. </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rtimer_arch_schedule</span><span class="params">(<span class="keyword">rtimer_clock_t</span> wakeup_time)</span></span>; <span class="comment">//  Schedule a call to rtimer_run_next().</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Contiki </category>
            
            <category> timer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Contiki </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Contiki进程分析-hello world]]></title>
      <url>https://xubovey.github.io/2016/10/20/161020-Contiki-process-analysis-helloworld/</url>
      <content type="html"><![CDATA[<p>Contiki定义了一个链表数据结构<code>struct process{struct process *next; ...;};</code> 用来管理进程，所有需要执行的进程都被注册（通过process_starta函数添加）在这个链表上。这个数据结构中包含进程的状态。<br>链表上的进程根据需要以轮询的方式逐一执行。以printf(“hello,world.\n”)为例,函数体；
<a id="more"></a></p>
<h1 id="1-helloworld进程宏展开"><a href="#1-helloworld进程宏展开" class="headerlink" title="1. helloworld进程宏展开"></a>1. helloworld进程宏展开</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></span><br><span class="line">PROCESS(hello_world_process, <span class="string">"Hello world process"</span>);</span><br><span class="line">AUTOSTART_PROCESSES(&amp;hello_world_process);</span><br><span class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></span><br><span class="line">PROCESS_THREAD(hello_world_process, ev, data)</span><br><span class="line">&#123;</span><br><span class="line">  PROCESS_BEGIN();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello, world\n"</span>);</span><br><span class="line">  </span><br><span class="line">  PROCESS_END();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>宏展开：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> <span class="title">process_thread_hello_world_process</span><span class="params">(struct pt *hello_world_process, <span class="keyword">process_event_t</span> ev, <span class="keyword">process_data_t</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> PT_YIELD_FLAG = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PT_YIELD_FLAG) &#123;;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>((process_pt) -&gt; lc) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Hello world!\n"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    PT_YIELD_FLAG = <span class="number">0</span>;</span><br><span class="line">    process_pt-&gt;lc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> PT_ENDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从宏展开后的代码可以看出，printf语句被执行是发生在<code>(process_pt) -&gt; lc</code>被置1之后的。并且printf语句执行完后return值是PT_ENDED，进程结束。所以只会打印1次。</p>
<h1 id="2-process数据结构"><a href="#2-process数据结构" class="headerlink" title="2. process数据结构"></a>2. process数据结构</h1><p>觉得还是先看下进程数据结构比较好：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">process</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">  <span class="keyword">int</span> (* thread) (struct pt *, <span class="keyword">process_event_t</span>, <span class="keyword">process_data_t</span>);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pt</span> <span class="title">pt</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> state, needspoll;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>next 用来构成链表的将指向其他的process数据结构；</li>
<li>name 字符串，用来存放进程名称的；</li>
<li>thread 函数指针，指向进程的函数体；</li>
<li>pt struct pt数据结构被展开是unsigned short lc; 这个lc就是上面helloworld函数体重语句switch((process_pt) -&gt; lc)中的lc，此值为0时执行printf语句；</li>
<li>state 进程的状态变量，执行process_start函数后该变量被置为PROCESS_STATE_RUNNING；</li>
<li>needspoll 是否需要轮询变量，只有当该变量值为1时，才会轮询到改进程。
要知道每一个进程都会有这样的一个数据结构，其中theread是函数指针，需要指向进程的函数体，这里就是process_thread_hello_world_process函数。  </li>
</ul>
<h1 id="3-对process数据结构进行操作的函数"><a href="#3-对process数据结构进行操作的函数" class="headerlink" title="3. 对process数据结构进行操作的函数"></a>3. 对process数据结构进行操作的函数</h1><h2 id="3-1-process数据结构类型变量定义"><a href="#3-1-process数据结构类型变量定义" class="headerlink" title="3.1 process数据结构类型变量定义"></a>3.1 process数据结构类型变量定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PROCESS(hello_world_process, <span class="string">"Hello world process"</span>);</span><br></pre></td></tr></table></figure>
<p>宏展开：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS(name, strname)				\</span></span><br><span class="line">  PROCESS_THREAD(name, ev, data);			\</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">process</span> <span class="title">name</span> = &#123;</span> <span class="literal">NULL</span>, strname,		\</span><br><span class="line">                          process_thread_#<span class="meta">#name &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上面语句完成了进程函数的声明，同时也定义了process类型变量,process的内容为：</p>
<ul>
<li>next = NULL;</li>
<li>name = “Hello world process”;</li>
<li>thread = process_thread_hello_world_process;//这是函数地址</li>
</ul>
<h2 id="3-2-数据结构成员变量的操作"><a href="#3-2-数据结构成员变量的操作" class="headerlink" title="3.2 数据结构成员变量的操作"></a>3.2 数据结构成员变量的操作</h2><p>对进程相关变量的操作是通过process.c中的一些函数和一些进程原函数实现的。</p>
<ul>
<li>process_start: 启动进程函数，将进程数据结构添加到process_list中，同时state变量置为PROCESS_STATE_RUNNING;再通过PT_INIT()进程原函数将pt置0（这里其实是1个unsigned short型变量）；</li>
<li><p>process_poll: 如果state=PROCESS_STATE_RUNNING/PROCESS_STATE_CALLE就会执行:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;needspoll = <span class="number">1</span>;</span><br><span class="line">poll_requested = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>process_run: 执行进程,如果poll_requested=1就执行do_poll函数，并且总会执行do_event函数。</p>
</li>
<li>do_poll: 进程轮询函数，该函数会轮询process_list中的所有进程，poll_requested清零，同时轮询方式执行所有needspoll=1的进程函数,执行完后needspoll清零,state=PROCESS_STATE_RUNNING, 进程函数的执行用call_process函数进行,ev=PROCESS_EVENT_POLL；</li>
<li><p>call_process: 进程调用函数，该函数会把当前被调用的函数设置为当前进程（process_current）,进程调用前将state=PROCESS_STATE_CALLED，然后通过ret = p-&gt;thread(&amp;p-&gt;pt, ev, data);语句执行进程，然后根据ret返回值改变进程的state值，并根据需要执行exet_process函数，函数体主要部分如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((p-&gt;state &amp; PROCESS_STATE_RUNNING) &amp;&amp;</span><br><span class="line">   p-&gt;thread != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  PRINTF(<span class="string">"process: calling process '%s' with event %d\n"</span>, PROCESS_NAME_STRING(p), ev);</span><br><span class="line">  process_current = p;</span><br><span class="line">  p-&gt;state = PROCESS_STATE_CALLED;</span><br><span class="line">  ret = p-&gt;thread(&amp;p-&gt;pt, ev, data);</span><br><span class="line">  <span class="keyword">if</span>(ret == PT_EXITED ||</span><br><span class="line">     ret == PT_ENDED ||</span><br><span class="line">     ev == PROCESS_EVENT_EXIT) &#123;</span><br><span class="line">    exit_process(p, p);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    p-&gt;state = PROCESS_STATE_RUNNING;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回想process_thread_hello_world_process进程的返回值就是PT_ENDED，所以helloworld只打印了1次；</p>
</li>
<li>exit_process: 进程退出，将进程数据结构从process_list中移除；</li>
</ul>
<p>参考<a href="https://my.oschina.net/lgl88911/blog/139463" target="_blank" rel="noopener">Contiki 调度内核不完全介绍</a><br>举得这个文章写的很不错，介绍进程、事件、进程调度都很好。
搬几块砖：</p>
<blockquote>
<p>process本身是基于event的，当有event触发时一个process才会工作，设置needspoll标志，在无event触发的情况下也要执行process，执行一次process后该标志会被清掉。 </p>
</blockquote>
<blockquote>
<p>contiki event默认支持32个event，以数组的形式管理，先进后出，因此有可能会出现最开始发生的event最后处理。对于同步的event，直接调用process的处理。对于异步event，先将event放到event数组内，在以后的调度中处理event。  </p>
</blockquote>
<p>Event的结构:
<code>`</code> c
struct event_data {
  process_event_t ev;
  process_data_t data;
  struct process *p;
};</p>
<blockquote>
<p>p: 事件发向那个process，process为NULL的话就是广播事件。  </p>
</blockquote>
<blockquote>
<p>Schedule 调度分为两个步骤，一是处理poll，二是处理event。  </p>
</blockquote>
<blockquote>
<p>do_poll() 遍历process list，将其中是poll的process都执行一遍，一次调度执行一次这个动作。  </p>
</blockquote>
<blockquote>
<p>do_event() 去除event数组的最末尾的event，并交由对应的process处理，一次调度只能处理一个event。  </p>
</blockquote>
<blockquote>
<p>call_processcall_process(struct process *p, process_event_t ev, process_data_t data) process处理event的函数，当一个process处理了event后，将被设置为PROCESS_STATE_CALLED状态，那么下次调度就不会被处理，将CPU时间可以让给其它的process。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Contiki </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Contiki </tag>
            
            <tag> Process </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从main函数分析contiki]]></title>
      <url>https://xubovey.github.io/2016/10/20/161020-Contiki-platform-main-function-analyse/</url>
      <content type="html"><![CDATA[<p>使用平台为CC26xx，main函数基本上全部位于contiki下的platform文件夹下的各平台文件夹中，所以尝试从main函数入手分析。
main函数放在平台目录中，相同处理器不同的开发板提供的资源是不一样的，那么是需要新创建一个平台的，然后在里面进行各种定制，所以分析现有平台的设计方法是很有必要的。
main函数中主要包含：</p>
<ul>
<li>*_init(); </li>
<li>process*(); </li>
<li>while(1);</li>
</ul>
<a id="more"></a>
<h1 id="init-部分"><a href="#init-部分" class="headerlink" title="init 部分"></a>init 部分</h1><h2 id="1-配置CC26XX的VIMS工作模式"><a href="#1-配置CC26XX的VIMS工作模式" class="headerlink" title="1. 配置CC26XX的VIMS工作模式"></a>1. 配置CC26XX的VIMS工作模式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Enable flash cache and prefetch. */</span></span><br><span class="line">  ti_lib_vims_mode_set(VIMS_BASE, VIMS_MODE_ENABLED);</span><br><span class="line">  ti_lib_vims_configure(VIMS_BASE, <span class="literal">true</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>在vim.h文件中可以找到：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIMS_MODE_ENABLED  (VIMS_CTL_MODE_CACHE) <span class="comment">// Enabled mode, only USERCODE is cached.</span></span></span><br></pre></td></tr></table></figure></p>
<p>在hw_vim.h文件中找到：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIMS_CTL_MODE_CACHE                                         0x00000001</span></span><br></pre></td></tr></table></figure></p>
<h2 id="2-关中断"><a href="#2-关中断" class="headerlink" title="2. 关中断"></a>2. 关中断</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ti_lib_int_master_disable()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>在ti-lib.h文件中有：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ti_lib_int_master_disable(...)        IntMasterDisable(__VA_ARGS__)</span></span><br></pre></td></tr></table></figure></p>
<h2 id="3-时钟选择"><a href="#3-时钟选择" class="headerlink" title="3. 时钟选择"></a>3. 时钟选择</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set the LF XOSC as the LF system clock source */</span></span><br><span class="line">  oscillators_select_lf_xosc<span class="comment">()</span>;</span><br></pre></td></tr></table></figure>
<h2 id="4-lpm初始化"><a href="#4-lpm初始化" class="headerlink" title="4. lpm初始化"></a>4. lpm初始化</h2><p>通过函数lpm_init()实现。
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">void</span></span><br><span class="line"><span class="selector-tag">lpm_init</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="selector-tag">list_init</span>(modules_list);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Always wake up on any DIO edge detection */</span></span><br><span class="line">  <span class="selector-tag">ti_lib_aon_event_mcu_wake_up_set</span>(AON_EVENT_MCU_WU3, AON_EVENT_IO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>modules_list由LIST(modules_list)定义，展开后如下：
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> void *modules_list_list = NULL;</span><br><span class="line"><span class="keyword">static</span> void ** modules_list = <span class="comment">(**)</span>&amp;modules_list_list;</span><br></pre></td></tr></table></figure></p>
<p>而list_init()是这样的：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">list_init(<span class="keyword">list_t</span> <span class="built_in">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">  *<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>嗯，除非用过，否则这句执行不执行一个样。</p>
<h2 id="5-board-init"><a href="#5-board-init" class="headerlink" title="5.  board_init"></a>5.  board_init</h2><p> board_init();实现，看看做了什么：
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> board_init()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> int_disabled = ti_lib_int_master_disable();<span class="comment">//如果本来就disable则返回true，如果为enable，则disable并返回false。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Turn on relevant PDs */</span></span><br><span class="line">  wakeup_handler();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Enable GPIO peripheral */</span></span><br><span class="line">  ti_lib_prcm_peripheral_run_enable(PRCM_PERIPH_GPIO);<span class="comment">//PRCM(power management and clock control)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Apply settings and wait for them to take effect */</span></span><br><span class="line">  ti_lib_prcm_load_set();</span><br><span class="line">  <span class="keyword">while</span>(!ti_lib_prcm_load_get());</span><br><span class="line"></span><br><span class="line">  lpm_register_module(&amp;srf_module); <span class="comment">//将srf_module添加到lpm的模块链表中。srf_module是个lpm_registered_module_t类型的数据结构，</span></span><br><span class="line"></span><br><span class="line">  configure_unused_pins();<span class="comment">//这个本来不想看的，看到了就写到下面。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Re-enable interrupt if initially enabled. */</span></span><br><span class="line">  <span class="keyword">if</span>(!int_disabled) &#123;<span class="comment">//如果原来为enable，这里进行还原。</span></span><br><span class="line">    ti_lib_int_master_enable();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>configure_unused_pins：看来没用的全关了。为了低功耗，不过写出来是为了知道想要的时候这里需要修改宏。
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">static</span> <span class="selector-tag">void</span></span><br><span class="line"><span class="selector-tag">configure_unused_pins</span>(void)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Turn off 3.3-V domain (lcd/sdcard power, output low) */</span></span><br><span class="line">  <span class="comment">//#define BOARD_IOID_3V3_EN         IOID_13 //demo板上这个pin是LCD的reset。</span></span><br><span class="line">  <span class="selector-tag">ti_lib_ioc_pin_type_gpio_output</span>(BOARD_IOID_3V3_EN);</span><br><span class="line">  <span class="selector-tag">ti_lib_gpio_clear_dio</span>(BOARD_IOID_3V3_EN);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Accelerometer (PWR output low, CSn output, high) */</span></span><br><span class="line">  <span class="selector-tag">ti_lib_ioc_pin_type_gpio_output</span>(BOARD_IOID_ACC_PWR);</span><br><span class="line">  <span class="selector-tag">ti_lib_gpio_clear_dio</span>(BOARD_IOID_ACC_PWR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-GPIO中断初始化"><a href="#6-GPIO中断初始化" class="headerlink" title="6. GPIO中断初始化"></a>6. GPIO中断初始化</h2><p><code>gpio_interrupt_init();</code>函数完成，而这个函数实现的是对handles[]函数指针数组的初始化，全部初始化为NULL，这个需要的时候用<code>gpio_interrupt_register_handler</code>函数进行注册，然后遇到中断的时候会用<code>handles[]()</code>;来完成中断处理。</p>
<h2 id="7-LED初始化"><a href="#7-LED初始化" class="headerlink" title="7. LED初始化"></a>7. LED初始化</h2><p>和GPIO一样需要设置相应端口为输出模式。其它事情不做。</p>
<h2 id="8-时钟初始化"><a href="#8-时钟初始化" class="headerlink" title="8. 时钟初始化"></a>8. 时钟初始化</h2><p>时钟初始化通过三个函数完成：
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">soc_rtc_init</span>(); <span class="comment">//初始化定时器，产生ticks</span></span><br><span class="line"><span class="selector-tag">clock_init</span>(); <span class="comment">//初始化GPT0定时器，配置用于定时的计时器</span></span><br><span class="line"><span class="selector-tag">rtimer_init</span>();<span class="comment">//什么也没做</span></span><br></pre></td></tr></table></figure></p>
<h2 id="9-看门狗初始化"><a href="#9-看门狗初始化" class="headerlink" title="9. 看门狗初始化"></a>9. 看门狗初始化</h2><h2 id="10-产生随机数"><a href="#10-产生随机数" class="headerlink" title="10. 产生随机数"></a>10. 产生随机数</h2><h2 id="11-串口初始化"><a href="#11-串口初始化" class="headerlink" title="11. 串口初始化"></a>11. 串口初始化</h2><h2 id="12-串口输入初始化-serial-line-init"><a href="#12-串口输入初始化-serial-line-init" class="headerlink" title="12. 串口输入初始化 //serial_line_init();"></a>12. 串口输入初始化 //serial_line_init();</h2><h2 id="13-RF和网络协议相关配置初始化"><a href="#13-RF和网络协议相关配置初始化" class="headerlink" title="13. RF和网络协议相关配置初始化"></a>13. RF和网络协议相关配置初始化</h2><h1 id="process-相关"><a href="#process-相关" class="headerlink" title="process 相关"></a>process 相关</h1><p>在serial_line_init();函数中就使用了process_start函数。把其他相关代码整理如下：
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">process_init()<span class="comment">; //清空任务链表</span></span><br><span class="line">process_start(<span class="name">&amp;serial_line_process</span>, NULL)<span class="comment">;//serial_line_init();展开得到。</span></span><br><span class="line"></span><br><span class="line">process_start(<span class="name">&amp;etimer_process</span>, NULL)<span class="comment">;</span></span><br><span class="line">ctimer_init()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">process_start(<span class="name">&amp;sensors_process</span>, NULL)<span class="comment">;</span></span><br><span class="line">autostart_start(<span class="name">autostart_processes</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>看了官方文档，跟了代码，总算搞明白了autostart_process，process_start, autostart_start, process_list之间的关系了。autostart_process是进程指针数组，包含需要直接启动的进程，process_list是进程链表所有启动的任务均在这个链表上。autostart_start最终调用了process_start，不同的是autostart_start的入口参数是个进程指针数组，可以同时启动多个进程，而process_start入口参数是进程指针，把某个进程添加到进程链表中。<br>process_start函数不能使进程被执行。</p>
<h2 id="process-start"><a href="#process-start" class="headerlink" title="process start"></a>process start</h2><ul>
<li>将进程添加到链表process_list的最前端，并将该进程的地址赋值给process_list。</li>
<li>将进程状态设置为<code>PROCESS_STATE_RUNNING</code>;</li>
<li>执行<code>PT_INIT(&amp;p-&gt;pt);</code>将进程的pt值设置为0。</li>
</ul>
<h1 id="while-1"><a href="#while-1" class="headerlink" title="while(1)"></a>while(1)</h1><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while(<span class="number">1</span>) &#123;</span><br><span class="line">  uint8_t r<span class="comment">;</span></span><br><span class="line">  do &#123;</span><br><span class="line">    r = process_run()<span class="comment">;</span></span><br><span class="line">    watchdog_periodic()<span class="comment">;</span></span><br><span class="line">  &#125; while(r &gt; <span class="number">0</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Drop to some low power mode */</span></span><br><span class="line">  lpm_drop()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>while(1)中执行1次<code>process_run</code>，然后执行<code>lpm_drop()</code>.</p>
]]></content>
      
        <categories>
            
            <category> contiki </category>
            
            <category> c </category>
            
        </categories>
        
        
        <tags>
            
            <tag> contiki </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言宏定义的使用]]></title>
      <url>https://xubovey.github.io/2016/10/17/161017-MacroBaseStaTion/</url>
      <content type="html"><![CDATA[<p>最近研究Contiki，看别人教程上分析宏定义，一层又一层，所以给自己充个电。
本文参考了hbprotoss的博客的<a href="http://hbprotoss.github.io/posts/cyu-yan-hong-de-te-shu-yong-fa-he-ji-ge-keng.html" target="_blank" rel="noopener">C语言宏的特殊用法和几个坑</a>和Anker’s的Blog的<a href="http://www.cnblogs.com/Anker/p/3418792.html" target="_blank" rel="noopener">C语言宏高级用法 [总结]</a>
<a id="more"></a></p>
<h1 id="用的最多的"><a href="#用的最多的" class="headerlink" title="用的最多的"></a>用的最多的</h1><p>最基础的也是最简单的，我们把常数替换成一个更容易识别的大写字符组合：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 100</span></span><br></pre></td></tr></table></figure></p>
<p>然后程序预处理的时候会把所有的BUFFER_SIZE替换成100。</p>
<h2 id="小基础"><a href="#小基础" class="headerlink" title="小基础"></a>小基础</h2><p>宏定义中的换行需要用反斜杠<code>\</code></p>
<h1 id="稍高级点的"><a href="#稍高级点的" class="headerlink" title="稍高级点的"></a>稍高级点的</h1><p>我们会把比较函数用宏定义，在预处理阶段进行替换，从而避免程序执行过程中有大量的函数调用而降低性能，专业点讲就是牺牲容量提高性能。例如：
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ #define min(<span class="keyword">X</span>, <span class="keyword">Y</span>)  ((<span class="keyword">X</span>) &lt; (<span class="keyword">Y</span>) ? (<span class="keyword">X</span>) : (<span class="keyword">Y</span>))</span><br></pre></td></tr></table></figure></p>
<p>这里的X，Y是宏的参数，称作宏参数。<br>功能很简单，找到并返回较小的。这里没有说值或数，因为X，Y可以是任何东西：变量，数字，字符，函数。所以这里的括号用的很多，括号的增加会避免运算符优先级问题引起的错误，其它类似宏的定义中同样需要认真、小心对待。举个例子：a=b*min(c,d);在min中有括号和没括号的时候是不一样的。试试看，想想看。<br>但是使用中应当注意，尽量不要用函数展开宏，例如，建设x为1个函数，那么这个宏展开后将被调用两次，有可能两次的结果是不一样的，这样就会带来逻辑错误，遇到这种情况时可以用变量对函数做缓存然后再对宏进行展开。</p>
<h1 id="他人踩的坑"><a href="#他人踩的坑" class="headerlink" title="他人踩的坑"></a>他人踩的坑</h1><p>看人代码时发现有的代码行都没有分号结尾，为了代码美观给加上后有报错，很是不爽。例如下面这个
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define SKIP_SPACES(p, limit)  \</span></span><br><span class="line">     &#123; char *lim = (limit);         <span class="string">\</span></span><br><span class="line">       <span class="keyword">while</span> (p &lt; lim) &#123;            <span class="string">\</span></span><br><span class="line">         <span class="keyword">if</span> (*p++ != <span class="string">' '</span>) &#123;         <span class="string">\</span></span><br><span class="line">           p--; <span class="keyword">break</span>; &#125;&#125;&#125;</span><br><span class="line">...省略很多...</span><br><span class="line"><span class="keyword">if</span> (*p != <span class="number">0</span>)</span><br><span class="line">   SKIP_SPACES (p, limit);</span><br><span class="line"><span class="keyword">else</span> ...</span><br></pre></td></tr></table></figure></p>
<p>为了看清问题等效成这样的
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (*p != 0)</span><br><span class="line">&#123;</span><br><span class="line">    SKIP_SPACES (p, <span class="built_in">limit</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">else</span> ...</span><br></pre></td></tr></table></figure></p>
<p>问题出来了if和else之间多了个分号，导致else没有if。<br>实际中还有这样的：
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ #define min(<span class="keyword">X</span>, <span class="keyword">Y</span>)  ((<span class="keyword">X</span>) &lt; (<span class="keyword">Y</span>) ? (<span class="keyword">X</span>) : (<span class="keyword">Y</span>));</span><br></pre></td></tr></table></figure></p>
<p>那么引用的时候就可能是：
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">c</span> = min(a,b)</span><br></pre></td></tr></table></figure></p>
<p>有没有很奇怪的感觉。<br>所以,if语句需要有{}。每行代码要有分号结束。然而如果if后没有{},还想正确呢，怎么处理呢。请继续看<br>C语言中常用的是while(){},很少用do{}while(),如果在宏中外面加上do{}while(0)会怎样呢？
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define SKIP_SPACES(p, limit)  \</span></span><br><span class="line">     <span class="keyword">do</span></span><br><span class="line">     &#123; char *lim = (limit);         <span class="string">\</span></span><br><span class="line">       <span class="keyword">while</span> (p &lt; lim) &#123;            <span class="string">\</span></span><br><span class="line">         <span class="keyword">if</span> (*p++ != <span class="string">' '</span>) &#123;         <span class="string">\</span></span><br><span class="line">           p--; <span class="keyword">break</span>; &#125;&#125;&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>if语句展开后：
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(*p != 0)</span></span><br><span class="line">   <span class="keyword">do</span></span><br><span class="line">   &#123; char *lim = <span class="comment">(limit)</span>;         </span><br><span class="line">     <span class="keyword">while</span> <span class="comment">(p &lt; lim)</span> &#123;            </span><br><span class="line">       <span class="keyword">if</span> <span class="comment">(*p++ != ' ')</span> &#123;         </span><br><span class="line">         p--; break; &#125;&#125;&#125;<span class="keyword">while</span><span class="comment">(0)</span>;</span><br><span class="line">else</span><br></pre></td></tr></table></figure></p>
<p>哈哈完美解决。最后的while(0)吃掉了分号，if和else重新组成了一个完整的语句。</p>
<h1 id="宏的递归引用"><a href="#宏的递归引用" class="headerlink" title="宏的递归引用"></a>宏的递归引用</h1><p>不做详细介绍，只说明预处理中只展开一次。  </p>
<h1 id="宏参数预处理"><a href="#宏参数预处理" class="headerlink" title="宏参数预处理"></a>宏参数预处理</h1><p>阅读一些C代码的时候会看到一些宏定义中有#或者##。那么怎么解读呢
其实就是特殊符合：# ##</p>
<h2 id=""><a href="#" class="headerlink" title="#"></a>#</h2><p>在一个宏中的参数前面使用一个#,预处理器会把这个参数转换为一个字符数组。<br>简化理解：#是“字符串化”的意思，出现在宏定义中的#是把跟在后面的参数转换成一个字符串。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define ERROR_LOG(<span class="function"><span class="keyword">module</span>)   <span class="title">fprintf</span><span class="params">(stderr,<span class="string">"error: "</span>#module<span class="string">"\n"</span>)</span></span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function"><span class="title">ERROR_LOG</span><span class="params">(<span class="string">"add"</span>)</span>; //转换为 <span class="title">fprintf</span><span class="params">(stderr,<span class="string">"error: "</span>add<span class="string">"\n"</span>)</span>;</span></span><br><span class="line"><span class="function"><span class="title">ERROR_LOG</span><span class="params">(devied =<span class="number">0</span>)</span>; //转换为 <span class="title">fprintf</span><span class="params">(stderr,<span class="string">"error: devied=0\n"</span>)</span>;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="-1"><a href="#-1" class="headerlink" title="#"></a>#</h2><p>“##”是一种分隔连接方式，它的作用是先分隔，然后进行强制连接。<br>在普通的宏定义中，预处理器一般把空格解释成分段标志，对于每一段和前面比较，相同的就被替换。但是这样做的结果是，被替换段之间存在一些空格。如果我们不希望出现这些空格，就可以通过添加一些##来替代空格。例如：
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define TYPE1(type,name)   type name_##type##_type</span><br><span class="line">TYPE1(int, c); <span class="comment">//转换为：int 　name_int_type ; </span></span><br><span class="line">#define TYPE2(type,name)   type name##_##type##_type</span><br><span class="line">TYPE2(int, d); <span class="comment">//转换为：int 　d_int_type ;</span></span><br></pre></td></tr></table></figure></p>
<p>参考：
<a href="http://www.cnblogs.com/Anker/p/3418792.html" target="_blank" rel="noopener">C语言宏高级用法 [总结]</a><br><a href="http://hbprotoss.github.io/posts/cyu-yan-hong-de-te-shu-yong-fa-he-ji-ge-keng.html" target="_blank" rel="noopener">C语言宏的特殊用法和几个坑</a></p>
<hr>
]]></content>
      
        <categories>
            
            <category> C语言 </category>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Makefile入门]]></title>
      <url>https://xubovey.github.io/2016/10/14/16-10-Makefile/</url>
      <content type="html"><![CDATA[<p>在写Contiki_Makefile-prj的时候，想到可能有的人一点都不了解Makefile,所以写此文以供入门。</p>
<a id="more"></a>
<h1 id="keil-vVersion环境的编译过程"><a href="#keil-vVersion环境的编译过程" class="headerlink" title="keil vVersion环境的编译过程"></a>keil vVersion环境的编译过程</h1><p>了解Makefile，主要是针对没有接触过linux的人，但是了解window下的单片机，dsp等开发环境。因此先简单说下window下的开发环境，以keil uVersion4为例。  </p>
<h2 id="新建工程完成编译"><a href="#新建工程完成编译" class="headerlink" title="新建工程完成编译"></a>新建工程完成编译</h2><p>新建工程/打开已有工程，我们常用的操作是在项目名称上“右键”-&gt;<code>Build Target</code>（或<code>Rebuild Target</code>），然后等待编译完成 ，输出hex文件或bin文件。<br>那么这个<code>Build Target</code>执行了具体做了什么呢。我试了一下<code>Rebuild Target</code>：
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Rebuild target <span class="string">'Target 1'</span></span><br><span class="line">compiling misc<span class="selector-class">.c</span>...</span><br><span class="line">...此处省略很多行</span><br><span class="line">compiling system_stm32f10x<span class="selector-class">.c</span>...</span><br><span class="line">assembling startup_stm32f10x_hd<span class="selector-class">.s</span>...</span><br><span class="line">compiling main<span class="selector-class">.c</span>...</span><br><span class="line">compiling adc<span class="selector-class">.c</span>...</span><br><span class="line">compiling adc_calc<span class="selector-class">.c</span>...</span><br><span class="line">linking...</span><br><span class="line">Program Size: Code=<span class="number">7812</span> RO-data=<span class="number">1312</span> RW-data=<span class="number">76</span> ZI-data=<span class="number">3676</span>  </span><br><span class="line">FromELF: creating hex file...</span><br><span class="line"><span class="string">"ADC_TEST.axf"</span> - <span class="number">0</span> Error(s), <span class="number">0</span> Warning(s).</span><br></pre></td></tr></table></figure></p>
<p>可以看到只有：compiling、assembling、linking、elf转hex。简单来说就是：编译、链接。<br>编译：就是将.c文件，.asm/.s文件编译，输出机器可识别的二进制文件.o文件；
链接：编译是把单个文件编译成一个个的.o文件，还不能直接给机器，因为程序中的包含、调用、变量的空间分配等还没有做好，也就是说这个二进制文件与处理器内的存储空间之间没有建立起一一对应的关系，所以就需要把所有的二进制文件一个一个连起来，把不同的代码放到不同的区域。所有相关的.o文件组合成一个新的文件.elf文件，不过通常需要的是hex，bin文件，所以看到了就是最后的FromELF,完成最终hex文件的创建。</p>
<h2 id="编译过程-参数研究"><a href="#编译过程-参数研究" class="headerlink" title="编译过程-参数研究"></a>编译过程-参数研究</h2><p>不管是哪种平台这个编译、链接的过程是不会改变的。只是针对不同平台有不同的编译器，这个平台包括操作系统和处理器。
例如上面的keil，自带编译器，针对不同的处理器：51，cortex-M3\M4\A…，Arm7，Arm9等，因其机器内数据位宽不一致，指令集也有所差异，所以编译器处理的时候是有所去别的。为了一探究竟，下面研究下keil的配置界面参数：  </p>
<h3 id="C-C-参数"><a href="#C-C-参数" class="headerlink" title="C/C++参数"></a>C/C++参数</h3><p>在<code>Project</code>窗口的项目根节点上右键选择<code>Option For Target</code>选项，进入C/C++选项页，最后有一项是<code>complier control string</code>，其中内容如下：
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-c --cpu Cortex-M3 -g -O0 --apcs=interwork -I.<span class="symbol">\s</span>ource<span class="symbol">\l</span>ib </span><br><span class="line">-I D:<span class="symbol">\K</span>eil<span class="symbol">\A</span>RM<span class="symbol">\R</span>V31<span class="symbol">\I</span>NC </span><br><span class="line">-I D:<span class="symbol">\K</span>eil<span class="symbol">\A</span>RM<span class="symbol">\C</span>MSIS<span class="symbol">\I</span>nclude </span><br><span class="line">-I D:<span class="symbol">\K</span>eil<span class="symbol">\A</span>RM<span class="symbol">\I</span>nc<span class="symbol">\S</span>T<span class="symbol">\S</span>TM32F10x </span><br><span class="line">-o "*.o" --omf_browse "*.crf" --depend "*.d"</span><br></pre></td></tr></table></figure></p>
<p>其中-I是用来描述包含路径的，第一行的<code>-I</code>后面的路径是在C/C++选项页的Include Paths栏所显示的内容。
第一行指定CPU等信息，最后一行指定编译输出文件信息。</p>
<h3 id="ASM参数"><a href="#ASM参数" class="headerlink" title="ASM参数"></a>ASM参数</h3><p>同样在Asm选项页的<code>Assembler control string</code>有如下内容：
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-cpu Cortex-M3 -g --apcs=interwork </span><br><span class="line">-I D:<span class="symbol">\K</span>eil<span class="symbol">\A</span>RM<span class="symbol">\R</span>V31<span class="symbol">\I</span>NC </span><br><span class="line">-I D:<span class="symbol">\K</span>eil<span class="symbol">\A</span>RM<span class="symbol">\C</span>MSIS<span class="symbol">\I</span>nclude </span><br><span class="line">-I D:<span class="symbol">\K</span>eil<span class="symbol">\A</span>RM<span class="symbol">\I</span>nc<span class="symbol">\S</span>T<span class="symbol">\S</span>TM32F10x </span><br><span class="line">--list "*.lst" --xref -o "*.o" --depend "*.d"</span><br></pre></td></tr></table></figure></p>
<p>这里主要描述将.o文件链接输出为可执行文件。</p>
<p>简单点说这个配置界面的参数就是告诉编译器以什么样的规则编译源代码。  </p>
<p>那么能不能把这些配置信息给提取出来放置到一个专门的文件中去呢，然后执行某个命令/操作，自动完成编译、链接。答案当然是可以的。
并且这个可以并不区分windows或linux。</p>
<h1 id="采用Makefile的helloworld函数"><a href="#采用Makefile的helloworld函数" class="headerlink" title="采用Makefile的helloworld函数"></a>采用Makefile的helloworld函数</h1><p>还记得上面提到的编译、链接吗，我们使用两个命令代替：<code>make</code>、<code>link</code>。同时呢，摆脱开发环境keil的限制，需要安装GCC工具，这个gcc就是可以将C文件变化成二进制文件的工具，叫编译器或工具链。</p>
<h2 id="GCC工具安装"><a href="#GCC工具安装" class="headerlink" title="GCC工具安装"></a>GCC工具安装</h2><p>安装完成后，windows下<code>win+R</code>打开终端命令行，输入<code>make -v</code>，查看版本信息：
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;make -v</span><br><span class="line">GNU Make <span class="number">3.81</span></span><br><span class="line">Copyright (C) <span class="number">2006</span>  Free Software Foundation, Inc.</span><br><span class="line">This <span class="keyword">is</span> free software; see the source <span class="keyword">for</span> copying conditions.</span><br><span class="line">There <span class="keyword">is</span> NO warranty; <span class="keyword">not</span> even <span class="keyword">for</span> MERCHANTABILITY <span class="keyword">or</span> FITNESS <span class="keyword">FOR</span> A</span><br><span class="line">PARTICULAR PURPOSE.</span><br><span class="line"></span><br><span class="line">This <span class="keyword">program</span> built <span class="keyword">for</span> i386-pc-mingw32</span><br></pre></td></tr></table></figure></p>
<h2 id="源文件和Makefile"><a href="#源文件和Makefile" class="headerlink" title="源文件和Makefile"></a>源文件和Makefile</h2><p>ok，有了编译工具了，那么下面就写个hello函数进行测试吧。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"hello!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#Makefile</span></span><br><span class="line"><span class="symbol">all:</span> hello</span><br><span class="line"><span class="symbol">hello:</span> hello.c</span><br><span class="line"><span class="meta">#gcc前面是tab，不是空格，Makefile中的命令前需要有tab，如果编辑器会把tab转换成空格是不可以的。</span></span><br><span class="line">	gcc -o hello hello.c</span><br><span class="line"><span class="symbol">clean:</span></span><br><span class="line"><span class="meta">#rm前面是tab，不是空格</span></span><br><span class="line">	rm -rf *.o</span><br></pre></td></tr></table></figure>
<h2 id="编译、运行"><a href="#编译、运行" class="headerlink" title="编译、运行"></a>编译、运行</h2><p>这里有了源文件，有了Makefile，有个编译工具，下面就看看怎么了编译运行吧。
windows下<code>win+r</code>，输入<code>cmd</code>开命令行,找到并进入hello.c和Makefile所在工程目录。<br>命令行下使用  </p>
<ul>
<li>cd name打开某个文件夹，输入文件夹名字时用tab键可自动补全；</li>
<li>cd ..返回上一级文件夹；</li>
<li>e:直接进入E盘根目录。</li>
<li>dir 显示当前文件夹下的文件或文件夹列表</li>
</ul>
<p>进入工程目录后，执行<code>make</code>命令,得到以下结果：
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span><span class="symbol">F:</span>\make-hello&gt;make</span><br><span class="line"><span class="variable">$ </span>gcc -o hello hello.c</span><br></pre></td></tr></table></figure></p>
<p>执行<code>dir</code>命令，发下文件夹中多了个hello.exe
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dir</span><br><span class="line">Makefile  hello<span class="selector-class">.c</span>  hello.exe</span><br></pre></td></tr></table></figure></p>
<p>命令行输入<code>hello.exe</code>/<code>hello</code>执行输出文件，可得到如下结果：
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">F:</span>\make-hello&gt;hello</span><br><span class="line">hello!</span><br></pre></td></tr></table></figure></p>
<p>到这里，我们完成了一个简单函数的编译、运行。没有使用集成开发环境。  </p>
<h2 id="Makefile里做了什么"><a href="#Makefile里做了什么" class="headerlink" title="Makefile里做了什么"></a>Makefile里做了什么</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">all: hello</span><br><span class="line">hello: hello.c</span><br><span class="line">	gcc -o hello hello.c</span><br><span class="line">clean:</span><br><span class="line">	rm -rf *.o</span><br></pre></td></tr></table></figure>
<p>Makefile中的<code>all</code>是个伪目标，make命令执行的时候会先来找到all，之后找到all中的hello。hello是个目标，它依赖于后面的hello.c，这个目标中包含命令行<code>gcc -o hello hello.c</code>。<br>这里的<code>-o</code>是不是很像keil中的<code>-o &quot;*.o&quot; --omf_browse &quot;*.crf&quot; --depend &quot;*.d&quot;</code>。这个<code>o</code>是output的缩写，用于设定输出信息的。而前面的gcc就是编译命令了，执行的make来触发这个命令。如果有多个文件相互依赖的话还会触发link操作。</p>
<p>如果想更深入的看懂理解Makefile，需要去学习Makefile的语法，命令，函数。</p>
<hr>
]]></content>
      
        <categories>
            
            <category> C语言 </category>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Makefile </tag>
            
            <tag> C </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Contiki_Makefile-prj]]></title>
      <url>https://xubovey.github.io/2016/10/14/Contiki-Makefile-prj/</url>
      <content type="html"><![CDATA[<p>参考：<a href="http://www.cnblogs.com/chineseboy/archive/2014/07.html" target="_blank" rel="noopener">鱼竿的传说</a>
鱼竿的文档里写的思路很清晰，理解Makefile包含关系，点到为止，代码阅读中遇到宏进行搜索替换。逐层拨开云团迷雾，看清代码的本质，很是受用。</p>
<p>本篇同样从Makefile入手，了解示例工程中的Makefile的区别和平台上Makefile文件的移植自定义方法。文中有误之处迭代更新吧。</p>
<a id="more"></a>
<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><blockquote>
<p>其实Makefile种类一说，这个是我自己创的—-其实它们都是makefile文件了。Contiki OS一共分为5类makefile文件：</p>
<ul>
<li>Makefile 位于工程目录下，文件中包含Makefile.include</li>
<li>Makefile.include 执行make命令的时候会展开Makefile.include,其中根据make命令的参数判断TARGET是什么，不指定则采用默认值，选择完后会展开Makefile.\$(TARGET)。</li>
<li>Makefile.\$(TARGET) 这个target其实就是指定用的开发平台是什么，再简单点说就是哪个开发板，其中会包含有哪些外设资源的。同时也会设定使用的处理器是什么Makefile.\$(CPU)，相同处理器的可以有不同的开发板，所以target与CPU就分开了。</li>
<li>Makefile.\$(CPU) CPU会指定采用什么样的编译器，会包含一些底层的东西。</li>
<li>Makefile.\$(APP) APP是Makefile.include中指定的，这些app由contiki提供，当然了，也可以用户自定定义的。就像操作系统上的应用程序一样。<br>其中第一个“Makefile”，我称之为Makefile-prj，因为它与实际工程有关，并且位于项目工程目录下。更详细的介绍可参见./contiki/doc/build-system.txt。</li>
</ul>
</blockquote>
<h1 id="Makefile-prj"><a href="#Makefile-prj" class="headerlink" title="Makefile-prj"></a>Makefile-prj</h1><p>以helloworld和CC26XX两个例程为例，比较Makefile的区别。<br>helloworld目录下：
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./examples/heloworld/Makefile</span><br><span class="line"></span><br><span class="line">CONTIKI_PROJECT = hello-world</span><br><span class="line"><span class="section">all: <span class="variable">$(CONTIKI_PROJECT)</span></span></span><br><span class="line"></span><br><span class="line">CONTIKI = ../..</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CONTIKI)</span>/Makefile.<span class="keyword">include</span></span><br></pre></td></tr></table></figure></p>
<p>CC26XX目录下：
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">./examples/CC26XX/Makefile</span><br><span class="line"></span><br><span class="line">DEFINES+=PROJECT_CONF_H=\<span class="string">"project-conf.h\"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CONTIKI_PROJECT = cc26xx-demo</span></span><br><span class="line"><span class="string">all: <span class="variable">$(CONTIKI_PROJECT)</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CONTIKI_WITH_IPV6 = 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CONTIKI = ../..</span></span><br><span class="line"><span class="string">include <span class="variable">$(CONTIKI)</span>/Makefile.include</span></span><br></pre></td></tr></table></figure></p>
<p>比较发现CC26XX目录下的Makefile文件中多了两行
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEFINES+=PROJECT_CONF_H=\<span class="string">"project-conf.h\"</span></span><br><span class="line"><span class="string">CONTIKI_WITH_IPV6 = 1</span></span><br></pre></td></tr></table></figure></p>
<p>CONTIKI_WITH_IPV6应该是用于指定包含IPv6协议栈的。不做展开。<br>那么project-conf.h文件中是什么呢：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROJECT_CONF_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROJECT_CONF_H_</span></span><br><span class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* Disable button shutdown functionality */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUTTON_SENSOR_CONF_ENABLE_SHUTDOWN    0</span></span><br><span class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* Enable the ROM bootloader */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROM_BOOTLOADER_ENABLE                 1</span></span><br><span class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* Change to match your configuration */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IEEE802154_CONF_PANID            0xABCD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RF_CORE_CONF_CHANNEL                 25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RF_BLE_CONF_ENABLED                   1</span></span><br><span class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* PROJECT_CONF_H_ */</span></span></span><br><span class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></span><br></pre></td></tr></table></figure></p>
<p>看样子是配置了一些用户自定义的信息，主要与外设相关。</p>
<p>觉得不够充分，那么就再看看2530和2538的吧：
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/examples/CC2530dk/Makefile</span><br><span class="line">CONTIKI_PROJECT = hello-world blink-hello timer-test sensors-demo</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(CONTIKI_PROJECT)</span> </span></span><br><span class="line"></span><br><span class="line">CONTIKI = ../..</span><br><span class="line">CONTIKI_WITH_RIME = 1</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CONTIKI)</span>/Makefile.<span class="keyword">include</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/examples/CC2538dk/Makefile</span><br><span class="line">DEFINES+=PROJECT_CONF_H=\<span class="string">"project-conf.h\"</span></span><br><span class="line"><span class="string">CONTIKI_PROJECT = cc2538-demo</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">all: <span class="variable">$(CONTIKI_PROJECT)</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CONTIKI = ../..</span></span><br><span class="line"><span class="string">CONTIKI_WITH_RIME = 1</span></span><br><span class="line"><span class="string">include <span class="variable">$(CONTIKI)</span>/Makefile.include</span></span><br></pre></td></tr></table></figure>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta-keyword">/examples/</span>CC2538dk/project_conf.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROJECT_CONF_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROJECT_CONF_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETSTACK_CONF_RDC     nullrdc_driver</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* PROJECT_CONF_H_ */</span></span></span><br></pre></td></tr></table></figure>
<p>嗯，看样子就是一些配置了。至于怎么配置暂时还不能很自如的说明。<br>但是除了project_conf.h文件，就是CONTIKI_PROJECT变量的配置了。
这个变量很简单，就是Makefile所在文件夹，当前文件夹中有几个*.c文件全部写在后面就可以了。<br>貌似没什么干货，不过算是简单的整理了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cnblogs.com/chineseboy/p/3844981.html" target="_blank" rel="noopener">contiki makefile框架分析 &lt; contiki学习之一 &gt;</a><br><a href="https://github.com/contiki-os/contiki/blob/master/doc/build-system.txt" target="_blank" rel="noopener">build-system.txt</a> </p>
<hr>
]]></content>
      
        <categories>
            
            <category> Contiki </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Makefile </tag>
            
            <tag> Contiki </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Contiki CC2650 HelloWorld例程测试]]></title>
      <url>https://xubovey.github.io/2016/10/12/Contiki-2650-helloworld/</url>
      <content type="html"><![CDATA[<h1 id="使用开发板完成HelloWorld的串口输出"><a href="#使用开发板完成HelloWorld的串口输出" class="headerlink" title="使用开发板完成HelloWorld的串口输出"></a>使用开发板完成HelloWorld的串口输出</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a><a href="http://www.contiki-os.org/start.html" target="_blank" rel="noopener">环境搭建</a></h2><ul>
<li>基于win10开发，所以要安装虚拟机VMware；</li>
<li>官网下载ubuntu虚拟机镜像；</li>
<li>启动虚拟机, 输入密码<code>user</code>完成登陆；</li>
<li>下载最新版contiki系统源文件；</li>
<li>下载CC26xx系列固件。</li>
</ul>
<a id="more"></a>
<h3 id="VMware安装"><a href="#VMware安装" class="headerlink" title="VMware安装"></a>VMware安装</h3><p>自行百度完成。</p>
<h3 id="下载ubuntu"><a href="#下载ubuntu" class="headerlink" title="下载ubuntu"></a>下载ubuntu</h3><p><a href="https://sourceforge.net/projects/contiki/files/Instant%20Contiki/" target="_blank" rel="noopener">下载地址</a>
一共2.2G左右。 用户名：；密码。 </p>
<h3 id="下载Contiki3-0"><a href="#下载Contiki3-0" class="headerlink" title="下载Contiki3.0"></a>下载Contiki3.0</h3><p>3.0版本是当前最新版。在虚拟机中打开终端，进入<code>home</code>目录，执行如下操作。
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/contiki-os/contiki.git​git</span><br></pre></td></tr></table></figure></p>
<p>下载完成后，虚拟机自带的contiki可以删除。</p>
<h3 id="下载CC26XX固件"><a href="#下载CC26XX固件" class="headerlink" title="下载CC26XX固件"></a>下载CC26XX固件</h3><p>进入contiki-&gt;cpu-&gt;cc26xx-cc13xx&gt;lib-&gt;cc26xxware目录，
执行如下操作：
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/contiki-os/cc26xxware.git</span><br></pre></td></tr></table></figure></p>
<p>等待完成固件的下载。</p>
<p>至此环境搭建完成。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>ubuntu系统中，终端界面下打开contiki-&gt;example-&gt;hello-world。<br>分布执行以下命令：
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">make <span class="attribute">TARGET</span>=srf06-cc26xx <span class="attribute">BOARD</span>=srf06/cc26xx</span><br></pre></td></tr></table></figure></p>
<p>在hello-world文件加下可以得到编译处的hex，bin文件。</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>将二进制文件复制到win10下，
启动<code>FlashProgrammer 2</code>(1不支持26xx)。<br>电脑连接开发板串口、仿真器后可在<code>FlashProgrammer 2</code>下看到连接2650设备。
在<code>FlashImages</code>选项中选择signal,并通过Browse按钮选择复制出的二进制文件。 
Actions选型中保留默认配置，单击<code>Play</code>按钮,即可完成下载。</p>
<p>打开串口终端，选择与开发板串口对应的串口-打开。然后按下开发板复位键，即可在终端上看到打印信息。
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">【2016-10-12</span> <span class="number">16</span><span class="string">:31:41:028】Starting</span> <span class="string">Contiki-3.x-2881-g3f4436b</span></span><br><span class="line"><span class="string">With</span> <span class="string">DriverLib</span> <span class="string">v0.46593</span></span><br><span class="line"><span class="string">TI</span> <span class="string">SmartRF06EB</span> <span class="string">+</span> <span class="string">CC26xx</span> <span class="string">EM</span></span><br><span class="line"><span class="attr"> Net:</span> <span class="string">sicslowpan</span></span><br><span class="line"><span class="attr"> MAC:</span> <span class="string">CSMA</span></span><br><span class="line"><span class="attr"> RDC:</span> <span class="string">ContikiMAC,</span> <span class="string">Channel</span> <span class="string">Check</span> <span class="attr">Interval:</span> <span class="number">16</span> <span class="string">ticks</span></span><br><span class="line"><span class="attr"> RF:</span> <span class="string">Channel</span> <span class="number">25</span></span><br><span class="line"> <span class="string">Node</span> <span class="attr">ID:</span> <span class="number">15107</span></span><br></pre></td></tr></table></figure></p>
<hr>
]]></content>
      
        <categories>
            
            <category> Contiki </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Contiki </tag>
            
            <tag> CC2650 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[启程]]></title>
      <url>https://xubovey.github.io/2016/10/02/Start/</url>
      <content type="html"><![CDATA[<h1 id="hexo-travis-搭建blog平台"><a href="#hexo-travis-搭建blog平台" class="headerlink" title="hexo + travis 搭建blog平台"></a>hexo + travis 搭建blog平台</h1><p>平台的折腾暂时告一段落。经过一番摸索、碰壁；参考大家的教程终于实现了git push后网页自动更新了。这里记录几个坑。</p>
<a id="more"></a>
<h1 id="坑一"><a href="#坑一" class="headerlink" title="坑一"></a>坑一</h1><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>因为此前没有用过，对其不熟悉所以走了许多弯路。不会创建branch，不会更新，
可能是因为用过svn的缘故把，以为commit之后就应该在github上有更新的，结果什么反应都没有
后来经过深入了解才知道git是本地操作只有push后才能更新到github上。</p>
<h1 id="坑二"><a href="#坑二" class="headerlink" title="坑二"></a>坑二</h1><p>travis一直在master分支上，并且报错无法找到.travis.yml文件。
这个坑跳得比较深，因为看别人写的教程里面在travis网页上显示的都是dev或者source之类的分支上进行的操作，而自己弄的却是在master分支
困惑、郁闷好久。经过一番摸索，发现需要几个条件：</p>
<ol>
<li>需要创建的是独立分支；git –orphan dev-name (是不是必须为独立分支不太确定)</li>
<li>github上需要在仓库-&gt;设置里将默认分支选择为新创建的分支；</li>
<li>在新创建的分支里面需要上传.travis.yml配置文件。</li>
</ol>
<h1 id="自己给挖的坑"><a href="#自己给挖的坑" class="headerlink" title="自己给挖的坑"></a>自己给挖的坑</h1><ul>
<li>修改.travis.yml文件的时候用户名、用户邮箱忘记修改；  </li>
<li>使用的环境变量名称与文件中不一致；</li>
<li>用了evn，仓库的地址前面加了https://<br>当然这些问题都是在travis的log信息中发现的，因为总是在执行git相关操作的时候出错。</li>
</ul>
<h1 id="加油"><a href="#加油" class="headerlink" title="加油"></a>加油</h1><p>无论如何经过不断的努力总算成功了。以后换电脑还是啥都方便了。<br>只需要装git bash，vs code+md插件就可以了。<br>改天还要把图片库给弄了。</p>
]]></content>
      
        <categories>
            
            <category> hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[开始-用hexo+Travis部署独立博文]]></title>
      <url>https://xubovey.github.io/2016/09/25/hexo_install/</url>
      <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>需要安装：</p>
<ul>
<li><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">node</a> :选择Windows Installer (.msi)，32bit/64bit根据系统自行选择。
安装完成后就可以用npm进行其他插件的安装了，安装时以管理员身份安装。</li>
<li>hexo </li>
<li><a href="https://git-scm.com/" target="_blank" rel="noopener">git</a></li>
<li><a href="http://rubyinstaller.org/downloads/" target="_blank" rel="noopener">Ruby</a></li>
<li>Travis CI  </li>
</ul>
<a id="more"></a>
<p>需要注册：</p>
<ul>
<li>github</li>
</ul>
<h2 id="nodejs安装"><a href="#nodejs安装" class="headerlink" title="nodejs安装"></a>nodejs安装</h2><p>下载适合的<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">hexo</a>，右键以管理员身份运行，之后选择默认安装即可。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">$ v.5.0</span><br></pre></td></tr></table></figure></p>
<p>表示安装成功。进入下一步。</p>
<h2 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo --save</span><br></pre></td></tr></table></figure>
<p>hexo初始化，我在D盘新建了文件夹hexo，进入文件夹，按下shift+右键&gt;在此处打开命令窗口。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果使用git方式进行部署，执行npm install hexo-deployer-git –save来安装所需的插件
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>然后打开_config文件，找到最后，做以下更改：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="comment"># Deployment</span></span><br><span class="line">$ <span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">$ deploy:</span><br><span class="line">$  <span class="built_in">type</span>: git</span><br><span class="line">$  repo: https://github.com/XuBovey/xubovey.github.io.git</span><br><span class="line">$  branch: master</span><br></pre></td></tr></table></figure></p>
<p>git配置身份信息:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.email <span class="string">"you@example.com"</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"Your name"</span></span><br></pre></td></tr></table></figure>
<h2 id="hexo预览-发布"><a href="#hexo预览-发布" class="headerlink" title="hexo预览/发布"></a>hexo预览/发布</h2><p>生成/预览/发布，命令如下：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g //生成</span><br><span class="line">$ hexo s //预览，hexo s --debug可以调试</span><br><span class="line">$ hexo d //发布</span><br></pre></td></tr></table></figure></p>
<p>执行<code>hexo s</code>后，在浏览器中输入<a href="http://localhost:4000/." target="_blank" rel="noopener">http://localhost:4000/.</a>即可预览编辑的页面。<br>因为前面已经配置过git的身份信息，因此可以直接发布，输入命令：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></p>
<h2 id="添加新博文"><a href="#添加新博文" class="headerlink" title="添加新博文"></a>添加新博文</h2><p>执行命令：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="built_in">test</span> //<span class="built_in">test</span>为新添加文章的名字</span><br></pre></td></tr></table></figure></p>
<p>然后可以在根目录下的source/_post文件夹找到test.md文件，打开后内容如下：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ---</span><br><span class="line">$ title: <span class="built_in">test</span></span><br><span class="line">$ date: 2016-09-25 21:32:53</span><br><span class="line">$ tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>hexo有很多主题可供选择，<a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">知乎</a>
上有相关的哪些好的提问，选择喜欢的主题参考以下命令git到本地。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure></p>
<p>安装与配置步骤创建的hexo文件夹下的_config文件，做以下修改：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="comment"># Extensions</span></span><br><span class="line">$ <span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line">$ <span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line">$ <span class="comment">#theme: landscape</span></span><br><span class="line">$ theme: next</span><br></pre></td></tr></table></figure></p>
<p>关于主题的配置可以参考next的<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">说明文档</a>，比较详细。
阅读说明文件时只强调一点：其中的站点配置未见就是刚才用的_config文件。而主题中的_config才是主题配置文件。</p>
<blockquote>
<p>为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。  </p>
</blockquote>
<p>至此已经可以了，只要每次添加新的文章后执行如下命令即可完成，生成和发布：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure></p>
<h2 id="走的更远"><a href="#走的更远" class="headerlink" title="走的更远"></a>走的更远</h2><h3 id="不同电脑如何进行同步"><a href="#不同电脑如何进行同步" class="headerlink" title="不同电脑如何进行同步"></a>不同电脑如何进行同步</h3><h3 id="用Travis进行自动更新github-pages"><a href="#用Travis进行自动更新github-pages" class="headerlink" title="用Travis进行自动更新github pages"></a>用Travis进行自动更新github pages</h3><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://xuanwo.org/2015/03/26/hexo-intor/" target="_blank" rel="noopener">史上最详细的Hexo博客搭建图文教程</a></li>
<li><a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo不同风格</a></li>
<li><a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">hexo不同风格比较-看家顺张的回答</a></li>
<li><a href="http://www.jianshu.com/p/q81RER" target="_blank" rel="noopener">献给写作者的 Markdown 新手指南</a></li>
<li><a href="http://notes.iissnan.com/2016/publishing-github-pages-with-travis-ci/" target="_blank" rel="noopener">使用 Travis CI 自动更新 GitHub Pages</a></li>
<li><a href="https://wizardforcel.gitbooks.io/markdown-simple-world/content/7.html" target="_blank" rel="noopener">用markdown写博客：hexo + gitcafe</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
