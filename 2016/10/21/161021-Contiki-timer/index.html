<!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css"><meta name="keywords" content="Contiki,"><link rel="alternate" href="/atom.xml" title="Bovey's Blog" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2"><meta name="description" content="了解contiki进程调度之前有必要先了解下它的定时器使用。因为作为轮询方式执行的函数，除了外部中断，其他事件中断可触发一些任务外，只有了解了才能明白系统是如何进行任务调度的。 Contiki有5种定时器：    clock : 用于处理系统时间，是下面集中timer的基础；而这个是需要platform提供的。 timer : 以clock的tick为单位进行计时，精度最高； stimer: se"><meta name="keywords" content="Contiki"><meta property="og:type" content="article"><meta property="og:title" content="Contiki定时器"><meta property="og:url" content="https://xubovey.github.io/2016/10/21/161021-Contiki-timer/index.html"><meta property="og:site_name" content="Bovey&#39;s Blog"><meta property="og:description" content="了解contiki进程调度之前有必要先了解下它的定时器使用。因为作为轮询方式执行的函数，除了外部中断，其他事件中断可触发一些任务外，只有了解了才能明白系统是如何进行任务调度的。 Contiki有5种定时器：    clock : 用于处理系统时间，是下面集中timer的基础；而这个是需要platform提供的。 timer : 以clock的tick为单位进行计时，精度最高； stimer: se"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2019-08-27T02:27:47.160Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Contiki定时器"><meta name="twitter:description" content="了解contiki进程调度之前有必要先了解下它的定时器使用。因为作为轮询方式执行的函数，除了外部中断，其他事件中断可触发一些任务外，只有了解了才能明白系统是如何进行任务调度的。 Contiki有5种定时器：    clock : 用于处理系统时间，是下面集中timer的基础；而这个是需要platform提供的。 timer : 以clock的tick为单位进行计时，精度最高； stimer: se"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",sidebar:{position:"right",display:"always",offset:12,offset_float:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://xubovey.github.io/2016/10/21/161021-Contiki-timer/"><title>Contiki定时器 | Bovey's Blog</title></head><body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-right page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Bovey's Blog</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">点滴</p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://xubovey.github.io/2016/10/21/161021-Contiki-timer/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="xu.bovey"><meta itemprop="description" content=""><meta itemprop="image" content="https://raw.githubusercontent.com/XuBovey/xubovey.github.io/source/blog_images/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Bovey's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Contiki定时器</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-21T10:25:59+00:00">2016-10-21</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Contiki/" itemprop="url" rel="index"><span itemprop="name">Contiki</span></a></span> ， <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Contiki/timer/" itemprop="url" rel="index"><span itemprop="name">timer</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>了解contiki进程调度之前有必要先了解下它的定时器使用。因为作为轮询方式执行的函数，除了外部中断，其他事件中断可触发一些任务外，只有了解了才能明白系统是如何进行任务调度的。</p><p>Contiki有5种定时器：</p><ul><li>clock : 用于处理系统时间，是下面集中timer的基础；而这个是需要platform提供的。</li><li>timer : 以clock的tick为单位进行计时，精度最高；</li><li>stimer: second timers，秒计时器，比timer计时时间长；timer和stimer库函数可以在中断中调用。</li><li>etimer: event timers，事件定时器，定期进行进程的事件调度；被用来上电时等待系统稳定，或进入低功耗模式；</li><li>ctimer: callback timers，回调定时器，定期执行进程回调函数，和etimer一样可被用于等待系统稳定和进入低功耗模式；但是更实用的是用在协议栈之类的非进程函数中。</li><li>rtimer: real-time timers，实时时钟定时器，用于实时任务的调度，rtimer优先级高于其它任何进程,以保证实时任务被及时调用。</li></ul><p>本文参考Contiki的<a href="https://github.com/contiki-os/contiki/wiki/Timers" target="_blank" rel="noopener">Timers</a></p><a id="more"></a><h1 id="1-clock"><a href="#1-clock" class="headerlink" title="1. clock"></a>1. clock</h1><p>clock是需要不同平台(platform)中提供的，Clock Module提供如下API:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">clock_time_t</span> clock_time(); <span class="comment">// Get the system time. </span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">clock_seconds</span><span class="params">()</span></span>; <span class="comment">// Get the system time in seconds. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clock_delay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> delay)</span></span>; <span class="comment">// Delay the CPU. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clock_wait</span><span class="params">(<span class="keyword">int</span> delay)</span></span>; <span class="comment">// Delay the CPU for a number of clock ticks. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clock_init</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// Initialize the clock module. </span></span><br><span class="line">CLOCK_SECOND; <span class="comment">// The number of ticks per second.</span></span><br></pre></td></tr></table></figure><p></p><p>clock_time返回ticks计数值，而每秒钟有多少个ticks，则由宏定义CLOCK_SECOND决定，clock_time_t多是unsigned，具体因platform而异。<br>clock_seconds是秒计数，返回值为unsigned long型数据（MSP430可计时136年），不同处理器字节数可能不同。<br>delay用于us延时，和wait用于ticks延时（利用clock_time延时）。这两个延时均独占CPU。</p><h1 id="2-timer"><a href="#2-timer" class="headerlink" title="2. timer"></a>2. timer</h1><p>timer调用clock的clock_time函数完成各种功能，每一个需要用到timer的地方需要定义一个struct timer数据结构，所有的timer函数均是对这个数据结构的操作，API函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_set</span><span class="params">(struct timer *t, <span class="keyword">clock_time_t</span> interval)</span></span>; <span class="comment">// Start the timer.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_reset</span><span class="params">(struct timer *t)</span></span>; <span class="comment">// Restart the timer from the previous expiration time.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_restart</span><span class="params">(struct timer *t)</span></span>; <span class="comment">// Restart the timer from current time. </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timer_expired</span><span class="params">(struct timer *t)</span></span>; <span class="comment">// Check if the timer has expired. </span></span><br><span class="line"><span class="keyword">clock_time_t</span> timer_remaining(struct timer *t); <span class="comment">// Get the time until the timer expires.</span></span><br></pre></td></tr></table></figure><p></p><p>例如串口接收中断函数，判断等待超时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/timer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer</span> <span class="title">rxtimer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  timer_set(&amp;rxtimer, CLOCK_SECOND / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interrupt(UART1RX_VECTOR)</span><br><span class="line">uart1_rx_interrupt(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(timer_expired(&amp;rxtimer)) &#123;</span><br><span class="line">    <span class="comment">/* Timeout */</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  timer_restart(&amp;rxtimer);</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>使用前先调用init函数，当前时间（clock_time函数获取）保存在timer-&gt;start中，将设定的时间间隔保存在timer-&gt;interval中，之后每次执行timer_expired函数时用当前时间减去start，然后和interval比较，返回ture/false。<br>timer数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer</span> &#123;</span></span><br><span class="line">  <span class="keyword">clock_time_t</span> start; <span class="comment">//= unsigned short start;</span></span><br><span class="line">  <span class="keyword">clock_time_t</span> interval; <span class="comment">//= unsigned short interval; </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><h1 id="3-stimer"><a href="#3-stimer" class="headerlink" title="3. stimer"></a>3. stimer</h1><p>用法和timer一样，只是时间精度和最大时间长度不一样，API函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stimer_set</span><span class="params">(struct stimer *t, <span class="keyword">unsigned</span> <span class="keyword">long</span> interval)</span></span>; <span class="comment">// Start the timer.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stimer_reset</span><span class="params">(struct stimer *t)</span></span>; <span class="comment">// Restart the stimer from the previous expiration time.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stimer_restart</span><span class="params">(struct stimer *t)</span></span>; <span class="comment">// Restart the stimer from current time. </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stimer_expired</span><span class="params">(struct stimer *t)</span></span>; <span class="comment">// Check if the stimer has expired. </span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">stimer_remaining</span><span class="params">(struct stimer *t)</span></span>; <span class="comment">// Get the time until the timer expires.</span></span><br></pre></td></tr></table></figure><p></p><h1 id="4-进程事件标识符"><a href="#4-进程事件标识符" class="headerlink" title="4. 进程事件标识符"></a>4. 进程事件标识符</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_EVENT_NONE 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_EVENT_INIT 129</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_EVENT_POLL 130</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_EVENT_EXIT 131</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_EVENT_CONTINUE 133</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_EVENT_MSG 134</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_EVENT_EXITED 135</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_EVENT_TIMER 136</span></span><br></pre></td></tr></table></figure><h1 id="5-etimer"><a href="#5-etimer" class="headerlink" title="5. etimer"></a>5. etimer</h1><p>参考<a href="https://my.oschina.net/lgl88911/blog/139463" target="_blank" rel="noopener">Contiki 调度内核不完全介绍</a> 在进程事件标识符中的PROCESS_EVENT_TIMER就是由etimer所触发的。etimer同样是通过clock_time函数进行时间的设定，比较的。不同的是etiemr必须绑定到一个process上，etimer到期后就触发PROCESS_EVENT_TIMER到对应的process上。etimer基于timer和etimer_process，而etiemr_process只响应两种事件：PROCESS_EVENT_EXITED和PROCESS_EVENT_POLL。<br> PROCESS_EVENT_EXITED告诉etimer_process有进程执行了process_exit，需要从etimer链表中删除相应process的节点；PROCESS_EVENT_POLL事件由etimer_request_poll()驱动，告诉etimer_process，让其检查etimer链表上是否有到期事件发生。</p><blockquote><p>当etimer检查到timer到期，会发生PROCESS_EVENT_TIMER到绑定的process，如果发送失败，etimer_process会再自己call etimer_request_poll()来触发一次检查。如果发生成功了etimer就会从timer list中删除，因此一个etimer启动后到期一次就失效了。</p></blockquote><p> 其API函数与timer类似：</p><h2 id="5-1-etimer-API函数"><a href="#5-1-etimer-API函数" class="headerlink" title="5.1 etimer API函数"></a>5.1 etimer API函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">etimer_set</span><span class="params">(struct etimer *t, <span class="keyword">clock_time_t</span> interval)</span></span>; <span class="comment">// Start the timer.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">etimer_reset</span><span class="params">(struct etimer *t)</span></span>; <span class="comment">// Restart the timer from the previous expiration time.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">etimer_reset_with_new_interval</span><span class="params">(struct etimer *et, <span class="keyword">clock_time_t</span> interval)</span></span>;<span class="comment">// Reset an event timer with a new interval.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">etimer_restart</span><span class="params">(struct etimer *t)</span></span>; <span class="comment">// Restart the timer from current time. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">etimer_adjust</span><span class="params">(struct etimer *et, <span class="keyword">int</span> td)</span></span>; <span class="comment">// Adjust the expiration time for an event timer.</span></span><br><span class="line"><span class="keyword">clock_time_t</span> etimer_start_time(struct etimer *et);<span class="comment">//Get the start time for the event timer.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">etimer_stop</span><span class="params">(struct etimer *t)</span></span>; <span class="comment">// Stop the timer. </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">etimer_expired</span><span class="params">(struct etimer *t)</span></span>; <span class="comment">// Check if the timer has expired. </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">etimer_pending</span><span class="params">()</span></span>; <span class="comment">// Check if there are any non-expired event timers.</span></span><br><span class="line"><span class="keyword">clock_time_t</span> etimer_next_expiration_time(); <span class="comment">// Get the next event timer expiration time.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">etimer_request_poll</span><span class="params">()</span></span>; <span class="comment">// Inform the etimer library that the system clock has changed.</span></span><br><span class="line">PROCESS_NAME(etimer_process);</span><br><span class="line"> ```  </span><br><span class="line">etimer的数据结构：</span><br><span class="line">``` c</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">etimer</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timer</span> <span class="title">timer</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">etimer</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出etimer与process数据结构类似都是链表形式。并且包含有timer结构类型变量.API函数etimer的也要丰富的多。并且有了一个etimer_process进程。还是举个实际的例子看看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/etimer.h"</span></span></span><br><span class="line"></span><br><span class="line">PROCESS_THREAD(example_process, ev, data)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">etimer</span> <span class="title">et</span>;</span></span><br><span class="line">  PROCESS_BEGIN();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Delay 1 second */</span></span><br><span class="line">  etimer_set(&amp;et, CLOCK_SECOND);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&amp;et));</span><br><span class="line">    <span class="comment">/* Reset the etimer to trig again in 1 second */</span></span><br><span class="line">    etimer_reset(&amp;et);</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  PROCESS_END();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看到timer是用在中断函数中，而etimer是用在进程中的。而进程相关的宏我们已经研究过了。这里的PROCESS_BEGIN和PROCESS_END展开为switch(c){ case 0:{…} };所以只需要看中间部分就好了。<br>由于etimer_set函数是在进程被执行的时候才会被调用的，所以函数的入口参数不需要进程信息，在etimer_set函数中用PROCESS_CURRENT();(其实就是process_current变量，指向当前正在运行的进程)得到当前的进程，并将此变量赋值给et-&gt;p。etimer_set函数执行以下两条语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timer_set(&amp;et-&gt;timer, interval);</span><br><span class="line">add_timer(et);</span><br></pre></td></tr></table></figure><p></p><p>第一条是timer数据结构的初始化，包含记录当前时间，并设置时间触发的距离。第二条语句是更新etimer的事件触发点，add_timer做四件事：</p><ul><li>执行etimer_request_poll();// = process_poll(&amp;etimer_process);</li><li>如果新的etimer数据结构不在链表中，则将其加入链表，并将链表指向新加入的数据结构；</li><li>将当前进程赋值给新的etimer数据结构的进程指针；</li><li>更新etimer事件触发的时间距离。</li></ul><p>执行process_poll意味着etimer_process进程需要被执行。<br>例如加入新的etimer之前需要在10s后执行某个etimer操作，加入后执行update_timer会更新这个时间为当前链表中的所有etimer的start+interval-now的最小值作为下次发生etimer事件的时间距离next_expiration。很简单，某事件需要在更短的时刻被执行，而事件的执行需要etimer条件，而etimer条件的出现依赖于next_expiration-now是否为0，now是clock_time函数得到的值。</p><h2 id="5-2-etimer-process"><a href="#5-2-etimer-process" class="headerlink" title="5.2 etimer_process"></a>5.2 etimer_process</h2><p>etimer_process进程做了两件事：</p><ul><li>删除已经停掉的或执行出错的进程的etimer在etimer_list上的节点；</li><li>如果有计时时间到的进程则，再次执行执行etimer_request_poll();// = process_poll(&amp;etimer_process); 执行etimer_request_poll的作用，参考<a href="https://xubovey.github.io/2016/10/20/161020-Contiki-process-analysis/">Contiki进程分析-struct process</a>。<br>那么etimer_process进程什么时候被添加到进程链表，又什么时候开始执行了呢？<br>答案是在main函数中有<code>process_start(&amp;etimer_process, NULL);</code>语句完成了将etimer_process进程添加到process_list中。</li></ul><h1 id="6-ctimer"><a href="#6-ctimer" class="headerlink" title="6. ctimer"></a>6. ctimer</h1><p>回调定时器，采用<code>clock_time()</code>获取当前时间，功能与etimer类似，不同的是<code>ctimer_set()</code>函数的入口参数和etimer不一样，多了一个函数指针和数据指针。<br>还有ctimer不适合应用在中断函数中。</p><h2 id="6-1-ctimer的API函数"><a href="#6-1-ctimer的API函数" class="headerlink" title="6.1 ctimer的API函数"></a>6.1 ctimer的API函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ctimer_set</span><span class="params">(struct ctimer *c, <span class="keyword">clock_time_t</span> t, <span class="keyword">void</span>(*f)(<span class="keyword">void</span> *), <span class="keyword">void</span> *ptr)</span></span>; <span class="comment">// Start the timer.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ctimer_reset</span><span class="params">(struct ctimer *t)</span></span>; <span class="comment">// Restart the timer from the previous expiration time.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ctimer_restart</span><span class="params">(struct ctimer *t)</span></span>; <span class="comment">// Restart the timer from current time. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ctimer_stop</span><span class="params">(struct ctimer *t)</span></span>; <span class="comment">// Stop the timer. </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ctimer_expired</span><span class="params">(struct ctimer *t)</span></span>; <span class="comment">// Check if the timer has expired.</span></span><br></pre></td></tr></table></figure><p>ctimer数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ctimer</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ctimer</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">etimer</span> <span class="title">etimer</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="keyword">void</span> (*f)(<span class="keyword">void</span> *);</span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>在etimer基础上，多了进程指针<code>struct process *p;</code>，函数指针<code>void (*f)(void *);</code>和数据指针<code>void *ptr;</code>。</p><h2 id="6-2-举个例子"><a href="#6-2-举个例子" class="headerlink" title="6.2 举个例子"></a>6.2 举个例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/ctimer.h"</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctimer</span> <span class="title">timer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">callback(<span class="keyword">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">  ctimer_reset(&amp;timer);</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  ctimer_set(&amp;timer, CLOCK_SECOND, callback, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数ctimer_set内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ctimer_set(struct ctimer *c, <span class="keyword">clock_time_t</span> t, <span class="keyword">void</span> (*f)(<span class="keyword">void</span> *), <span class="keyword">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">  ctimer_set_with_process(c, t, f, ptr, PROCESS_CURRENT());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>继续展开</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ctimer_set_with_process(struct ctimer *c, <span class="keyword">clock_time_t</span> t, <span class="keyword">void</span> (*f)(<span class="keyword">void</span> *), <span class="keyword">void</span> *ptr, struct process *p)</span><br><span class="line">&#123;</span><br><span class="line">  PRINTF(<span class="string">"ctimer_set %p %u\n"</span>, c, (<span class="keyword">unsigned</span>)t);</span><br><span class="line">  c-&gt;p = p;  <span class="comment">//将当前进添加到ctimer数据结构中.</span></span><br><span class="line">  c-&gt;f = f;  <span class="comment">//将回调函数添加到ctimer数据结构中.</span></span><br><span class="line">  c-&gt;ptr = ptr; <span class="comment">//将入口参数数据指针添加到ctimer数据结构中.</span></span><br><span class="line">  <span class="keyword">if</span>(initialized) &#123; <span class="comment">//初始化ctimer数据结构总的etimer数据结构.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    #define PROCESS_CONTEXT_BEGIN(p) &#123;\</span></span><br><span class="line"><span class="comment">    struct process *tmp_current = PROCESS_CURRENT();\</span></span><br><span class="line"><span class="comment">    process_current = p</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    PROCESS_CONTEXT_BEGIN(&amp;ctimer_process);</span><br><span class="line"></span><br><span class="line">    etimer_set(&amp;c-&gt;etimer, t);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    #define PROCESS_CONTEXT_END(p) process_current = tmp_current; &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    PROCESS_CONTEXT_END(&amp;ctimer_process);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c-&gt;etimer.timer.interval = t;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  list_add(ctimer_list, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其中if语句展开如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(initialized) &#123; <span class="comment">//1表示ctimer_process进程已经被执行.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">tmp_current</span> = <span class="title">PROCESS_CURRENT</span>();</span></span><br><span class="line">  process_current = &amp;ctimer_process;</span><br><span class="line">  etimer_set(&amp;c-&gt;etimer, t);</span><br><span class="line">  process_current = tmp_current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="6-3-进程切换"><a href="#6-3-进程切换" class="headerlink" title="6.3 进程切换"></a>6.3 进程切换</h2><p>为什么需要进程切换再执行<code>etimer_set</code>函数呢，因为<code>etimer_set</code>会在其链表中添加新节点，并将当前进程添加进来。此处是将<code>ctimer_process</code>进程添加到etimer的链表中，这样对应的etimer事件就不会直接触发最终进程，而是触发<code>ctimer_process</code>进程，再由<code>ctimer_process</code>进程找到对应的回调函数完成事件处理。 <code>ctimer_process</code>进程中核心代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    PROCESS_YIELD_UNTIL(ev == PROCESS_EVENT_TIMER);</span><br><span class="line">    <span class="keyword">for</span>(c = list_head(ctimer_list); c != <span class="literal">NULL</span>; c = c-&gt;next) &#123;</span><br><span class="line">      <span class="keyword">if</span>(&amp;c-&gt;etimer == data) &#123;</span><br><span class="line">	      list_remove(ctimer_list, c);</span><br><span class="line">	      PROCESS_CONTEXT_BEGIN(c-&gt;p);</span><br><span class="line">	      <span class="keyword">if</span>(c-&gt;f != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	        c-&gt;f(c-&gt;ptr);</span><br><span class="line">	      &#125;</span><br><span class="line">	      PROCESS_CONTEXT_END(c-&gt;p);</span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p></p><p><code>ctimer_process</code>进程是在执行过<code>ctimer_init()</code>函数中启动的。</p><h1 id="7-rtimer"><a href="#7-rtimer" class="headerlink" title="7. rtimer"></a>7. rtimer</h1><p>实时时钟定时器，用于处理实时的、紧急的事件，被处理的事件或被调用的处理函数的运行事件必须是可评估的，防止事件处理函数执行事件过长，影响实时性能。和其它几种定时器依赖与tiemr或stimer，rtimer有独立的定时器和调度方式。<br>函数<code>RTIMER_NOW()</code>可获得当前时间，<code>TIMER_SECOND</code>指定1s钟需要多少个tiks。另外rtimer最大的特点是可以抢占其它正在运行的进程。同样也是这个特点，只有中断中可安全使用的process_poll()之类的函数可以被执行，而会引起与其它进程冲突的函数则必须要异步方式执行。<br>rtimer的API函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RTIMER_CLOCK_LT(a, b); <span class="comment">// This should give TRUE if 'a' is less than 'b', otherwise false.</span></span><br><span class="line">RTIMER_ARCH_SECOND; <span class="comment">// The number of ticks per second. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtimer_arch_init</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// Initialize the rtimer architecture code. </span></span><br><span class="line"><span class="keyword">rtimer_clock_t</span> rtimer_arch_now(); <span class="comment">// Get the current time. </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rtimer_arch_schedule</span><span class="params">(<span class="keyword">rtimer_clock_t</span> wakeup_time)</span></span>; <span class="comment">//  Schedule a call to rtimer_run_next().</span></span><br></pre></td></tr></table></figure><p></p></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/Contiki/" rel="tag"># Contiki</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2016/10/20/161020-Contiki-process-analysis-helloworld/" rel="next" title="Contiki进程分析-hello world"><i class="fa fa-chevron-left"></i> Contiki进程分析-hello world</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2016/10/24/161024-Contiki-process-etimer-process/" rel="prev" title="Contiki etimer_process进程分析">Contiki etimer_process进程分析<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview"> 站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="https://raw.githubusercontent.com/XuBovey/xubovey.github.io/source/blog_images/images/avatar.jpg" alt="xu.bovey"><p class="site-author-name" itemprop="name">xu.bovey</p><p class="site-description motion-element" itemprop="description">点点 - 滴滴</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">49</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">18</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">27</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-clock"><span class="nav-number">1.</span> <span class="nav-text">1. clock</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-timer"><span class="nav-number">2.</span> <span class="nav-text">2. timer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-stimer"><span class="nav-number">3.</span> <span class="nav-text">3. stimer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-进程事件标识符"><span class="nav-number">4.</span> <span class="nav-text">4. 进程事件标识符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-etimer"><span class="nav-number">5.</span> <span class="nav-text">5. etimer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-etimer-API函数"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 etimer API函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-etimer-process"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 etimer_process</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-ctimer"><span class="nav-number">6.</span> <span class="nav-text">6. ctimer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-ctimer的API函数"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 ctimer的API函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-举个例子"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 举个例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-进程切换"><span class="nav-number">6.3.</span> <span class="nav-text">6.3 进程切换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-rtimer"><span class="nav-number">7.</span> <span class="nav-text">7. rtimer</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2019</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">xu.bovey</span></div><div class="powered-by"> 由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info"> 主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script></body></html>